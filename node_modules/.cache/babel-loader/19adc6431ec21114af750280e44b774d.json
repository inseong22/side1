{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/filters/list\n */\nimport { Matcher, UpcastWriter } from 'ckeditor5/src/engine';\n/**\n * Transforms Word specific list-like elements to the semantic HTML lists.\n *\n * Lists in Word are represented by block elements with special attributes like:\n *\n *\t\t<p class=MsoListParagraphCxSpFirst style='mso-list:l1 level1 lfo1'>...</p> // Paragraph based list.\n *\t\t<h1 style='mso-list:l0 level1 lfo1'>...</h1> // Heading 1 based list.\n *\n * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment The view structure to be transformed.\n * @param {String} stylesString Styles from which list-like elements styling will be extracted.\n */\n\nexport function transformListItemLikeElementsIntoLists(documentFragment, stylesString) {\n  if (!documentFragment.childCount) {\n    return;\n  }\n\n  const writer = new UpcastWriter(documentFragment.document);\n  const itemLikeElements = findAllItemLikeElements(documentFragment, writer);\n\n  if (!itemLikeElements.length) {\n    return;\n  }\n\n  let currentList = null;\n  let currentIndentation = 1;\n  itemLikeElements.forEach((itemLikeElement, i) => {\n    const isDifferentList = isNewListNeeded(itemLikeElements[i - 1], itemLikeElement);\n    const previousItemLikeElement = isDifferentList ? null : itemLikeElements[i - 1];\n    const indentationDifference = getIndentationDifference(previousItemLikeElement, itemLikeElement);\n\n    if (isDifferentList) {\n      currentList = null;\n      currentIndentation = 1;\n    }\n\n    if (!currentList || indentationDifference !== 0) {\n      const listStyle = detectListStyle(itemLikeElement, stylesString);\n\n      if (!currentList) {\n        currentList = insertNewEmptyList(listStyle, itemLikeElement.element, writer);\n      } else if (itemLikeElement.indent > currentIndentation) {\n        const lastListItem = currentList.getChild(currentList.childCount - 1);\n        const lastListItemChild = lastListItem.getChild(lastListItem.childCount - 1);\n        currentList = insertNewEmptyList(listStyle, lastListItemChild, writer);\n        currentIndentation += 1;\n      } else if (itemLikeElement.indent < currentIndentation) {\n        const differentIndentation = currentIndentation - itemLikeElement.indent;\n        currentList = findParentListAtLevel(currentList, differentIndentation);\n        currentIndentation = parseInt(itemLikeElement.indent);\n      }\n\n      if (itemLikeElement.indent <= currentIndentation) {\n        if (!currentList.is('element', listStyle.type)) {\n          currentList = writer.rename(listStyle.type, currentList);\n        }\n      }\n    }\n\n    const listItem = transformElementIntoListItem(itemLikeElement.element, writer);\n    writer.appendChild(listItem, currentList);\n  });\n}\n/**\n * Removes paragraph wrapping content inside a list item.\n *\n * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment\n * @param {module:engine/view/upcastwriter~UpcastWriter} writer\n */\n\nexport function unwrapParagraphInListItem(documentFragment, writer) {\n  for (const value of writer.createRangeIn(documentFragment)) {\n    const element = value.item;\n\n    if (element.is('element', 'li')) {\n      // Google Docs allows on single paragraph inside LI.\n      const firstChild = element.getChild(0);\n\n      if (firstChild && firstChild.is('element', 'p')) {\n        writer.unwrapElement(firstChild);\n      }\n    }\n  }\n} // Finds all list-like elements in a given document fragment.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment\n// in which to look for list-like nodes.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Array.<Object>} Array of found list-like items. Each item is an object containing:\n//\n//\t\t* {module:engine/src/view/element~Element} element List-like element.\n//\t\t* {Number} id List item id parsed from `mso-list` style (see `getListItemData()` function).\n//\t\t* {Number} order List item creation order parsed from `mso-list` style (see `getListItemData()` function).\n//\t\t* {Number} indent List item indentation level parsed from `mso-list` style (see `getListItemData()` function).\n\nfunction findAllItemLikeElements(documentFragment, writer) {\n  const range = writer.createRangeIn(documentFragment); // Matcher for finding list-like elements.\n\n  const itemLikeElementsMatcher = new Matcher({\n    name: /^p|h\\d+$/,\n    styles: {\n      'mso-list': /.*/\n    }\n  });\n  const itemLikeElements = [];\n\n  for (const value of range) {\n    if (value.type === 'elementStart' && itemLikeElementsMatcher.match(value.item)) {\n      const itemData = getListItemData(value.item);\n      itemLikeElements.push({\n        element: value.item,\n        id: itemData.id,\n        order: itemData.order,\n        indent: itemData.indent\n      });\n    }\n  }\n\n  return itemLikeElements;\n} // Extracts list item style from the provided CSS.\n//\n// List item style is extracted from the CSS stylesheet. Each list with its specific style attribute\n// value (`mso-list:l1 level1 lfo1`) has its dedicated properties in a CSS stylesheet defined with a selector like:\n//\n// \t\t@list l1:level1 { ... }\n//\n// It contains `mso-level-number-format` property which defines list numbering/bullet style. If this property\n// is not defined it means default `decimal` numbering.\n//\n// Here CSS string representation is used as `mso-level-number-format` property is an invalid CSS property\n// and will be removed during CSS parsing.\n//\n// @param {Object} listLikeItem List-like item for which list style will be searched for. Usually\n// a result of `findAllItemLikeElements()` function.\n// @param {String} stylesString CSS stylesheet.\n// @returns {Object} result\n// @returns {String} result.type List type, could be `ul` or `ol`.\n// @returns {String|null} result.style List style, for example: `decimal`, `lower-roman`, etc. It is extracted\n// directly from Word stylesheet and adjusted to represent proper values for the CSS `list-style-type` property.\n// If it cannot be adjusted, the `null` value is returned.\n\n\nfunction detectListStyle(listLikeItem, stylesString) {\n  const listStyleRegexp = new RegExp(`@list l${listLikeItem.id}:level${listLikeItem.indent}\\\\s*({[^}]*)`, 'gi');\n  const listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;\n  const listStyleMatch = listStyleRegexp.exec(stylesString);\n  let listStyleType = 'decimal'; // Decimal is default one.\n\n  let type = 'ol'; // <ol> is default list.\n\n  if (listStyleMatch && listStyleMatch[1]) {\n    const listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);\n\n    if (listStyleTypeMatch && listStyleTypeMatch[1]) {\n      listStyleType = listStyleTypeMatch[1].trim();\n      type = listStyleType !== 'bullet' && listStyleType !== 'image' ? 'ol' : 'ul';\n    } // Styles for the numbered lists are always defined in the Word CSS stylesheet.\n    // Unordered lists MAY contain a value for the Word CSS definition `mso-level-text` but sometimes\n    // this tag is missing. And because of that, we cannot depend on that. We need to predict the list style value\n    // based on the list style marker element.\n\n\n    if (listStyleType === 'bullet') {\n      const bulletedStyle = findBulletedListStyle(listLikeItem.element);\n\n      if (bulletedStyle) {\n        listStyleType = bulletedStyle;\n      }\n    }\n  }\n\n  return {\n    type,\n    style: mapListStyleDefinition(listStyleType)\n  };\n} // Tries to extract the `list-style-type` value based on the marker element for bulleted list.\n//\n// @param {module:engine/view/element~Element} element\n// @returns {module:engine/view/element~Element|null}\n\n\nfunction findBulletedListStyle(element) {\n  const listMarkerElement = findListMarkerNode(element);\n\n  if (!listMarkerElement) {\n    return null;\n  }\n\n  const listMarker = listMarkerElement._data;\n\n  if (listMarker === 'o') {\n    return 'circle';\n  } else if (listMarker === '·') {\n    return 'disc';\n  } // Word returns '§' instead of '■' for the square list style.\n  else if (listMarker === '§') {\n      return 'square';\n    }\n\n  return null;\n} // Tries to find a text node that represents the marker element (list-style-type).\n//\n// @param {module:engine/view/element~Element} element\n// @returns {module:engine/view/text~Text|null}\n\n\nfunction findListMarkerNode(element) {\n  // If the first child is a text node, it is the data for the element.\n  // The list-style marker is not present here.\n  if (element.getChild(0).is('$text')) {\n    return null;\n  }\n\n  for (const childNode of element.getChildren()) {\n    // The list-style marker will be inside the `<span>` element. Let's ignore all non-span elements.\n    // It may happen that the `<a>` element is added as the first child. Most probably, it's an anchor element.\n    if (!childNode.is('element', 'span')) {\n      continue;\n    }\n\n    const textNodeOrElement = childNode.getChild(0); // If already found the marker element, use it.\n\n    if (textNodeOrElement.is('$text')) {\n      return textNodeOrElement;\n    }\n\n    return textNodeOrElement.getChild(0);\n  }\n} // Parses the `list-style-type` value extracted directly from the Word CSS stylesheet and returns proper CSS definition.\n//\n// @param {String|null} value\n// @returns {String|null}\n\n\nfunction mapListStyleDefinition(value) {\n  switch (value) {\n    case 'arabic-leading-zero':\n      return 'decimal-leading-zero';\n\n    case 'alpha-upper':\n      return 'upper-alpha';\n\n    case 'alpha-lower':\n      return 'lower-alpha';\n\n    case 'roman-upper':\n      return 'upper-roman';\n\n    case 'roman-lower':\n      return 'lower-roman';\n\n    case 'circle':\n    case 'disc':\n    case 'square':\n      return value;\n\n    default:\n      return null;\n  }\n} // Creates empty list of a given type and inserts it after a specified element.\n//\n// @param {Object} listStyle List style object which determines the type of newly created list.\n// Usually a result of `detectListStyle()` function.\n// @param {module:engine/view/element~Element} element Element after which list is inserted.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {module:engine/view/element~Element} Newly created list element.\n\n\nfunction insertNewEmptyList(listStyle, element, writer) {\n  const parent = element.parent;\n  const list = writer.createElement(listStyle.type);\n  const position = parent.getChildIndex(element) + 1;\n  writer.insertChild(position, list, parent); // We do not support modifying the marker for a particular list item.\n  // Set the value for the `list-style-type` property directly to the list container.\n\n  if (listStyle.style) {\n    writer.setStyle('list-style-type', listStyle.style, list);\n  }\n\n  return list;\n} // Transforms a given element into a semantic list item. As the function operates on a provided\n// {module:engine/src/view/element~Element element} it will modify the view structure to which this element belongs.\n//\n// @param {module:engine/view/element~Element} element Element which will be transformed into a list item.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {module:engine/view/element~Element} New element to which the given one was transformed. It is\n// inserted in place of the old element (the reference to the old element is lost due to renaming).\n\n\nfunction transformElementIntoListItem(element, writer) {\n  removeBulletElement(element, writer);\n  return writer.rename('li', element);\n} // Extracts list item information from Word specific list-like element style:\n//\n//\t\t`style=\"mso-list:l1 level1 lfo1\"`\n//\n// where:\n//\n//\t\t* `l1` is a list id (however it does not mean this is a continuous list - see #43),\n//\t\t* `level1` is a list item indentation level,\n//\t\t* `lfo1` is a list insertion order in a document.\n//\n// @param {module:engine/view/element~Element} element Element from which style data is extracted.\n// @returns {Object} result\n// @returns {Number} result.id Parent list id.\n// @returns {Number} result.order List item creation order.\n// @returns {Number} result.indent List item indentation level.\n\n\nfunction getListItemData(element) {\n  const data = {};\n  const listStyle = element.getStyle('mso-list');\n\n  if (listStyle) {\n    const idMatch = listStyle.match(/(^|\\s{1,100})l(\\d+)/i);\n    const orderMatch = listStyle.match(/\\s{0,100}lfo(\\d+)/i);\n    const indentMatch = listStyle.match(/\\s{0,100}level(\\d+)/i);\n\n    if (idMatch && orderMatch && indentMatch) {\n      data.id = idMatch[2];\n      data.order = orderMatch[1];\n      data.indent = indentMatch[1];\n    }\n  }\n\n  return data;\n} // Removes span with a numbering/bullet from a given element.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n\n\nfunction removeBulletElement(element, writer) {\n  // Matcher for finding `span` elements holding lists numbering/bullets.\n  const bulletMatcher = new Matcher({\n    name: 'span',\n    styles: {\n      'mso-list': 'Ignore'\n    }\n  });\n  const range = writer.createRangeIn(element);\n\n  for (const value of range) {\n    if (value.type === 'elementStart' && bulletMatcher.match(value.item)) {\n      writer.remove(value.item);\n    }\n  }\n} // Whether the previous and current items belong to the same list. It is determined based on `item.id`\n// (extracted from `mso-list` style, see #getListItemData) and a previous sibling of the current item.\n//\n// However, it's quite easy to change the `id` attribute for nested lists in Word. It will break the list feature while pasting.\n// Let's check also the `indent` attribute. If the difference between those two elements is equal to 1, we can assume that\n// the `currentItem` is a beginning of the nested list because lists in CKEditor 5 always start with the `indent=0` attribute.\n// See: https://github.com/ckeditor/ckeditor5/issues/7805.\n//\n// @param {Object} previousItem\n// @param {Object} currentItem\n// @returns {Boolean}\n\n\nfunction isNewListNeeded(previousItem, currentItem) {\n  if (!previousItem) {\n    return true;\n  }\n\n  if (previousItem.id !== currentItem.id) {\n    // See: https://github.com/ckeditor/ckeditor5/issues/7805.\n    //\n    // * List item 1.\n    //     - Nested list item 1.\n    if (currentItem.indent - previousItem.indent === 1) {\n      return false;\n    }\n\n    return true;\n  }\n\n  const previousSibling = currentItem.element.previousSibling;\n\n  if (!previousSibling) {\n    return true;\n  } // Even with the same id the list does not have to be continuous (#43).\n\n\n  return !isList(previousSibling);\n}\n\nfunction isList(element) {\n  return element.is('element', 'ol') || element.is('element', 'ul');\n} // Calculates the indentation difference between two given list items (based on the indent attribute\n// extracted from the `mso-list` style, see #getListItemData).\n//\n// @param {Object} previousItem\n// @param {Object} currentItem\n// @returns {Number}\n\n\nfunction getIndentationDifference(previousItem, currentItem) {\n  return previousItem ? currentItem.indent - previousItem.indent : currentItem.indent - 1;\n} // Finds the parent list element (ul/ol) of a given list element with indentation level lower by a given value.\n//\n// @param {module:engine/view/element~Element} listElement List element from which to start looking for a parent list.\n// @param {Number} indentationDifference Indentation difference between lists.\n// @returns {module:engine/view/element~Element} Found list element with indentation level lower by a given value.\n\n\nfunction findParentListAtLevel(listElement, indentationDifference) {\n  const ancestors = listElement.getAncestors({\n    parentFirst: true\n  });\n  let parentList = null;\n  let levelChange = 0;\n\n  for (const ancestor of ancestors) {\n    if (ancestor.name === 'ul' || ancestor.name === 'ol') {\n      levelChange++;\n    }\n\n    if (levelChange === indentationDifference) {\n      parentList = ancestor;\n      break;\n    }\n  }\n\n  return parentList;\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/list.js"],"names":["Matcher","UpcastWriter","transformListItemLikeElementsIntoLists","documentFragment","stylesString","childCount","writer","document","itemLikeElements","findAllItemLikeElements","length","currentList","currentIndentation","forEach","itemLikeElement","i","isDifferentList","isNewListNeeded","previousItemLikeElement","indentationDifference","getIndentationDifference","listStyle","detectListStyle","insertNewEmptyList","element","indent","lastListItem","getChild","lastListItemChild","differentIndentation","findParentListAtLevel","parseInt","is","type","rename","listItem","transformElementIntoListItem","appendChild","unwrapParagraphInListItem","value","createRangeIn","item","firstChild","unwrapElement","range","itemLikeElementsMatcher","name","styles","match","itemData","getListItemData","push","id","order","listLikeItem","listStyleRegexp","RegExp","listStyleTypeRegex","listStyleMatch","exec","listStyleType","listStyleTypeMatch","trim","bulletedStyle","findBulletedListStyle","style","mapListStyleDefinition","listMarkerElement","findListMarkerNode","listMarker","_data","childNode","getChildren","textNodeOrElement","parent","list","createElement","position","getChildIndex","insertChild","setStyle","removeBulletElement","data","getStyle","idMatch","orderMatch","indentMatch","bulletMatcher","remove","previousItem","currentItem","previousSibling","isList","listElement","ancestors","getAncestors","parentFirst","parentList","levelChange","ancestor"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/filters/list\n */\n\nimport { Matcher, UpcastWriter } from 'ckeditor5/src/engine';\n\n/**\n * Transforms Word specific list-like elements to the semantic HTML lists.\n *\n * Lists in Word are represented by block elements with special attributes like:\n *\n *\t\t<p class=MsoListParagraphCxSpFirst style='mso-list:l1 level1 lfo1'>...</p> // Paragraph based list.\n *\t\t<h1 style='mso-list:l0 level1 lfo1'>...</h1> // Heading 1 based list.\n *\n * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment The view structure to be transformed.\n * @param {String} stylesString Styles from which list-like elements styling will be extracted.\n */\nexport function transformListItemLikeElementsIntoLists( documentFragment, stylesString ) {\n\tif ( !documentFragment.childCount ) {\n\t\treturn;\n\t}\n\n\tconst writer = new UpcastWriter( documentFragment.document );\n\tconst itemLikeElements = findAllItemLikeElements( documentFragment, writer );\n\n\tif ( !itemLikeElements.length ) {\n\t\treturn;\n\t}\n\n\tlet currentList = null;\n\tlet currentIndentation = 1;\n\n\titemLikeElements.forEach( ( itemLikeElement, i ) => {\n\t\tconst isDifferentList = isNewListNeeded( itemLikeElements[ i - 1 ], itemLikeElement );\n\t\tconst previousItemLikeElement = isDifferentList ? null : itemLikeElements[ i - 1 ];\n\t\tconst indentationDifference = getIndentationDifference( previousItemLikeElement, itemLikeElement );\n\n\t\tif ( isDifferentList ) {\n\t\t\tcurrentList = null;\n\t\t\tcurrentIndentation = 1;\n\t\t}\n\n\t\tif ( !currentList || indentationDifference !== 0 ) {\n\t\t\tconst listStyle = detectListStyle( itemLikeElement, stylesString );\n\n\t\t\tif ( !currentList ) {\n\t\t\t\tcurrentList = insertNewEmptyList( listStyle, itemLikeElement.element, writer );\n\t\t\t} else if ( itemLikeElement.indent > currentIndentation ) {\n\t\t\t\tconst lastListItem = currentList.getChild( currentList.childCount - 1 );\n\t\t\t\tconst lastListItemChild = lastListItem.getChild( lastListItem.childCount - 1 );\n\n\t\t\t\tcurrentList = insertNewEmptyList( listStyle, lastListItemChild, writer );\n\t\t\t\tcurrentIndentation += 1;\n\t\t\t} else if ( itemLikeElement.indent < currentIndentation ) {\n\t\t\t\tconst differentIndentation = currentIndentation - itemLikeElement.indent;\n\n\t\t\t\tcurrentList = findParentListAtLevel( currentList, differentIndentation );\n\t\t\t\tcurrentIndentation = parseInt( itemLikeElement.indent );\n\t\t\t}\n\n\t\t\tif ( itemLikeElement.indent <= currentIndentation ) {\n\t\t\t\tif ( !currentList.is( 'element', listStyle.type ) ) {\n\t\t\t\t\tcurrentList = writer.rename( listStyle.type, currentList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst listItem = transformElementIntoListItem( itemLikeElement.element, writer );\n\n\t\twriter.appendChild( listItem, currentList );\n\t} );\n}\n\n/**\n * Removes paragraph wrapping content inside a list item.\n *\n * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment\n * @param {module:engine/view/upcastwriter~UpcastWriter} writer\n */\nexport function unwrapParagraphInListItem( documentFragment, writer ) {\n\tfor ( const value of writer.createRangeIn( documentFragment ) ) {\n\t\tconst element = value.item;\n\n\t\tif ( element.is( 'element', 'li' ) ) {\n\t\t\t// Google Docs allows on single paragraph inside LI.\n\t\t\tconst firstChild = element.getChild( 0 );\n\n\t\t\tif ( firstChild && firstChild.is( 'element', 'p' ) ) {\n\t\t\t\twriter.unwrapElement( firstChild );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Finds all list-like elements in a given document fragment.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment\n// in which to look for list-like nodes.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Array.<Object>} Array of found list-like items. Each item is an object containing:\n//\n//\t\t* {module:engine/src/view/element~Element} element List-like element.\n//\t\t* {Number} id List item id parsed from `mso-list` style (see `getListItemData()` function).\n//\t\t* {Number} order List item creation order parsed from `mso-list` style (see `getListItemData()` function).\n//\t\t* {Number} indent List item indentation level parsed from `mso-list` style (see `getListItemData()` function).\nfunction findAllItemLikeElements( documentFragment, writer ) {\n\tconst range = writer.createRangeIn( documentFragment );\n\n\t// Matcher for finding list-like elements.\n\tconst itemLikeElementsMatcher = new Matcher( {\n\t\tname: /^p|h\\d+$/,\n\t\tstyles: {\n\t\t\t'mso-list': /.*/\n\t\t}\n\t} );\n\n\tconst itemLikeElements = [];\n\n\tfor ( const value of range ) {\n\t\tif ( value.type === 'elementStart' && itemLikeElementsMatcher.match( value.item ) ) {\n\t\t\tconst itemData = getListItemData( value.item );\n\n\t\t\titemLikeElements.push( {\n\t\t\t\telement: value.item,\n\t\t\t\tid: itemData.id,\n\t\t\t\torder: itemData.order,\n\t\t\t\tindent: itemData.indent\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn itemLikeElements;\n}\n\n// Extracts list item style from the provided CSS.\n//\n// List item style is extracted from the CSS stylesheet. Each list with its specific style attribute\n// value (`mso-list:l1 level1 lfo1`) has its dedicated properties in a CSS stylesheet defined with a selector like:\n//\n// \t\t@list l1:level1 { ... }\n//\n// It contains `mso-level-number-format` property which defines list numbering/bullet style. If this property\n// is not defined it means default `decimal` numbering.\n//\n// Here CSS string representation is used as `mso-level-number-format` property is an invalid CSS property\n// and will be removed during CSS parsing.\n//\n// @param {Object} listLikeItem List-like item for which list style will be searched for. Usually\n// a result of `findAllItemLikeElements()` function.\n// @param {String} stylesString CSS stylesheet.\n// @returns {Object} result\n// @returns {String} result.type List type, could be `ul` or `ol`.\n// @returns {String|null} result.style List style, for example: `decimal`, `lower-roman`, etc. It is extracted\n// directly from Word stylesheet and adjusted to represent proper values for the CSS `list-style-type` property.\n// If it cannot be adjusted, the `null` value is returned.\nfunction detectListStyle( listLikeItem, stylesString ) {\n\tconst listStyleRegexp = new RegExp( `@list l${ listLikeItem.id }:level${ listLikeItem.indent }\\\\s*({[^}]*)`, 'gi' );\n\tconst listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;\n\n\tconst listStyleMatch = listStyleRegexp.exec( stylesString );\n\n\tlet listStyleType = 'decimal'; // Decimal is default one.\n\tlet type = 'ol'; // <ol> is default list.\n\n\tif ( listStyleMatch && listStyleMatch[ 1 ] ) {\n\t\tconst listStyleTypeMatch = listStyleTypeRegex.exec( listStyleMatch[ 1 ] );\n\n\t\tif ( listStyleTypeMatch && listStyleTypeMatch[ 1 ] ) {\n\t\t\tlistStyleType = listStyleTypeMatch[ 1 ].trim();\n\t\t\ttype = listStyleType !== 'bullet' && listStyleType !== 'image' ? 'ol' : 'ul';\n\t\t}\n\n\t\t// Styles for the numbered lists are always defined in the Word CSS stylesheet.\n\t\t// Unordered lists MAY contain a value for the Word CSS definition `mso-level-text` but sometimes\n\t\t// this tag is missing. And because of that, we cannot depend on that. We need to predict the list style value\n\t\t// based on the list style marker element.\n\t\tif ( listStyleType === 'bullet' ) {\n\t\t\tconst bulletedStyle = findBulletedListStyle( listLikeItem.element );\n\n\t\t\tif ( bulletedStyle ) {\n\t\t\t\tlistStyleType = bulletedStyle;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\ttype,\n\t\tstyle: mapListStyleDefinition( listStyleType )\n\t};\n}\n\n// Tries to extract the `list-style-type` value based on the marker element for bulleted list.\n//\n// @param {module:engine/view/element~Element} element\n// @returns {module:engine/view/element~Element|null}\nfunction findBulletedListStyle( element ) {\n\tconst listMarkerElement = findListMarkerNode( element );\n\n\tif ( !listMarkerElement ) {\n\t\treturn null;\n\t}\n\n\tconst listMarker = listMarkerElement._data;\n\n\tif ( listMarker === 'o' ) {\n\t\treturn 'circle';\n\t} else if ( listMarker === '·' ) {\n\t\treturn 'disc';\n\t}\n\t// Word returns '§' instead of '■' for the square list style.\n\telse if ( listMarker === '§' ) {\n\t\treturn 'square';\n\t}\n\n\treturn null;\n}\n\n// Tries to find a text node that represents the marker element (list-style-type).\n//\n// @param {module:engine/view/element~Element} element\n// @returns {module:engine/view/text~Text|null}\nfunction findListMarkerNode( element ) {\n\t// If the first child is a text node, it is the data for the element.\n\t// The list-style marker is not present here.\n\tif ( element.getChild( 0 ).is( '$text' ) ) {\n\t\treturn null;\n\t}\n\n\tfor ( const childNode of element.getChildren() ) {\n\t\t// The list-style marker will be inside the `<span>` element. Let's ignore all non-span elements.\n\t\t// It may happen that the `<a>` element is added as the first child. Most probably, it's an anchor element.\n\t\tif ( !childNode.is( 'element', 'span' ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst textNodeOrElement = childNode.getChild( 0 );\n\n\t\t// If already found the marker element, use it.\n\t\tif ( textNodeOrElement.is( '$text' ) ) {\n\t\t\treturn textNodeOrElement;\n\t\t}\n\n\t\treturn textNodeOrElement.getChild( 0 );\n\t}\n}\n\n// Parses the `list-style-type` value extracted directly from the Word CSS stylesheet and returns proper CSS definition.\n//\n// @param {String|null} value\n// @returns {String|null}\nfunction mapListStyleDefinition( value ) {\n\tswitch ( value ) {\n\t\tcase 'arabic-leading-zero':\n\t\t\treturn 'decimal-leading-zero';\n\t\tcase 'alpha-upper':\n\t\t\treturn 'upper-alpha';\n\t\tcase 'alpha-lower':\n\t\t\treturn 'lower-alpha';\n\t\tcase 'roman-upper':\n\t\t\treturn 'upper-roman';\n\t\tcase 'roman-lower':\n\t\t\treturn 'lower-roman';\n\t\tcase 'circle':\n\t\tcase 'disc':\n\t\tcase 'square':\n\t\t\treturn value;\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n// Creates empty list of a given type and inserts it after a specified element.\n//\n// @param {Object} listStyle List style object which determines the type of newly created list.\n// Usually a result of `detectListStyle()` function.\n// @param {module:engine/view/element~Element} element Element after which list is inserted.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {module:engine/view/element~Element} Newly created list element.\n\nfunction insertNewEmptyList( listStyle, element, writer ) {\n\tconst parent = element.parent;\n\tconst list = writer.createElement( listStyle.type );\n\tconst position = parent.getChildIndex( element ) + 1;\n\n\twriter.insertChild( position, list, parent );\n\n\t// We do not support modifying the marker for a particular list item.\n\t// Set the value for the `list-style-type` property directly to the list container.\n\tif ( listStyle.style ) {\n\t\twriter.setStyle( 'list-style-type', listStyle.style, list );\n\t}\n\n\treturn list;\n}\n\n// Transforms a given element into a semantic list item. As the function operates on a provided\n// {module:engine/src/view/element~Element element} it will modify the view structure to which this element belongs.\n//\n// @param {module:engine/view/element~Element} element Element which will be transformed into a list item.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {module:engine/view/element~Element} New element to which the given one was transformed. It is\n// inserted in place of the old element (the reference to the old element is lost due to renaming).\nfunction transformElementIntoListItem( element, writer ) {\n\tremoveBulletElement( element, writer );\n\n\treturn writer.rename( 'li', element );\n}\n\n// Extracts list item information from Word specific list-like element style:\n//\n//\t\t`style=\"mso-list:l1 level1 lfo1\"`\n//\n// where:\n//\n//\t\t* `l1` is a list id (however it does not mean this is a continuous list - see #43),\n//\t\t* `level1` is a list item indentation level,\n//\t\t* `lfo1` is a list insertion order in a document.\n//\n// @param {module:engine/view/element~Element} element Element from which style data is extracted.\n// @returns {Object} result\n// @returns {Number} result.id Parent list id.\n// @returns {Number} result.order List item creation order.\n// @returns {Number} result.indent List item indentation level.\nfunction getListItemData( element ) {\n\tconst data = {};\n\tconst listStyle = element.getStyle( 'mso-list' );\n\n\tif ( listStyle ) {\n\t\tconst idMatch = listStyle.match( /(^|\\s{1,100})l(\\d+)/i );\n\t\tconst orderMatch = listStyle.match( /\\s{0,100}lfo(\\d+)/i );\n\t\tconst indentMatch = listStyle.match( /\\s{0,100}level(\\d+)/i );\n\n\t\tif ( idMatch && orderMatch && indentMatch ) {\n\t\t\tdata.id = idMatch[ 2 ];\n\t\t\tdata.order = orderMatch[ 1 ];\n\t\t\tdata.indent = indentMatch[ 1 ];\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// Removes span with a numbering/bullet from a given element.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\nfunction removeBulletElement( element, writer ) {\n\t// Matcher for finding `span` elements holding lists numbering/bullets.\n\tconst bulletMatcher = new Matcher( {\n\t\tname: 'span',\n\t\tstyles: {\n\t\t\t'mso-list': 'Ignore'\n\t\t}\n\t} );\n\n\tconst range = writer.createRangeIn( element );\n\n\tfor ( const value of range ) {\n\t\tif ( value.type === 'elementStart' && bulletMatcher.match( value.item ) ) {\n\t\t\twriter.remove( value.item );\n\t\t}\n\t}\n}\n\n// Whether the previous and current items belong to the same list. It is determined based on `item.id`\n// (extracted from `mso-list` style, see #getListItemData) and a previous sibling of the current item.\n//\n// However, it's quite easy to change the `id` attribute for nested lists in Word. It will break the list feature while pasting.\n// Let's check also the `indent` attribute. If the difference between those two elements is equal to 1, we can assume that\n// the `currentItem` is a beginning of the nested list because lists in CKEditor 5 always start with the `indent=0` attribute.\n// See: https://github.com/ckeditor/ckeditor5/issues/7805.\n//\n// @param {Object} previousItem\n// @param {Object} currentItem\n// @returns {Boolean}\nfunction isNewListNeeded( previousItem, currentItem ) {\n\tif ( !previousItem ) {\n\t\treturn true;\n\t}\n\n\tif ( previousItem.id !== currentItem.id ) {\n\t\t// See: https://github.com/ckeditor/ckeditor5/issues/7805.\n\t\t//\n\t\t// * List item 1.\n\t\t//     - Nested list item 1.\n\t\tif ( currentItem.indent - previousItem.indent === 1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconst previousSibling = currentItem.element.previousSibling;\n\n\tif ( !previousSibling ) {\n\t\treturn true;\n\t}\n\n\t// Even with the same id the list does not have to be continuous (#43).\n\treturn !isList( previousSibling );\n}\n\nfunction isList( element ) {\n\treturn element.is( 'element', 'ol' ) || element.is( 'element', 'ul' );\n}\n\n// Calculates the indentation difference between two given list items (based on the indent attribute\n// extracted from the `mso-list` style, see #getListItemData).\n//\n// @param {Object} previousItem\n// @param {Object} currentItem\n// @returns {Number}\nfunction getIndentationDifference( previousItem, currentItem ) {\n\treturn previousItem ? currentItem.indent - previousItem.indent : currentItem.indent - 1;\n}\n\n// Finds the parent list element (ul/ol) of a given list element with indentation level lower by a given value.\n//\n// @param {module:engine/view/element~Element} listElement List element from which to start looking for a parent list.\n// @param {Number} indentationDifference Indentation difference between lists.\n// @returns {module:engine/view/element~Element} Found list element with indentation level lower by a given value.\nfunction findParentListAtLevel( listElement, indentationDifference ) {\n\tconst ancestors = listElement.getAncestors( { parentFirst: true } );\n\n\tlet parentList = null;\n\tlet levelChange = 0;\n\n\tfor ( const ancestor of ancestors ) {\n\t\tif ( ancestor.name === 'ul' || ancestor.name === 'ol' ) {\n\t\t\tlevelChange++;\n\t\t}\n\n\t\tif ( levelChange === indentationDifference ) {\n\t\t\tparentList = ancestor;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn parentList;\n}\n"]},"metadata":{},"sourceType":"module"}