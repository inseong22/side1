{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injecttypingmutationshandling\n */\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport DomConverter from '@ckeditor/ckeditor5-engine/src/view/domconverter';\nimport { getSingleTextNodeChange, containerChildrenMutated } from './utils';\n/**\n * Handles mutations caused by normal typing.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\n\nexport default function injectTypingMutationsHandling(editor) {\n  editor.editing.view.document.on('mutations', (evt, mutations, viewSelection) => {\n    new MutationHandler(editor).handle(mutations, viewSelection);\n  });\n}\n/**\n * Helper class for translating DOM mutations into model changes.\n *\n * @private\n */\n\nclass MutationHandler {\n  /**\n   * Creates an instance of the mutation handler.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   */\n  constructor(editor) {\n    /**\n     * Editor instance for which mutations are handled.\n     *\n     * @readonly\n     * @member {module:core/editor/editor~Editor} #editor\n     */\n    this.editor = editor;\n    /**\n     * The editing controller.\n     *\n     * @readonly\n     * @member {module:engine/controller/editingcontroller~EditingController} #editing\n     */\n\n    this.editing = this.editor.editing;\n  }\n  /**\n   * Handles given mutations.\n   *\n   * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n   * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n   * @param {module:engine/view/selection~Selection|null} viewSelection\n   */\n\n\n  handle(mutations, viewSelection) {\n    if (containerChildrenMutated(mutations)) {\n      this._handleContainerChildrenMutations(mutations, viewSelection);\n    } else {\n      for (const mutation of mutations) {\n        // Fortunately it will never be both.\n        this._handleTextMutation(mutation, viewSelection);\n\n        this._handleTextNodeInsertion(mutation);\n      }\n    }\n  }\n  /**\n   * Handles situations when container's children mutated during input. This can happen when\n   * the browser is trying to \"fix\" DOM in certain situations. For example, when the user starts to type\n   * in `<p><a href=\"\"><i>Link{}</i></a></p>`, the browser might change the order of elements\n   * to `<p><i><a href=\"\">Link</a>x{}</i></p>`. A similar situation happens when the spell checker\n   * replaces a word wrapped with `<strong>` with a word wrapped with a `<b>` element.\n   *\n   * To handle such situations, the common DOM ancestor of all mutations is converted to the model representation\n   * and then compared with the current model to calculate the proper text change.\n   *\n   * Note: Single text node insertion is handled in {@link #_handleTextNodeInsertion} and text node mutation is handled\n   * in {@link #_handleTextMutation}).\n   *\n   * @private\n   * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n   * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n   * @param {module:engine/view/selection~Selection|null} viewSelection\n   */\n\n\n  _handleContainerChildrenMutations(mutations, viewSelection) {\n    // Get common ancestor of all mutations.\n    const mutationsCommonAncestor = getMutationsContainer(mutations); // Quit if there is no common ancestor.\n\n    if (!mutationsCommonAncestor) {\n      return;\n    }\n\n    const domConverter = this.editor.editing.view.domConverter; // Get common ancestor in DOM.\n\n    const domMutationCommonAncestor = domConverter.mapViewToDom(mutationsCommonAncestor); // Create fresh DomConverter so it will not use existing mapping and convert current DOM to model.\n    // This wouldn't be needed if DomConverter would allow to create fresh view without checking any mappings.\n\n    const freshDomConverter = new DomConverter(this.editor.editing.view.document);\n    const modelFromCurrentDom = this.editor.data.toModel(freshDomConverter.domToView(domMutationCommonAncestor)).getChild(0); // Current model.\n\n    const currentModel = this.editor.editing.mapper.toModelElement(mutationsCommonAncestor); // If common ancestor is not mapped, do not do anything. It probably is a parent of another view element.\n    // That means that we would need to diff model elements (see `if` below). Better return early instead of\n    // trying to get a reasonable model ancestor. It will fell into the `if` below anyway.\n    // This situation happens for example for lists. If `<ul>` is a common ancestor, `currentModel` is `undefined`\n    // because `<ul>` is not mapped (`<li>`s are).\n    // See https://github.com/ckeditor/ckeditor5/issues/718.\n\n    if (!currentModel) {\n      return;\n    } // Get children from both ancestors.\n\n\n    const modelFromDomChildren = Array.from(modelFromCurrentDom.getChildren());\n    const currentModelChildren = Array.from(currentModel.getChildren()); // Remove the last `<softBreak>` from the end of `modelFromDomChildren` if there is no `<softBreak>` in current model.\n    // If the described scenario happened, it means that this is a bogus `<br />` added by a browser.\n\n    const lastDomChild = modelFromDomChildren[modelFromDomChildren.length - 1];\n    const lastCurrentChild = currentModelChildren[currentModelChildren.length - 1];\n    const isLastDomChildSoftBreak = lastDomChild && lastDomChild.is('element', 'softBreak');\n    const isLastCurrentChildSoftBreak = lastCurrentChild && !lastCurrentChild.is('element', 'softBreak');\n\n    if (isLastDomChildSoftBreak && isLastCurrentChildSoftBreak) {\n      modelFromDomChildren.pop();\n    }\n\n    const schema = this.editor.model.schema; // Skip situations when common ancestor has any container elements.\n\n    if (!isSafeForTextMutation(modelFromDomChildren, schema) || !isSafeForTextMutation(currentModelChildren, schema)) {\n      return;\n    } // Replace &nbsp; inserted by the browser with normal space. See comment in `_handleTextMutation`.\n    // Replace non-texts with any character. This is potentially dangerous but passes in manual tests. The thing is\n    // that we need to take care of proper indexes so we cannot simply remove non-text elements from the content.\n    // By inserting a character we keep all the real texts on their indexes.\n\n\n    const newText = modelFromDomChildren.map(item => item.is('$text') ? item.data : '@').join('').replace(/\\u00A0/g, ' ');\n    const oldText = currentModelChildren.map(item => item.is('$text') ? item.data : '@').join('').replace(/\\u00A0/g, ' '); // Do nothing if mutations created same text.\n\n    if (oldText === newText) {\n      return;\n    }\n\n    const diffResult = diff(oldText, newText);\n    const {\n      firstChangeAt,\n      insertions,\n      deletions\n    } = calculateChanges(diffResult); // Try setting new model selection according to passed view selection.\n\n    let modelSelectionRange = null;\n\n    if (viewSelection) {\n      modelSelectionRange = this.editing.mapper.toModelRange(viewSelection.getFirstRange());\n    }\n\n    const insertText = newText.substr(firstChangeAt, insertions);\n    const removeRange = this.editor.model.createRange(this.editor.model.createPositionAt(currentModel, firstChangeAt), this.editor.model.createPositionAt(currentModel, firstChangeAt + deletions));\n    this.editor.execute('input', {\n      text: insertText,\n      range: removeRange,\n      resultRange: modelSelectionRange\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleTextMutation(mutation, viewSelection) {\n    if (mutation.type != 'text') {\n      return;\n    } // Replace &nbsp; inserted by the browser with normal space.\n    // We want only normal spaces in the model and in the view. Renderer and DOM Converter will be then responsible\n    // for rendering consecutive spaces using &nbsp;, but the model and the view has to be clear.\n    // Other feature may introduce inserting non-breakable space on specific key stroke (for example shift + space).\n    // However then it will be handled outside of mutations, like enter key is.\n    // The replacing is here because it has to be done before `diff` and `diffToChanges` functions, as they\n    // take `newText` and compare it to (cleaned up) view.\n    // It could also be done in mutation observer too, however if any outside plugin would like to\n    // introduce additional events for mutations, they would get already cleaned up version (this may be good or not).\n\n\n    const newText = mutation.newText.replace(/\\u00A0/g, ' '); // To have correct `diffResult`, we also compare view node text data with &nbsp; replaced by space.\n\n    const oldText = mutation.oldText.replace(/\\u00A0/g, ' '); // Do nothing if mutations created same text.\n\n    if (oldText === newText) {\n      return;\n    }\n\n    const diffResult = diff(oldText, newText);\n    const {\n      firstChangeAt,\n      insertions,\n      deletions\n    } = calculateChanges(diffResult); // Try setting new model selection according to passed view selection.\n\n    let modelSelectionRange = null;\n\n    if (viewSelection) {\n      modelSelectionRange = this.editing.mapper.toModelRange(viewSelection.getFirstRange());\n    } // Get the position in view and model where the changes will happen.\n\n\n    const viewPos = this.editing.view.createPositionAt(mutation.node, firstChangeAt);\n    const modelPos = this.editing.mapper.toModelPosition(viewPos);\n    const removeRange = this.editor.model.createRange(modelPos, modelPos.getShiftedBy(deletions));\n    const insertText = newText.substr(firstChangeAt, insertions);\n    this.editor.execute('input', {\n      text: insertText,\n      range: removeRange,\n      resultRange: modelSelectionRange\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleTextNodeInsertion(mutation) {\n    if (mutation.type != 'children') {\n      return;\n    }\n\n    const change = getSingleTextNodeChange(mutation);\n    const viewPos = this.editing.view.createPositionAt(mutation.node, change.index);\n    const modelPos = this.editing.mapper.toModelPosition(viewPos);\n    const insertedText = change.values[0].data;\n    this.editor.execute('input', {\n      // Replace &nbsp; inserted by the browser with normal space.\n      // See comment in `_handleTextMutation`.\n      // In this case we don't need to do this before `diff` because we diff whole nodes.\n      // Just change &nbsp; in case there are some.\n      text: insertedText.replace(/\\u00A0/g, ' '),\n      range: this.editor.model.createRange(modelPos)\n    });\n  }\n\n} // Returns first common ancestor of all mutations that is either {@link module:engine/view/containerelement~ContainerElement}\n// or {@link module:engine/view/rootelement~RootElement}.\n//\n// @private\n// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n// @returns {module:engine/view/containerelement~ContainerElement|engine/view/rootelement~RootElement|undefined}\n\n\nfunction getMutationsContainer(mutations) {\n  const lca = mutations.map(mutation => mutation.node).reduce((commonAncestor, node) => {\n    return commonAncestor.getCommonAncestor(node, {\n      includeSelf: true\n    });\n  });\n\n  if (!lca) {\n    return;\n  } // We need to look for container and root elements only, so check all LCA's\n  // ancestors (starting from itself).\n\n\n  return lca.getAncestors({\n    includeSelf: true,\n    parentFirst: true\n  }).find(element => element.is('containerElement') || element.is('rootElement'));\n} // Returns true if provided array contains content that won't be problematic during diffing and text mutation handling.\n//\n// @param {Array.<module:engine/model/node~Node>} children\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\n\n\nfunction isSafeForTextMutation(children, schema) {\n  return children.every(child => schema.isInline(child));\n} // Calculates first change index and number of characters that should be inserted and deleted starting from that index.\n//\n// @private\n// @param diffResult\n// @returns {{insertions: number, deletions: number, firstChangeAt: *}}\n\n\nfunction calculateChanges(diffResult) {\n  // Index where the first change happens. Used to set the position from which nodes will be removed and where will be inserted.\n  let firstChangeAt = null; // Index where the last change happens. Used to properly count how many characters have to be removed and inserted.\n\n  let lastChangeAt = null; // Get `firstChangeAt` and `lastChangeAt`.\n\n  for (let i = 0; i < diffResult.length; i++) {\n    const change = diffResult[i];\n\n    if (change != 'equal') {\n      firstChangeAt = firstChangeAt === null ? i : firstChangeAt;\n      lastChangeAt = i;\n    }\n  } // How many characters, starting from `firstChangeAt`, should be removed.\n\n\n  let deletions = 0; // How many characters, starting from `firstChangeAt`, should be inserted.\n\n  let insertions = 0;\n\n  for (let i = firstChangeAt; i <= lastChangeAt; i++) {\n    // If there is no change (equal) or delete, the character is existing in `oldText`. We count it for removing.\n    if (diffResult[i] != 'insert') {\n      deletions++;\n    } // If there is no change (equal) or insert, the character is existing in `newText`. We count it for inserting.\n\n\n    if (diffResult[i] != 'delete') {\n      insertions++;\n    }\n  }\n\n  return {\n    insertions,\n    deletions,\n    firstChangeAt\n  };\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-typing/src/utils/injecttypingmutationshandling.js"],"names":["diff","DomConverter","getSingleTextNodeChange","containerChildrenMutated","injectTypingMutationsHandling","editor","editing","view","document","on","evt","mutations","viewSelection","MutationHandler","handle","constructor","_handleContainerChildrenMutations","mutation","_handleTextMutation","_handleTextNodeInsertion","mutationsCommonAncestor","getMutationsContainer","domConverter","domMutationCommonAncestor","mapViewToDom","freshDomConverter","modelFromCurrentDom","data","toModel","domToView","getChild","currentModel","mapper","toModelElement","modelFromDomChildren","Array","from","getChildren","currentModelChildren","lastDomChild","length","lastCurrentChild","isLastDomChildSoftBreak","is","isLastCurrentChildSoftBreak","pop","schema","model","isSafeForTextMutation","newText","map","item","join","replace","oldText","diffResult","firstChangeAt","insertions","deletions","calculateChanges","modelSelectionRange","toModelRange","getFirstRange","insertText","substr","removeRange","createRange","createPositionAt","execute","text","range","resultRange","type","viewPos","node","modelPos","toModelPosition","getShiftedBy","change","index","insertedText","values","lca","reduce","commonAncestor","getCommonAncestor","includeSelf","getAncestors","parentFirst","find","element","children","every","child","isInline","lastChangeAt","i"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injecttypingmutationshandling\n */\n\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport DomConverter from '@ckeditor/ckeditor5-engine/src/view/domconverter';\n\nimport { getSingleTextNodeChange, containerChildrenMutated } from './utils';\n\n/**\n * Handles mutations caused by normal typing.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\nexport default function injectTypingMutationsHandling( editor ) {\n\teditor.editing.view.document.on( 'mutations', ( evt, mutations, viewSelection ) => {\n\t\tnew MutationHandler( editor ).handle( mutations, viewSelection );\n\t} );\n}\n\n/**\n * Helper class for translating DOM mutations into model changes.\n *\n * @private\n */\nclass MutationHandler {\n\t/**\n\t * Creates an instance of the mutation handler.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t */\n\tconstructor( editor ) {\n\t\t/**\n\t\t * Editor instance for which mutations are handled.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/editor/editor~Editor} #editor\n\t\t */\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * The editing controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/controller/editingcontroller~EditingController} #editing\n\t\t */\n\t\tthis.editing = this.editor.editing;\n\t}\n\n\t/**\n\t * Handles given mutations.\n\t *\n\t * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n\t * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n\t * @param {module:engine/view/selection~Selection|null} viewSelection\n\t */\n\thandle( mutations, viewSelection ) {\n\t\tif ( containerChildrenMutated( mutations ) ) {\n\t\t\tthis._handleContainerChildrenMutations( mutations, viewSelection );\n\t\t} else {\n\t\t\tfor ( const mutation of mutations ) {\n\t\t\t\t// Fortunately it will never be both.\n\t\t\t\tthis._handleTextMutation( mutation, viewSelection );\n\t\t\t\tthis._handleTextNodeInsertion( mutation );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles situations when container's children mutated during input. This can happen when\n\t * the browser is trying to \"fix\" DOM in certain situations. For example, when the user starts to type\n\t * in `<p><a href=\"\"><i>Link{}</i></a></p>`, the browser might change the order of elements\n\t * to `<p><i><a href=\"\">Link</a>x{}</i></p>`. A similar situation happens when the spell checker\n\t * replaces a word wrapped with `<strong>` with a word wrapped with a `<b>` element.\n\t *\n\t * To handle such situations, the common DOM ancestor of all mutations is converted to the model representation\n\t * and then compared with the current model to calculate the proper text change.\n\t *\n\t * Note: Single text node insertion is handled in {@link #_handleTextNodeInsertion} and text node mutation is handled\n\t * in {@link #_handleTextMutation}).\n\t *\n\t * @private\n\t * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n\t * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n\t * @param {module:engine/view/selection~Selection|null} viewSelection\n\t */\n\t_handleContainerChildrenMutations( mutations, viewSelection ) {\n\t\t// Get common ancestor of all mutations.\n\t\tconst mutationsCommonAncestor = getMutationsContainer( mutations );\n\n\t\t// Quit if there is no common ancestor.\n\t\tif ( !mutationsCommonAncestor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst domConverter = this.editor.editing.view.domConverter;\n\n\t\t// Get common ancestor in DOM.\n\t\tconst domMutationCommonAncestor = domConverter.mapViewToDom( mutationsCommonAncestor );\n\n\t\t// Create fresh DomConverter so it will not use existing mapping and convert current DOM to model.\n\t\t// This wouldn't be needed if DomConverter would allow to create fresh view without checking any mappings.\n\t\tconst freshDomConverter = new DomConverter( this.editor.editing.view.document );\n\t\tconst modelFromCurrentDom = this.editor.data.toModel(\n\t\t\tfreshDomConverter.domToView( domMutationCommonAncestor )\n\t\t).getChild( 0 );\n\n\t\t// Current model.\n\t\tconst currentModel = this.editor.editing.mapper.toModelElement( mutationsCommonAncestor );\n\n\t\t// If common ancestor is not mapped, do not do anything. It probably is a parent of another view element.\n\t\t// That means that we would need to diff model elements (see `if` below). Better return early instead of\n\t\t// trying to get a reasonable model ancestor. It will fell into the `if` below anyway.\n\t\t// This situation happens for example for lists. If `<ul>` is a common ancestor, `currentModel` is `undefined`\n\t\t// because `<ul>` is not mapped (`<li>`s are).\n\t\t// See https://github.com/ckeditor/ckeditor5/issues/718.\n\t\tif ( !currentModel ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Get children from both ancestors.\n\t\tconst modelFromDomChildren = Array.from( modelFromCurrentDom.getChildren() );\n\t\tconst currentModelChildren = Array.from( currentModel.getChildren() );\n\n\t\t// Remove the last `<softBreak>` from the end of `modelFromDomChildren` if there is no `<softBreak>` in current model.\n\t\t// If the described scenario happened, it means that this is a bogus `<br />` added by a browser.\n\t\tconst lastDomChild = modelFromDomChildren[ modelFromDomChildren.length - 1 ];\n\t\tconst lastCurrentChild = currentModelChildren[ currentModelChildren.length - 1 ];\n\n\t\tconst isLastDomChildSoftBreak = lastDomChild && lastDomChild.is( 'element', 'softBreak' );\n\t\tconst isLastCurrentChildSoftBreak = lastCurrentChild && !lastCurrentChild.is( 'element', 'softBreak' );\n\n\t\tif ( isLastDomChildSoftBreak && isLastCurrentChildSoftBreak ) {\n\t\t\tmodelFromDomChildren.pop();\n\t\t}\n\n\t\tconst schema = this.editor.model.schema;\n\n\t\t// Skip situations when common ancestor has any container elements.\n\t\tif ( !isSafeForTextMutation( modelFromDomChildren, schema ) || !isSafeForTextMutation( currentModelChildren, schema ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Replace &nbsp; inserted by the browser with normal space. See comment in `_handleTextMutation`.\n\t\t// Replace non-texts with any character. This is potentially dangerous but passes in manual tests. The thing is\n\t\t// that we need to take care of proper indexes so we cannot simply remove non-text elements from the content.\n\t\t// By inserting a character we keep all the real texts on their indexes.\n\t\tconst newText = modelFromDomChildren.map( item => item.is( '$text' ) ? item.data : '@' ).join( '' ).replace( /\\u00A0/g, ' ' );\n\t\tconst oldText = currentModelChildren.map( item => item.is( '$text' ) ? item.data : '@' ).join( '' ).replace( /\\u00A0/g, ' ' );\n\n\t\t// Do nothing if mutations created same text.\n\t\tif ( oldText === newText ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst diffResult = diff( oldText, newText );\n\n\t\tconst { firstChangeAt, insertions, deletions } = calculateChanges( diffResult );\n\n\t\t// Try setting new model selection according to passed view selection.\n\t\tlet modelSelectionRange = null;\n\n\t\tif ( viewSelection ) {\n\t\t\tmodelSelectionRange = this.editing.mapper.toModelRange( viewSelection.getFirstRange() );\n\t\t}\n\n\t\tconst insertText = newText.substr( firstChangeAt, insertions );\n\t\tconst removeRange = this.editor.model.createRange(\n\t\t\tthis.editor.model.createPositionAt( currentModel, firstChangeAt ),\n\t\t\tthis.editor.model.createPositionAt( currentModel, firstChangeAt + deletions )\n\t\t);\n\n\t\tthis.editor.execute( 'input', {\n\t\t\ttext: insertText,\n\t\t\trange: removeRange,\n\t\t\tresultRange: modelSelectionRange\n\t\t} );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleTextMutation( mutation, viewSelection ) {\n\t\tif ( mutation.type != 'text' ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Replace &nbsp; inserted by the browser with normal space.\n\t\t// We want only normal spaces in the model and in the view. Renderer and DOM Converter will be then responsible\n\t\t// for rendering consecutive spaces using &nbsp;, but the model and the view has to be clear.\n\t\t// Other feature may introduce inserting non-breakable space on specific key stroke (for example shift + space).\n\t\t// However then it will be handled outside of mutations, like enter key is.\n\t\t// The replacing is here because it has to be done before `diff` and `diffToChanges` functions, as they\n\t\t// take `newText` and compare it to (cleaned up) view.\n\t\t// It could also be done in mutation observer too, however if any outside plugin would like to\n\t\t// introduce additional events for mutations, they would get already cleaned up version (this may be good or not).\n\t\tconst newText = mutation.newText.replace( /\\u00A0/g, ' ' );\n\t\t// To have correct `diffResult`, we also compare view node text data with &nbsp; replaced by space.\n\t\tconst oldText = mutation.oldText.replace( /\\u00A0/g, ' ' );\n\n\t\t// Do nothing if mutations created same text.\n\t\tif ( oldText === newText ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst diffResult = diff( oldText, newText );\n\n\t\tconst { firstChangeAt, insertions, deletions } = calculateChanges( diffResult );\n\n\t\t// Try setting new model selection according to passed view selection.\n\t\tlet modelSelectionRange = null;\n\n\t\tif ( viewSelection ) {\n\t\t\tmodelSelectionRange = this.editing.mapper.toModelRange( viewSelection.getFirstRange() );\n\t\t}\n\n\t\t// Get the position in view and model where the changes will happen.\n\t\tconst viewPos = this.editing.view.createPositionAt( mutation.node, firstChangeAt );\n\t\tconst modelPos = this.editing.mapper.toModelPosition( viewPos );\n\t\tconst removeRange = this.editor.model.createRange( modelPos, modelPos.getShiftedBy( deletions ) );\n\t\tconst insertText = newText.substr( firstChangeAt, insertions );\n\n\t\tthis.editor.execute( 'input', {\n\t\t\ttext: insertText,\n\t\t\trange: removeRange,\n\t\t\tresultRange: modelSelectionRange\n\t\t} );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleTextNodeInsertion( mutation ) {\n\t\tif ( mutation.type != 'children' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst change = getSingleTextNodeChange( mutation );\n\t\tconst viewPos = this.editing.view.createPositionAt( mutation.node, change.index );\n\t\tconst modelPos = this.editing.mapper.toModelPosition( viewPos );\n\t\tconst insertedText = change.values[ 0 ].data;\n\n\t\tthis.editor.execute( 'input', {\n\t\t\t// Replace &nbsp; inserted by the browser with normal space.\n\t\t\t// See comment in `_handleTextMutation`.\n\t\t\t// In this case we don't need to do this before `diff` because we diff whole nodes.\n\t\t\t// Just change &nbsp; in case there are some.\n\t\t\ttext: insertedText.replace( /\\u00A0/g, ' ' ),\n\t\t\trange: this.editor.model.createRange( modelPos )\n\t\t} );\n\t}\n}\n\n// Returns first common ancestor of all mutations that is either {@link module:engine/view/containerelement~ContainerElement}\n// or {@link module:engine/view/rootelement~RootElement}.\n//\n// @private\n// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n// @returns {module:engine/view/containerelement~ContainerElement|engine/view/rootelement~RootElement|undefined}\nfunction getMutationsContainer( mutations ) {\n\tconst lca = mutations\n\t\t.map( mutation => mutation.node )\n\t\t.reduce( ( commonAncestor, node ) => {\n\t\t\treturn commonAncestor.getCommonAncestor( node, { includeSelf: true } );\n\t\t} );\n\n\tif ( !lca ) {\n\t\treturn;\n\t}\n\n\t// We need to look for container and root elements only, so check all LCA's\n\t// ancestors (starting from itself).\n\treturn lca.getAncestors( { includeSelf: true, parentFirst: true } )\n\t\t.find( element => element.is( 'containerElement' ) || element.is( 'rootElement' ) );\n}\n\n// Returns true if provided array contains content that won't be problematic during diffing and text mutation handling.\n//\n// @param {Array.<module:engine/model/node~Node>} children\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction isSafeForTextMutation( children, schema ) {\n\treturn children.every( child => schema.isInline( child ) );\n}\n\n// Calculates first change index and number of characters that should be inserted and deleted starting from that index.\n//\n// @private\n// @param diffResult\n// @returns {{insertions: number, deletions: number, firstChangeAt: *}}\nfunction calculateChanges( diffResult ) {\n\t// Index where the first change happens. Used to set the position from which nodes will be removed and where will be inserted.\n\tlet firstChangeAt = null;\n\t// Index where the last change happens. Used to properly count how many characters have to be removed and inserted.\n\tlet lastChangeAt = null;\n\n\t// Get `firstChangeAt` and `lastChangeAt`.\n\tfor ( let i = 0; i < diffResult.length; i++ ) {\n\t\tconst change = diffResult[ i ];\n\n\t\tif ( change != 'equal' ) {\n\t\t\tfirstChangeAt = firstChangeAt === null ? i : firstChangeAt;\n\t\t\tlastChangeAt = i;\n\t\t}\n\t}\n\n\t// How many characters, starting from `firstChangeAt`, should be removed.\n\tlet deletions = 0;\n\t// How many characters, starting from `firstChangeAt`, should be inserted.\n\tlet insertions = 0;\n\n\tfor ( let i = firstChangeAt; i <= lastChangeAt; i++ ) {\n\t\t// If there is no change (equal) or delete, the character is existing in `oldText`. We count it for removing.\n\t\tif ( diffResult[ i ] != 'insert' ) {\n\t\t\tdeletions++;\n\t\t}\n\n\t\t// If there is no change (equal) or insert, the character is existing in `newText`. We count it for inserting.\n\t\tif ( diffResult[ i ] != 'delete' ) {\n\t\t\tinsertions++;\n\t\t}\n\t}\n\n\treturn { insertions, deletions, firstChangeAt };\n}\n"]},"metadata":{},"sourceType":"module"}