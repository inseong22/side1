{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module editor-inline/inlineeditorui\n */\nimport { EditorUI } from 'ckeditor5/src/core';\nimport { enableToolbarKeyboardFocus, normalizeToolbarConfig } from 'ckeditor5/src/ui';\nimport { enablePlaceholder } from 'ckeditor5/src/engine';\n/**\n * The inline editor UI class.\n *\n * @extends module:core/editor/editorui~EditorUI\n */\n\nexport default class InlineEditorUI extends EditorUI {\n  /**\n   * Creates an instance of the inline editor UI class.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   * @param {module:ui/editorui/editoruiview~EditorUIView} view The view of the UI.\n   */\n  constructor(editor, view) {\n    super(editor);\n    /**\n     * The main (top–most) view of the editor UI.\n     *\n     * @readonly\n     * @member {module:ui/editorui/editoruiview~EditorUIView} #view\n     */\n\n    this.view = view;\n    /**\n     * A normalized `config.toolbar` object.\n     *\n     * @type {Object}\n     * @private\n     */\n\n    this._toolbarConfig = normalizeToolbarConfig(editor.config.get('toolbar'));\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  get element() {\n    return this.view.editable.element;\n  }\n  /**\n   * Initializes the UI.\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const view = this.view;\n    const editingView = editor.editing.view;\n    const editable = view.editable;\n    const editingRoot = editingView.document.getRoot(); // The editable UI and editing root should share the same name. Then name is used\n    // to recognize the particular editable, for instance in ARIA attributes.\n\n    editable.name = editingRoot.rootName;\n    view.render(); // The editable UI element in DOM is available for sure only after the editor UI view has been rendered.\n    // But it can be available earlier if a DOM element has been passed to InlineEditor.create().\n\n    const editableElement = editable.element; // Register the editable UI view in the editor. A single editor instance can aggregate multiple\n    // editable areas (roots) but the inline editor has only one.\n\n    this.setEditableElement(editable.name, editableElement); // Let the global focus tracker know that the editable UI element is focusable and\n    // belongs to the editor. From now on, the focus tracker will sustain the editor focus\n    // as long as the editable is focused (e.g. the user is typing).\n\n    this.focusTracker.add(editableElement); // Let the editable UI element respond to the changes in the global editor focus\n    // tracker. It has been added to the same tracker a few lines above but, in reality, there are\n    // many focusable areas in the editor, like balloons, toolbars or dropdowns and as long\n    // as they have focus, the editable should act like it is focused too (although technically\n    // it isn't), e.g. by setting the proper CSS class, visually announcing focus to the user.\n    // Doing otherwise will result in editable focus styles disappearing, once e.g. the\n    // toolbar gets focused.\n\n    editable.bind('isFocused').to(this.focusTracker); // Bind the editable UI element to the editing view, making it an end– and entry–point\n    // of the editor's engine. This is where the engine meets the UI.\n\n    editingView.attachDomRoot(editableElement);\n\n    this._initPlaceholder();\n\n    this._initToolbar();\n\n    this.fire('ready');\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    const view = this.view;\n    const editingView = this.editor.editing.view;\n    editingView.detachDomRoot(view.editable.name);\n    view.destroy();\n    super.destroy();\n  }\n  /**\n   * Initializes the inline editor toolbar and its panel.\n   *\n   * @private\n   */\n\n\n  _initToolbar() {\n    const editor = this.editor;\n    const view = this.view;\n    const editableElement = view.editable.element;\n    const editingView = editor.editing.view;\n    const toolbar = view.toolbar; // Set–up the view#panel.\n\n    view.panel.bind('isVisible').to(this.focusTracker, 'isFocused');\n    view.bind('viewportTopOffset').to(this, 'viewportOffset', ({\n      top\n    }) => top); // https://github.com/ckeditor/ckeditor5-editor-inline/issues/4\n\n    view.listenTo(editor.ui, 'update', () => {\n      // Don't pin if the panel is not already visible. It prevents the panel\n      // showing up when there's no focus in the UI.\n      if (view.panel.isVisible) {\n        view.panel.pin({\n          target: editableElement,\n          positions: view.panelPositions\n        });\n      }\n    });\n    toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);\n    enableToolbarKeyboardFocus({\n      origin: editingView,\n      originFocusTracker: this.focusTracker,\n      originKeystrokeHandler: editor.keystrokes,\n      toolbar\n    });\n  }\n  /**\n   * Enable the placeholder text on the editing root, if any was configured.\n   *\n   * @private\n   */\n\n\n  _initPlaceholder() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    const editingRoot = editingView.document.getRoot();\n    const sourceElement = editor.sourceElement;\n    const placeholderText = editor.config.get('placeholder') || sourceElement && sourceElement.tagName.toLowerCase() === 'textarea' && sourceElement.getAttribute('placeholder');\n\n    if (placeholderText) {\n      enablePlaceholder({\n        view: editingView,\n        element: editingRoot,\n        text: placeholderText,\n        isDirectHost: false,\n        keepOnFocus: true\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-editor-inline/src/inlineeditorui.js"],"names":["EditorUI","enableToolbarKeyboardFocus","normalizeToolbarConfig","enablePlaceholder","InlineEditorUI","constructor","editor","view","_toolbarConfig","config","get","element","editable","init","editingView","editing","editingRoot","document","getRoot","name","rootName","render","editableElement","setEditableElement","focusTracker","add","bind","to","attachDomRoot","_initPlaceholder","_initToolbar","fire","destroy","detachDomRoot","toolbar","panel","top","listenTo","ui","isVisible","pin","target","positions","panelPositions","fillFromConfig","componentFactory","origin","originFocusTracker","originKeystrokeHandler","keystrokes","sourceElement","placeholderText","tagName","toLowerCase","getAttribute","text","isDirectHost","keepOnFocus"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module editor-inline/inlineeditorui\n */\n\nimport { EditorUI } from 'ckeditor5/src/core';\nimport { enableToolbarKeyboardFocus, normalizeToolbarConfig } from 'ckeditor5/src/ui';\nimport { enablePlaceholder } from 'ckeditor5/src/engine';\n\n/**\n * The inline editor UI class.\n *\n * @extends module:core/editor/editorui~EditorUI\n */\nexport default class InlineEditorUI extends EditorUI {\n\t/**\n\t * Creates an instance of the inline editor UI class.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor instance.\n\t * @param {module:ui/editorui/editoruiview~EditorUIView} view The view of the UI.\n\t */\n\tconstructor( editor, view ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The main (top–most) view of the editor UI.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/editorui/editoruiview~EditorUIView} #view\n\t\t */\n\t\tthis.view = view;\n\n\t\t/**\n\t\t * A normalized `config.toolbar` object.\n\t\t *\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._toolbarConfig = normalizeToolbarConfig( editor.config.get( 'toolbar' ) );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget element() {\n\t\treturn this.view.editable.element;\n\t}\n\n\t/**\n\t * Initializes the UI.\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst view = this.view;\n\t\tconst editingView = editor.editing.view;\n\t\tconst editable = view.editable;\n\t\tconst editingRoot = editingView.document.getRoot();\n\n\t\t// The editable UI and editing root should share the same name. Then name is used\n\t\t// to recognize the particular editable, for instance in ARIA attributes.\n\t\teditable.name = editingRoot.rootName;\n\n\t\tview.render();\n\n\t\t// The editable UI element in DOM is available for sure only after the editor UI view has been rendered.\n\t\t// But it can be available earlier if a DOM element has been passed to InlineEditor.create().\n\t\tconst editableElement = editable.element;\n\n\t\t// Register the editable UI view in the editor. A single editor instance can aggregate multiple\n\t\t// editable areas (roots) but the inline editor has only one.\n\t\tthis.setEditableElement( editable.name, editableElement );\n\n\t\t// Let the global focus tracker know that the editable UI element is focusable and\n\t\t// belongs to the editor. From now on, the focus tracker will sustain the editor focus\n\t\t// as long as the editable is focused (e.g. the user is typing).\n\t\tthis.focusTracker.add( editableElement );\n\n\t\t// Let the editable UI element respond to the changes in the global editor focus\n\t\t// tracker. It has been added to the same tracker a few lines above but, in reality, there are\n\t\t// many focusable areas in the editor, like balloons, toolbars or dropdowns and as long\n\t\t// as they have focus, the editable should act like it is focused too (although technically\n\t\t// it isn't), e.g. by setting the proper CSS class, visually announcing focus to the user.\n\t\t// Doing otherwise will result in editable focus styles disappearing, once e.g. the\n\t\t// toolbar gets focused.\n\t\teditable.bind( 'isFocused' ).to( this.focusTracker );\n\n\t\t// Bind the editable UI element to the editing view, making it an end– and entry–point\n\t\t// of the editor's engine. This is where the engine meets the UI.\n\t\teditingView.attachDomRoot( editableElement );\n\n\t\tthis._initPlaceholder();\n\t\tthis._initToolbar();\n\t\tthis.fire( 'ready' );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tconst view = this.view;\n\t\tconst editingView = this.editor.editing.view;\n\n\t\teditingView.detachDomRoot( view.editable.name );\n\t\tview.destroy();\n\n\t\tsuper.destroy();\n\t}\n\n\t/**\n\t * Initializes the inline editor toolbar and its panel.\n\t *\n\t * @private\n\t */\n\t_initToolbar() {\n\t\tconst editor = this.editor;\n\t\tconst view = this.view;\n\t\tconst editableElement = view.editable.element;\n\t\tconst editingView = editor.editing.view;\n\t\tconst toolbar = view.toolbar;\n\n\t\t// Set–up the view#panel.\n\t\tview.panel.bind( 'isVisible' ).to( this.focusTracker, 'isFocused' );\n\n\t\tview.bind( 'viewportTopOffset' ).to( this, 'viewportOffset', ( { top } ) => top );\n\n\t\t// https://github.com/ckeditor/ckeditor5-editor-inline/issues/4\n\t\tview.listenTo( editor.ui, 'update', () => {\n\t\t\t// Don't pin if the panel is not already visible. It prevents the panel\n\t\t\t// showing up when there's no focus in the UI.\n\t\t\tif ( view.panel.isVisible ) {\n\t\t\t\tview.panel.pin( {\n\t\t\t\t\ttarget: editableElement,\n\t\t\t\t\tpositions: view.panelPositions\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\ttoolbar.fillFromConfig( this._toolbarConfig, this.componentFactory );\n\n\t\tenableToolbarKeyboardFocus( {\n\t\t\torigin: editingView,\n\t\t\toriginFocusTracker: this.focusTracker,\n\t\t\toriginKeystrokeHandler: editor.keystrokes,\n\t\t\ttoolbar\n\t\t} );\n\t}\n\n\t/**\n\t * Enable the placeholder text on the editing root, if any was configured.\n\t *\n\t * @private\n\t */\n\t_initPlaceholder() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\t\tconst editingRoot = editingView.document.getRoot();\n\t\tconst sourceElement = editor.sourceElement;\n\n\t\tconst placeholderText = editor.config.get( 'placeholder' ) ||\n\t\t\tsourceElement && sourceElement.tagName.toLowerCase() === 'textarea' && sourceElement.getAttribute( 'placeholder' );\n\n\t\tif ( placeholderText ) {\n\t\t\tenablePlaceholder( {\n\t\t\t\tview: editingView,\n\t\t\t\telement: editingRoot,\n\t\t\t\ttext: placeholderText,\n\t\t\t\tisDirectHost: false,\n\t\t\t\tkeepOnFocus: true\n\t\t\t} );\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}