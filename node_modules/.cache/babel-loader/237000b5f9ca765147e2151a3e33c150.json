{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/imagetypecommand\n */\nimport { Command } from 'ckeditor5/src/core';\n/**\n * The image type command. It changes the type of a selected image, depending on the configuration.\n *\n * @extends module:core/command~Command\n */\n\nexport default class ImageTypeCommand extends Command {\n  /**\n   * @inheritDoc\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {'imageBlock'|'imageInline'} modelElementName Model element name the command converts to.\n   */\n  constructor(editor, modelElementName) {\n    super(editor);\n    /**\n     * Model element name the command converts to.\n     *\n     * @readonly\n     * @private\n     * @member {'imageBlock'|'imageInline'}\n     */\n\n    this._modelElementName = modelElementName;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  refresh() {\n    const editor = this.editor;\n    const imageUtils = editor.plugins.get('ImageUtils');\n    const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);\n\n    if (this._modelElementName === 'imageBlock') {\n      this.isEnabled = imageUtils.isInlineImage(element);\n    } else {\n      this.isEnabled = imageUtils.isBlockImage(element);\n    }\n  }\n  /**\n   * Executes the command and changes the type of a selected image.\n   *\n   * @fires execute\n   * @returns {Object|null} An object containing references to old and new model image elements\n   * (for before and after the change) so external integrations can hook into the decorated\n   * `execute` event and handle this change. `null` if the type change failed.\n   */\n\n\n  execute() {\n    const editor = this.editor;\n    const model = this.editor.model;\n    const imageUtils = editor.plugins.get('ImageUtils');\n    const oldElement = imageUtils.getClosestSelectedImageElement(model.document.selection);\n    const attributes = Object.fromEntries(oldElement.getAttributes()); // Don't change image type if \"src\" is missing (a broken image), unless there's \"uploadId\" set.\n    // This state may happen during image upload (before it finishes) and it should be possible to change type\n    // of the image in the meantime.\n\n    if (!attributes.src && !attributes.uploadId) {\n      return null;\n    }\n\n    return model.change(writer => {\n      // Get all markers that contain the old image element.\n      const markers = Array.from(model.markers).filter(marker => marker.getRange().containsItem(oldElement));\n      const newElement = imageUtils.insertImage(attributes, model.createSelection(oldElement, 'on'), this._modelElementName);\n\n      if (!newElement) {\n        return null;\n      }\n\n      const newElementRange = writer.createRangeOn(newElement); // Expand the previously intersecting markers' ranges to include the new image element.\n\n      for (const marker of markers) {\n        const markerRange = marker.getRange(); // Join the survived part of the old marker range with the new element range\n        // (loosely because there could be some new paragraph or the existing one might got split).\n\n        const range = markerRange.root.rootName != '$graveyard' ? markerRange.getJoined(newElementRange, true) : newElementRange;\n        writer.updateMarker(marker, {\n          range\n        });\n      }\n\n      return {\n        oldElement,\n        newElement\n      };\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-image/src/image/imagetypecommand.js"],"names":["Command","ImageTypeCommand","constructor","editor","modelElementName","_modelElementName","refresh","imageUtils","plugins","get","element","getClosestSelectedImageElement","model","document","selection","isEnabled","isInlineImage","isBlockImage","execute","oldElement","attributes","Object","fromEntries","getAttributes","src","uploadId","change","writer","markers","Array","from","filter","marker","getRange","containsItem","newElement","insertImage","createSelection","newElementRange","createRangeOn","markerRange","range","root","rootName","getJoined","updateMarker"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/imagetypecommand\n */\n\nimport { Command } from 'ckeditor5/src/core';\n\n/**\n * The image type command. It changes the type of a selected image, depending on the configuration.\n *\n * @extends module:core/command~Command\n */\nexport default class ImageTypeCommand extends Command {\n\t/**\n\t * @inheritDoc\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {'imageBlock'|'imageInline'} modelElementName Model element name the command converts to.\n\t */\n\tconstructor( editor, modelElementName ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * Model element name the command converts to.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {'imageBlock'|'imageInline'}\n\t\t */\n\t\tthis._modelElementName = modelElementName;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst editor = this.editor;\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\t\tconst element = imageUtils.getClosestSelectedImageElement( this.editor.model.document.selection );\n\n\t\tif ( this._modelElementName === 'imageBlock' ) {\n\t\t\tthis.isEnabled = imageUtils.isInlineImage( element );\n\t\t} else {\n\t\t\tthis.isEnabled = imageUtils.isBlockImage( element );\n\t\t}\n\t}\n\n\t/**\n\t * Executes the command and changes the type of a selected image.\n\t *\n\t * @fires execute\n\t * @returns {Object|null} An object containing references to old and new model image elements\n\t * (for before and after the change) so external integrations can hook into the decorated\n\t * `execute` event and handle this change. `null` if the type change failed.\n\t */\n\texecute() {\n\t\tconst editor = this.editor;\n\t\tconst model = this.editor.model;\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\t\tconst oldElement = imageUtils.getClosestSelectedImageElement( model.document.selection );\n\t\tconst attributes = Object.fromEntries( oldElement.getAttributes() );\n\n\t\t// Don't change image type if \"src\" is missing (a broken image), unless there's \"uploadId\" set.\n\t\t// This state may happen during image upload (before it finishes) and it should be possible to change type\n\t\t// of the image in the meantime.\n\t\tif ( !attributes.src && !attributes.uploadId ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn model.change( writer => {\n\t\t\t// Get all markers that contain the old image element.\n\t\t\tconst markers = Array.from( model.markers )\n\t\t\t\t.filter( marker => marker.getRange().containsItem( oldElement ) );\n\n\t\t\tconst newElement = imageUtils.insertImage( attributes, model.createSelection( oldElement, 'on' ), this._modelElementName );\n\n\t\t\tif ( !newElement ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst newElementRange = writer.createRangeOn( newElement );\n\n\t\t\t// Expand the previously intersecting markers' ranges to include the new image element.\n\t\t\tfor ( const marker of markers ) {\n\t\t\t\tconst markerRange = marker.getRange();\n\n\t\t\t\t// Join the survived part of the old marker range with the new element range\n\t\t\t\t// (loosely because there could be some new paragraph or the existing one might got split).\n\t\t\t\tconst range = markerRange.root.rootName != '$graveyard' ?\n\t\t\t\t\tmarkerRange.getJoined( newElementRange, true ) : newElementRange;\n\n\t\t\t\twriter.updateMarker( marker, { range } );\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\toldElement,\n\t\t\t\tnewElement\n\t\t\t};\n\t\t} );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}