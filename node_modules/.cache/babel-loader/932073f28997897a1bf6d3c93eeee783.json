{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nvar _excluded = [\"prefixCls\", \"className\", \"onMove\", \"onDown\"];\nimport React, { useRef, useState, useCallback, useEffect } from 'react';\nimport { isTouch, preventDefaultMove, getRelativePosition, useEventCallback } from './utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport * from './utils';\nvar Interactive = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var {\n    prefixCls = 'w-color-interactive',\n    className,\n    onMove,\n    onDown\n  } = props,\n      reset = _objectWithoutPropertiesLoose(props, _excluded);\n\n  var container = useRef(null);\n  var hasTouched = useRef(false);\n  var [isDragging, setDragging] = useState(false);\n  var onMoveCallback = useEventCallback(onMove);\n  var onKeyCallback = useEventCallback(onDown); // Prevent mobile browsers from handling mouse events (conflicting with touch ones).\n  // If we detected a touch interaction before, we prefer reacting to touch events only.\n\n  var isValid = event => {\n    if (hasTouched.current && !isTouch(event)) return false;\n    hasTouched.current = isTouch(event);\n    return true;\n  };\n\n  var handleMove = useCallback(event => {\n    preventDefaultMove(event); // If user moves the pointer outside of the window or iframe bounds and release it there,\n    // `mouseup`/`touchend` won't be fired. In order to stop the picker from following the cursor\n    // after the user has moved the mouse/finger back to the document, we check `event.buttons`\n    // and `event.touches`. It allows us to detect that the user is just moving his pointer\n    // without pressing it down\n\n    var isDown = isTouch(event) ? event.touches.length > 0 : event.buttons > 0;\n\n    if (isDown && container.current) {\n      onMoveCallback && onMoveCallback(getRelativePosition(container.current, event), event);\n    } else {\n      setDragging(false);\n    }\n  }, [onMoveCallback]);\n  var handleMoveEnd = useCallback(() => setDragging(false), []);\n  var toggleDocumentEvents = useCallback(state => {\n    var toggleEvent = state ? window.addEventListener : window.removeEventListener;\n    toggleEvent(hasTouched.current ? 'touchmove' : 'mousemove', handleMove);\n    toggleEvent(hasTouched.current ? 'touchend' : 'mouseup', handleMoveEnd);\n  }, []);\n  useEffect(() => {\n    toggleDocumentEvents(isDragging);\n    return () => {\n      isDragging && toggleDocumentEvents(false);\n    };\n  }, [isDragging, toggleDocumentEvents]);\n  var handleMoveStart = useCallback(event => {\n    preventDefaultMove(event.nativeEvent);\n    if (!isValid(event.nativeEvent)) return;\n    onKeyCallback && onKeyCallback(getRelativePosition(container.current, event.nativeEvent), event.nativeEvent);\n    setDragging(true);\n  }, [onKeyCallback]);\n  return /*#__PURE__*/_jsx(\"div\", _extends({}, reset, {\n    className: [prefixCls, className || ''].filter(Boolean).join(' '),\n    style: _extends({}, reset.style, {\n      touchAction: 'none'\n    }),\n    ref: container,\n    tabIndex: 0,\n    onMouseDown: handleMoveStart,\n    onTouchStart: handleMoveStart\n  }));\n});\nInteractive.displayName = 'Interactive';\nexport default Interactive;","map":{"version":3,"sources":["../src/index.tsx"],"names":["Interactive","prefixCls","onDown","reset","container","useRef","hasTouched","useState","onMoveCallback","useEventCallback","onKeyCallback","isValid","event","isTouch","handleMove","useCallback","preventDefaultMove","isDown","getRelativePosition","setDragging","handleMoveEnd","toggleDocumentEvents","state","toggleEvent","window","useEffect","isDragging","handleMoveStart","className","touchAction"],"mappings":"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","sourcesContent":["import React, { useRef, useState, useCallback, useEffect } from 'react';\nimport { isTouch, preventDefaultMove, getRelativePosition, Interaction, useEventCallback } from './utils';\n\nexport * from './utils';\n\nexport interface InteractiveProps extends React.HTMLAttributes<HTMLDivElement> {\n  prefixCls?: string;\n  onMove?: (interaction: Interaction, event: MouseEvent | TouchEvent) => void;\n  onDown?: (offset: Interaction, event: MouseEvent | TouchEvent) => void;\n}\n\nconst Interactive = React.forwardRef<HTMLDivElement, InteractiveProps>((props, ref) => {\n  const { prefixCls = 'w-color-interactive', className, onMove, onDown, ...reset } = props;\n  const container = useRef<HTMLDivElement>(null);\n  const hasTouched = useRef(false);\n  const [isDragging, setDragging] = useState(false);\n  const onMoveCallback = useEventCallback<Interaction, MouseEvent | TouchEvent>(onMove);\n  const onKeyCallback = useEventCallback<Interaction, MouseEvent | TouchEvent>(onDown);\n\n  // Prevent mobile browsers from handling mouse events (conflicting with touch ones).\n  // If we detected a touch interaction before, we prefer reacting to touch events only.\n  const isValid = (event: MouseEvent | TouchEvent): boolean => {\n    if (hasTouched.current && !isTouch(event)) return false;\n    hasTouched.current = isTouch(event);\n    return true;\n  };\n\n  const handleMove = useCallback(\n    (event: MouseEvent | TouchEvent) => {\n      preventDefaultMove(event);\n      // If user moves the pointer outside of the window or iframe bounds and release it there,\n      // `mouseup`/`touchend` won't be fired. In order to stop the picker from following the cursor\n      // after the user has moved the mouse/finger back to the document, we check `event.buttons`\n      // and `event.touches`. It allows us to detect that the user is just moving his pointer\n      // without pressing it down\n      const isDown = isTouch(event) ? event.touches.length > 0 : event.buttons > 0;\n      if (isDown && container.current) {\n        onMoveCallback && onMoveCallback(getRelativePosition(container.current!, event), event);\n      } else {\n        setDragging(false);\n      }\n    },\n    [onMoveCallback],\n  );\n\n  const handleMoveEnd = useCallback(() => setDragging(false), []);\n  const toggleDocumentEvents = useCallback((state: boolean) => {\n    const toggleEvent = state ? window.addEventListener : window.removeEventListener;\n    toggleEvent(hasTouched.current ? 'touchmove' : 'mousemove', handleMove);\n    toggleEvent(hasTouched.current ? 'touchend' : 'mouseup', handleMoveEnd);\n  }, []);\n\n  useEffect(() => {\n    toggleDocumentEvents(isDragging);\n    return () => {\n      isDragging && toggleDocumentEvents(false);\n    };\n  }, [isDragging, toggleDocumentEvents]);\n\n  const handleMoveStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      preventDefaultMove(event.nativeEvent);\n      if (!isValid(event.nativeEvent)) return;\n      onKeyCallback && onKeyCallback(getRelativePosition(container.current!, event.nativeEvent), event.nativeEvent);\n      setDragging(true);\n    },\n    [onKeyCallback],\n  );\n\n  return (\n    <div\n      {...reset}\n      className={[prefixCls, className || ''].filter(Boolean).join(' ')}\n      style={{\n        ...reset.style,\n        touchAction: 'none',\n      }}\n      ref={container}\n      tabIndex={0}\n      onMouseDown={handleMoveStart}\n      onTouchStart={handleMoveStart}\n    />\n  );\n});\n\nInteractive.displayName = 'Interactive';\n\nexport default Interactive;\n"]},"metadata":{},"sourceType":"module"}