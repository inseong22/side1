{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/textwatcher\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport getLastTextLine from './utils/getlasttextline';\n/**\n * The text watcher feature.\n *\n * Fires the {@link module:typing/textwatcher~TextWatcher#event:matched:data `matched:data`},\n * {@link module:typing/textwatcher~TextWatcher#event:matched:selection `matched:selection`} and\n * {@link module:typing/textwatcher~TextWatcher#event:unmatched `unmatched`} events on typing or selection changes.\n *\n * @private\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class TextWatcher {\n  /**\n   * Creates a text watcher instance.\n   *\n   * @param {module:engine/model/model~Model} model\n   * @param {Function} testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.\n   */\n  constructor(model, testCallback) {\n    /**\n     * The editor's model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The function used to match the text.\n     *\n     * The test callback can return 3 values:\n     *\n     * * `false` if there is no match,\n     * * `true` if there is a match,\n     * * an object if there is a match and we want to pass some additional information to the {@link #event:matched:data} event.\n     *\n     * @member {Function} #testCallback\n     * @returns {Object} testResult\n     */\n\n    this.testCallback = testCallback;\n    /**\n     * Whether there is a match currently.\n     *\n     * @readonly\n     * @member {Boolean}\n     */\n\n    this.hasMatch = false;\n    /**\n     * Flag indicating whether the `TextWatcher` instance is enabled or disabled.\n     * A disabled TextWatcher will not evaluate text.\n     *\n     * To disable TextWatcher:\n     *\n     *\t\tconst watcher = new TextWatcher( editor.model, testCallback );\n     *\n     *\t\t// After this a testCallback will not be called.\n     *\t\twatcher.isEnabled = false;\n     *\n     * @observable\n     * @member {Boolean} #isEnabled\n     */\n\n    this.set('isEnabled', true); // Toggle text watching on isEnabled state change.\n\n    this.on('change:isEnabled', () => {\n      if (this.isEnabled) {\n        this._startListening();\n      } else {\n        this.stopListening(model.document.selection);\n        this.stopListening(model.document);\n      }\n    });\n\n    this._startListening();\n  }\n  /**\n   * Starts listening to the editor for typing and selection events.\n   *\n   * @private\n   */\n\n\n  _startListening() {\n    const model = this.model;\n    const document = model.document;\n    this.listenTo(document.selection, 'change:range', (evt, {\n      directChange\n    }) => {\n      // Indirect changes (i.e. when the user types or external changes are applied) are handled in the document's change event.\n      if (!directChange) {\n        return;\n      } // Act only on collapsed selection.\n\n\n      if (!document.selection.isCollapsed) {\n        if (this.hasMatch) {\n          this.fire('unmatched');\n          this.hasMatch = false;\n        }\n\n        return;\n      }\n\n      this._evaluateTextBeforeSelection('selection');\n    });\n    this.listenTo(document, 'change:data', (evt, batch) => {\n      if (batch.type == 'transparent') {\n        return;\n      }\n\n      this._evaluateTextBeforeSelection('data', {\n        batch\n      });\n    });\n  }\n  /**\n   * Checks the editor content for matched text.\n   *\n   * @fires matched:data\n   * @fires matched:selection\n   * @fires unmatched\n   *\n   * @private\n   * @param {'data'|'selection'} suffix A suffix used for generating the event name.\n   * @param {Object} data Data object for event.\n   */\n\n\n  _evaluateTextBeforeSelection(suffix, data = {}) {\n    const model = this.model;\n    const document = model.document;\n    const selection = document.selection;\n    const rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);\n    const {\n      text,\n      range\n    } = getLastTextLine(rangeBeforeSelection, model);\n    const testResult = this.testCallback(text);\n\n    if (!testResult && this.hasMatch) {\n      this.fire('unmatched');\n    }\n\n    this.hasMatch = !!testResult;\n\n    if (testResult) {\n      const eventData = Object.assign(data, {\n        text,\n        range\n      }); // If the test callback returns an object with additional data, assign the data as well.\n\n      if (typeof testResult == 'object') {\n        Object.assign(eventData, testResult);\n      }\n\n      this.fire(`matched:${suffix}`, eventData);\n    }\n  }\n\n}\nmix(TextWatcher, ObservableMixin);\n/**\n * Fired whenever the text watcher found a match for data changes.\n *\n * @event matched:data\n * @param {Object} data Event data.\n * @param {String} data.text The full text before selection to which the regexp was applied.\n * @param {module:engine/model/range~Range} data.range The range representing the position of the `data.text`.\n * @param {Object} [data.testResult] The additional data returned from the {@link module:typing/textwatcher~TextWatcher#testCallback}.\n */\n\n/**\n * Fired whenever the text watcher found a match for selection changes.\n *\n * @event matched:selection\n * @param {Object} data Event data.\n * @param {String} data.text The full text before selection.\n * @param {module:engine/model/range~Range} data.range The range representing the position of the `data.text`.\n * @param {Object} [data.testResult] The additional data returned from the {@link module:typing/textwatcher~TextWatcher#testCallback}.\n */\n\n/**\n * Fired whenever the text does not match anymore. Fired only when the text watcher found a match.\n *\n * @event unmatched\n */","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-typing/src/textwatcher.js"],"names":["mix","ObservableMixin","getLastTextLine","TextWatcher","constructor","model","testCallback","hasMatch","set","on","isEnabled","_startListening","stopListening","document","selection","listenTo","evt","directChange","isCollapsed","fire","_evaluateTextBeforeSelection","batch","type","suffix","data","rangeBeforeSelection","createRange","createPositionAt","focus","parent","text","range","testResult","eventData","Object","assign"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,GAAP,MAAgB,mCAAhB;AACA,OAAOC,eAAP,MAA4B,+CAA5B;AACA,OAAOC,eAAP,MAA4B,yBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,WAAN,CAAkB;AAChC;AACD;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,KAAF,EAASC,YAAT,EAAwB;AAClC;AACF;AACA;AACA;AACA;AACA;AACE,SAAKD,KAAL,GAAaA,KAAb;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,YAAL,GAAoBA,YAApB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,QAAL,GAAgB,KAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,GAAL,CAAU,WAAV,EAAuB,IAAvB,EA7CkC,CA+ClC;;AACA,SAAKC,EAAL,CAAS,kBAAT,EAA6B,MAAM;AAClC,UAAK,KAAKC,SAAV,EAAsB;AACrB,aAAKC,eAAL;AACA,OAFD,MAEO;AACN,aAAKC,aAAL,CAAoBP,KAAK,CAACQ,QAAN,CAAeC,SAAnC;AACA,aAAKF,aAAL,CAAoBP,KAAK,CAACQ,QAA1B;AACA;AACD,KAPD;;AASA,SAAKF,eAAL;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCA,EAAAA,eAAe,GAAG;AACjB,UAAMN,KAAK,GAAG,KAAKA,KAAnB;AACA,UAAMQ,QAAQ,GAAGR,KAAK,CAACQ,QAAvB;AAEA,SAAKE,QAAL,CAAeF,QAAQ,CAACC,SAAxB,EAAmC,cAAnC,EAAmD,CAAEE,GAAF,EAAO;AAAEC,MAAAA;AAAF,KAAP,KAA6B;AAC/E;AACA,UAAK,CAACA,YAAN,EAAqB;AACpB;AACA,OAJ8E,CAM/E;;;AACA,UAAK,CAACJ,QAAQ,CAACC,SAAT,CAAmBI,WAAzB,EAAuC;AACtC,YAAK,KAAKX,QAAV,EAAqB;AACpB,eAAKY,IAAL,CAAW,WAAX;AACA,eAAKZ,QAAL,GAAgB,KAAhB;AACA;;AAED;AACA;;AAED,WAAKa,4BAAL,CAAmC,WAAnC;AACA,KAjBD;AAmBA,SAAKL,QAAL,CAAeF,QAAf,EAAyB,aAAzB,EAAwC,CAAEG,GAAF,EAAOK,KAAP,KAAkB;AACzD,UAAKA,KAAK,CAACC,IAAN,IAAc,aAAnB,EAAmC;AAClC;AACA;;AAED,WAAKF,4BAAL,CAAmC,MAAnC,EAA2C;AAAEC,QAAAA;AAAF,OAA3C;AACA,KAND;AAOA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCD,EAAAA,4BAA4B,CAAEG,MAAF,EAAUC,IAAI,GAAG,EAAjB,EAAsB;AACjD,UAAMnB,KAAK,GAAG,KAAKA,KAAnB;AACA,UAAMQ,QAAQ,GAAGR,KAAK,CAACQ,QAAvB;AACA,UAAMC,SAAS,GAAGD,QAAQ,CAACC,SAA3B;AAEA,UAAMW,oBAAoB,GAAGpB,KAAK,CAACqB,WAAN,CAAmBrB,KAAK,CAACsB,gBAAN,CAAwBb,SAAS,CAACc,KAAV,CAAgBC,MAAxC,EAAgD,CAAhD,CAAnB,EAAwEf,SAAS,CAACc,KAAlF,CAA7B;AAEA,UAAM;AAAEE,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAAkB7B,eAAe,CAAEuB,oBAAF,EAAwBpB,KAAxB,CAAvC;AAEA,UAAM2B,UAAU,GAAG,KAAK1B,YAAL,CAAmBwB,IAAnB,CAAnB;;AAEA,QAAK,CAACE,UAAD,IAAe,KAAKzB,QAAzB,EAAoC;AACnC,WAAKY,IAAL,CAAW,WAAX;AACA;;AAED,SAAKZ,QAAL,GAAgB,CAAC,CAACyB,UAAlB;;AAEA,QAAKA,UAAL,EAAkB;AACjB,YAAMC,SAAS,GAAGC,MAAM,CAACC,MAAP,CAAeX,IAAf,EAAqB;AAAEM,QAAAA,IAAF;AAAQC,QAAAA;AAAR,OAArB,CAAlB,CADiB,CAGjB;;AACA,UAAK,OAAOC,UAAP,IAAqB,QAA1B,EAAqC;AACpCE,QAAAA,MAAM,CAACC,MAAP,CAAeF,SAAf,EAA0BD,UAA1B;AACA;;AAED,WAAKb,IAAL,CAAY,WAAWI,MAAQ,EAA/B,EAAkCU,SAAlC;AACA;AACD;;AA9I+B;AAiJjCjC,GAAG,CAAEG,WAAF,EAAeF,eAAf,CAAH;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/textwatcher\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport getLastTextLine from './utils/getlasttextline';\n\n/**\n * The text watcher feature.\n *\n * Fires the {@link module:typing/textwatcher~TextWatcher#event:matched:data `matched:data`},\n * {@link module:typing/textwatcher~TextWatcher#event:matched:selection `matched:selection`} and\n * {@link module:typing/textwatcher~TextWatcher#event:unmatched `unmatched`} events on typing or selection changes.\n *\n * @private\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class TextWatcher {\n\t/**\n\t * Creates a text watcher instance.\n\t *\n\t * @param {module:engine/model/model~Model} model\n\t * @param {Function} testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.\n\t */\n\tconstructor( model, testCallback ) {\n\t\t/**\n\t\t * The editor's model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The function used to match the text.\n\t\t *\n\t\t * The test callback can return 3 values:\n\t\t *\n\t\t * * `false` if there is no match,\n\t\t * * `true` if there is a match,\n\t\t * * an object if there is a match and we want to pass some additional information to the {@link #event:matched:data} event.\n\t\t *\n\t\t * @member {Function} #testCallback\n\t\t * @returns {Object} testResult\n\t\t */\n\t\tthis.testCallback = testCallback;\n\n\t\t/**\n\t\t * Whether there is a match currently.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.hasMatch = false;\n\n\t\t/**\n\t\t * Flag indicating whether the `TextWatcher` instance is enabled or disabled.\n\t\t * A disabled TextWatcher will not evaluate text.\n\t\t *\n\t\t * To disable TextWatcher:\n\t\t *\n\t\t *\t\tconst watcher = new TextWatcher( editor.model, testCallback );\n\t\t *\n\t\t *\t\t// After this a testCallback will not be called.\n\t\t *\t\twatcher.isEnabled = false;\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #isEnabled\n\t\t */\n\t\tthis.set( 'isEnabled', true );\n\n\t\t// Toggle text watching on isEnabled state change.\n\t\tthis.on( 'change:isEnabled', () => {\n\t\t\tif ( this.isEnabled ) {\n\t\t\t\tthis._startListening();\n\t\t\t} else {\n\t\t\t\tthis.stopListening( model.document.selection );\n\t\t\t\tthis.stopListening( model.document );\n\t\t\t}\n\t\t} );\n\n\t\tthis._startListening();\n\t}\n\n\t/**\n\t * Starts listening to the editor for typing and selection events.\n\t *\n\t * @private\n\t */\n\t_startListening() {\n\t\tconst model = this.model;\n\t\tconst document = model.document;\n\n\t\tthis.listenTo( document.selection, 'change:range', ( evt, { directChange } ) => {\n\t\t\t// Indirect changes (i.e. when the user types or external changes are applied) are handled in the document's change event.\n\t\t\tif ( !directChange ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Act only on collapsed selection.\n\t\t\tif ( !document.selection.isCollapsed ) {\n\t\t\t\tif ( this.hasMatch ) {\n\t\t\t\t\tthis.fire( 'unmatched' );\n\t\t\t\t\tthis.hasMatch = false;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._evaluateTextBeforeSelection( 'selection' );\n\t\t} );\n\n\t\tthis.listenTo( document, 'change:data', ( evt, batch ) => {\n\t\t\tif ( batch.type == 'transparent' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._evaluateTextBeforeSelection( 'data', { batch } );\n\t\t} );\n\t}\n\n\t/**\n\t * Checks the editor content for matched text.\n\t *\n\t * @fires matched:data\n\t * @fires matched:selection\n\t * @fires unmatched\n\t *\n\t * @private\n\t * @param {'data'|'selection'} suffix A suffix used for generating the event name.\n\t * @param {Object} data Data object for event.\n\t */\n\t_evaluateTextBeforeSelection( suffix, data = {} ) {\n\t\tconst model = this.model;\n\t\tconst document = model.document;\n\t\tconst selection = document.selection;\n\n\t\tconst rangeBeforeSelection = model.createRange( model.createPositionAt( selection.focus.parent, 0 ), selection.focus );\n\n\t\tconst { text, range } = getLastTextLine( rangeBeforeSelection, model );\n\n\t\tconst testResult = this.testCallback( text );\n\n\t\tif ( !testResult && this.hasMatch ) {\n\t\t\tthis.fire( 'unmatched' );\n\t\t}\n\n\t\tthis.hasMatch = !!testResult;\n\n\t\tif ( testResult ) {\n\t\t\tconst eventData = Object.assign( data, { text, range } );\n\n\t\t\t// If the test callback returns an object with additional data, assign the data as well.\n\t\t\tif ( typeof testResult == 'object' ) {\n\t\t\t\tObject.assign( eventData, testResult );\n\t\t\t}\n\n\t\t\tthis.fire( `matched:${ suffix }`, eventData );\n\t\t}\n\t}\n}\n\nmix( TextWatcher, ObservableMixin );\n\n/**\n * Fired whenever the text watcher found a match for data changes.\n *\n * @event matched:data\n * @param {Object} data Event data.\n * @param {String} data.text The full text before selection to which the regexp was applied.\n * @param {module:engine/model/range~Range} data.range The range representing the position of the `data.text`.\n * @param {Object} [data.testResult] The additional data returned from the {@link module:typing/textwatcher~TextWatcher#testCallback}.\n */\n\n/**\n * Fired whenever the text watcher found a match for selection changes.\n *\n * @event matched:selection\n * @param {Object} data Event data.\n * @param {String} data.text The full text before selection.\n * @param {module:engine/model/range~Range} data.range The range representing the position of the `data.text`.\n * @param {Object} [data.testResult] The additional data returned from the {@link module:typing/textwatcher~TextWatcher#testCallback}.\n */\n\n/**\n * Fired whenever the text does not match anymore. Fired only when the text watcher found a match.\n *\n * @event unmatched\n */\n"]},"metadata":{},"sourceType":"module"}