{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/converters\n */\nimport { TreeWalker } from 'ckeditor5/src/engine';\nimport { generateLiInUl, injectViewList, mergeViewLists, getSiblingListItem, positionAfterUiElements } from './utils';\n/**\n * A model-to-view converter for the `listItem` model element insertion.\n *\n * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct\n * position, and merges the list with surrounding lists (if available).\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewInsertion(model) {\n  return (evt, data, conversionApi) => {\n    const consumable = conversionApi.consumable;\n\n    if (!consumable.test(data.item, 'insert') || !consumable.test(data.item, 'attribute:listType') || !consumable.test(data.item, 'attribute:listIndent')) {\n      return;\n    }\n\n    consumable.consume(data.item, 'insert');\n    consumable.consume(data.item, 'attribute:listType');\n    consumable.consume(data.item, 'attribute:listIndent');\n    const modelItem = data.item;\n    const viewItem = generateLiInUl(modelItem, conversionApi);\n    injectViewList(modelItem, viewItem, conversionApi, model);\n  };\n}\n/**\n * A model-to-view converter for the `listItem` model element removal.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewRemove(model) {\n  return (evt, data, conversionApi) => {\n    const viewPosition = conversionApi.mapper.toViewPosition(data.position);\n    const viewStart = viewPosition.getLastMatchingPosition(value => !value.item.is('element', 'li'));\n    const viewItem = viewStart.nodeAfter;\n    const viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.\n    // This will create a view list with one view list item - the one to remove.\n\n    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Remove the list with the item to remove.\n\n    const viewList = viewItem.parent;\n    const viewListPrev = viewList.previousSibling;\n    const removeRange = viewWriter.createRangeOn(viewList);\n    const removed = viewWriter.remove(removeRange); // 3. Merge the whole created by breaking and removing the list.\n\n    if (viewListPrev && viewListPrev.nextSibling) {\n      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);\n    } // 4. Bring back nested list that was in the removed <li>.\n\n\n    const modelItem = conversionApi.mapper.toModelElement(viewItem);\n    hoistNestedLists(modelItem.getAttribute('listIndent') + 1, data.position, removeRange.start, viewItem, conversionApi, model); // 5. Unbind removed view item and all children.\n\n    for (const child of viewWriter.createRangeIn(removed).getItems()) {\n      conversionApi.mapper.unbindViewElement(child);\n    }\n\n    evt.stop();\n  };\n}\n/**\n * A model-to-view converter for the `type` attribute change on the `listItem` model element.\n *\n * This change means that the `<li>` element parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished\n * by breaking view elements and changing their name. The next {@link module:list/converters~modelViewMergeAfterChangeType}\n * converter will attempt to merge split nodes.\n *\n * Splitting this conversion into 2 steps makes it possible to add an additional conversion in the middle.\n * Check {@link module:list/todolistconverters~modelViewChangeType} to see an example of it.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewChangeType(evt, data, conversionApi) {\n  if (!conversionApi.consumable.consume(data.item, 'attribute:listType')) {\n    return;\n  }\n\n  const viewItem = conversionApi.mapper.toViewElement(data.item);\n  const viewWriter = conversionApi.writer; // Break the container after and before the list item.\n  // This will create a view list with one view list item -- the one that changed type.\n\n  viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n  viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // Change name of the view list that holds the changed view item.\n  // We cannot just change name property, because that would not render properly.\n\n  const viewList = viewItem.parent;\n  const listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';\n  viewWriter.rename(listName, viewList);\n}\n/**\n * A model-to-view converter that attempts to merge nodes split by {@link module:list/converters~modelViewChangeType}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewMergeAfterChangeType(evt, data, conversionApi) {\n  const viewItem = conversionApi.mapper.toViewElement(data.item);\n  const viewList = viewItem.parent;\n  const viewWriter = conversionApi.writer; // Merge the changed view list with other lists, if possible.\n\n  mergeViewLists(viewWriter, viewList, viewList.nextSibling);\n  mergeViewLists(viewWriter, viewList.previousSibling, viewList); // Consumable insertion of children inside the item. They are already handled by re-building the item in view.\n\n  for (const child of data.item.getChildren()) {\n    conversionApi.consumable.consume(child, 'insert');\n  }\n}\n/**\n * A model-to-view converter for the `listIndent` attribute change on the `listItem` model element.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewChangeIndent(model) {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.consume(data.item, 'attribute:listIndent')) {\n      return;\n    }\n\n    const viewItem = conversionApi.mapper.toViewElement(data.item);\n    const viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.\n    // This will create a view list with one view list item -- the one that changed type.\n\n    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Extract view list with changed view list item and merge \"hole\" possibly created by breaking and removing elements.\n\n    const viewList = viewItem.parent;\n    const viewListPrev = viewList.previousSibling;\n    const removeRange = viewWriter.createRangeOn(viewList);\n    viewWriter.remove(removeRange);\n\n    if (viewListPrev && viewListPrev.nextSibling) {\n      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);\n    } // 3. Bring back nested list that was in the removed <li>.\n\n\n    hoistNestedLists(data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model); // 4. Inject view list like it is newly inserted.\n\n    injectViewList(data.item, viewItem, conversionApi, model); // 5. Consume insertion of children inside the item. They are already handled by re-building the item in view.\n\n    for (const child of data.item.getChildren()) {\n      conversionApi.consumable.consume(child, 'insert');\n    }\n  };\n}\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for\n * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted\n * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the\n * list so the model element is inserted to the view parent element corresponding to its model parent element.\n *\n * The converter prevents such situations:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>\n *\t\t<paragraph>xxx</paragraph>       // Instead of this wrong view state:\n *\t\t<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewSplitOnInsert(evt, data, conversionApi) {\n  if (data.item.name != 'listItem') {\n    let viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    const viewWriter = conversionApi.writer;\n    const lists = []; // Break multiple ULs/OLs if there are.\n    //\n    // Imagine following list:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //     1.1.2 --------\n    //     1.1.3 --------\n    //       1.1.3.1 --------\n    //   1.2 --------\n    //     1.2.1 --------\n    // 2 --------\n    //\n    // Insert paragraph after item 1.1.1:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //\n    // Lorem ipsum.\n    //\n    //     1.1.2 --------\n    //     1.1.3 --------\n    //       1.1.3.1 --------\n    //   1.2 --------\n    //     1.2.1 --------\n    // 2 --------\n    //\n    // In this case 1.1.2 has to become beginning of a new list.\n    // We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.\n    // Then we need to move those broken pieces one after another and merge:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //\n    // Lorem ipsum.\n    //\n    // 1.1.2 --------\n    //   1.1.3 --------\n    //     1.1.3.1 --------\n    // 1.2 --------\n    //   1.2.1 --------\n    // 2 --------\n    //\n\n    while (viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol') {\n      viewPosition = viewWriter.breakContainer(viewPosition);\n\n      if (viewPosition.parent.name != 'li') {\n        break;\n      } // Remove lists that are after inserted element.\n      // They will be brought back later, below the inserted element.\n\n\n      const removeStart = viewPosition;\n      const removeEnd = viewWriter.createPositionAt(viewPosition.parent, 'end'); // Don't remove if there is nothing to remove.\n\n      if (!removeStart.isEqual(removeEnd)) {\n        const removed = viewWriter.remove(viewWriter.createRange(removeStart, removeEnd));\n        lists.push(removed);\n      }\n\n      viewPosition = viewWriter.createPositionAfter(viewPosition.parent);\n    } // Bring back removed lists.\n\n\n    if (lists.length > 0) {\n      for (let i = 0; i < lists.length; i++) {\n        const previousList = viewPosition.nodeBefore;\n        const insertedRange = viewWriter.insert(viewPosition, lists[i]);\n        viewPosition = insertedRange.end; // Don't merge first list! We want a split in that place (this is why this converter is introduced).\n\n        if (i > 0) {\n          const mergePos = mergeViewLists(viewWriter, previousList, previousList.nextSibling); // If `mergePos` is in `previousList` it means that the lists got merged.\n          // In this case, we need to fix insert position.\n\n          if (mergePos && mergePos.parent == previousList) {\n            viewPosition.offset--;\n          }\n        }\n      } // Merge last inserted list with element after it.\n\n\n      mergeViewLists(viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter);\n    }\n  }\n}\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of\n * merging view lists after something is removed or moved from near them.\n *\n * Example:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul>\n *\t\t<paragraph>xxx</paragraph>       <p>xxx</p>\n *\t\t<listItem>bar</listItem>         <ul><li>bar</li></ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewMergeAfter(evt, data, conversionApi) {\n  const viewPosition = conversionApi.mapper.toViewPosition(data.position);\n  const viewItemPrev = viewPosition.nodeBefore;\n  const viewItemNext = viewPosition.nodeAfter; // Merge lists if something (remove, move) was done from inside of list.\n  // Merging will be done only if both items are view lists of the same type.\n  // The check is done inside the helper function.\n\n  mergeViewLists(conversionApi.writer, viewItemPrev, viewItemNext);\n}\n/**\n * A view-to-model converter that converts the `<li>` view elements into the `listItem` model elements.\n *\n * To set correct values of the `listType` and `listIndent` attributes the converter:\n * * checks `<li>`'s parent,\n * * stores and increases the `conversionApi.store.indent` value when `<li>`'s sub-items are converted.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function viewModelConverter(evt, data, conversionApi) {\n  if (conversionApi.consumable.consume(data.viewItem, {\n    name: true\n  })) {\n    const writer = conversionApi.writer; // 1. Create `listItem` model element.\n\n    const listItem = writer.createElement('listItem'); // 2. Handle `listItem` model element attributes.\n\n    const indent = getIndent(data.viewItem);\n    writer.setAttribute('listIndent', indent, listItem); // Set 'bulleted' as default. If this item is pasted into a context,\n\n    const type = data.viewItem.parent && data.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted';\n    writer.setAttribute('listType', type, listItem);\n\n    if (!conversionApi.safeInsert(listItem, data.modelCursor)) {\n      return;\n    }\n\n    const nextPosition = viewToModelListItemChildrenConverter(listItem, data.viewItem.getChildren(), conversionApi); // Result range starts before the first item and ends after the last.\n\n    data.modelRange = writer.createRange(data.modelCursor, nextPosition);\n    conversionApi.updateConversionResult(listItem, data);\n  }\n}\n/**\n * A view-to-model converter for the `<ul>` and `<ol>` view elements that cleans the input view of garbage.\n * This is mostly to clean whitespaces from between the `<li>` view elements inside the view list element, however, also\n * incorrect data can be cleared if the view was incorrect.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function cleanList(evt, data, conversionApi) {\n  if (conversionApi.consumable.test(data.viewItem, {\n    name: true\n  })) {\n    // Caching children because when we start removing them iterating fails.\n    const children = Array.from(data.viewItem.getChildren());\n\n    for (const child of children) {\n      const isWrongElement = !(child.is('element', 'li') || isList(child));\n\n      if (isWrongElement) {\n        child._remove();\n      }\n    }\n  }\n}\n/**\n * A view-to-model converter for the `<li>` elements that cleans whitespace formatting from the input view.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function cleanListItem(evt, data, conversionApi) {\n  if (conversionApi.consumable.test(data.viewItem, {\n    name: true\n  })) {\n    if (data.viewItem.childCount === 0) {\n      return;\n    }\n\n    const children = [...data.viewItem.getChildren()];\n    let foundList = false;\n\n    for (const child of children) {\n      if (foundList && !isList(child)) {\n        child._remove();\n      }\n\n      if (isList(child)) {\n        // If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.\n        foundList = true;\n      }\n    }\n  }\n}\n/**\n * Returns a callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `listItem` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:modelToViewPosition\n * @param {module:engine/view/view~View} view A view instance.\n * @returns {Function}\n */\n\nexport function modelToViewPosition(view) {\n  return (evt, data) => {\n    if (data.isPhantom) {\n      return;\n    }\n\n    const modelItem = data.modelPosition.nodeBefore;\n\n    if (modelItem && modelItem.is('element', 'listItem')) {\n      const viewItem = data.mapper.toViewElement(modelItem);\n      const topmostViewList = viewItem.getAncestors().find(isList);\n      const walker = view.createPositionAt(viewItem, 0).getWalker();\n\n      for (const value of walker) {\n        if (value.type == 'elementStart' && value.item.is('element', 'li')) {\n          data.viewPosition = value.previousPosition;\n          break;\n        } else if (value.type == 'elementEnd' && value.item == topmostViewList) {\n          data.viewPosition = value.nextPosition;\n          break;\n        }\n      }\n    }\n  };\n}\n/**\n * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `<li>` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function viewToModelPosition(model) {\n  return (evt, data) => {\n    const viewPos = data.viewPosition;\n    const viewParent = viewPos.parent;\n    const mapper = data.mapper;\n\n    if (viewParent.name == 'ul' || viewParent.name == 'ol') {\n      // Position is directly in <ul> or <ol>.\n      if (!viewPos.isAtEnd) {\n        // If position is not at the end, it must be before <li>.\n        // Get that <li>, map it to `listItem` and set model position before that `listItem`.\n        const modelNode = mapper.toModelElement(viewPos.nodeAfter);\n        data.modelPosition = model.createPositionBefore(modelNode);\n      } else {\n        // Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.\n        // There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,\n        // because that <li> may contain nested items.\n        // We will check \"model length\" of that <li>, in other words - how many `listItem`s are in that <li>.\n        const modelNode = mapper.toModelElement(viewPos.nodeBefore);\n        const modelLength = mapper.getModelLength(viewPos.nodeBefore); // Then we get model position before mapped `listItem` and shift it accordingly.\n\n        data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);\n      }\n\n      evt.stop();\n    } else if (viewParent.name == 'li' && viewPos.nodeBefore && (viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol')) {\n      // In most cases when view position is in <li> it is in text and this is a correct position.\n      // However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.\n      const modelNode = mapper.toModelElement(viewParent); // Check all <ul>s and <ol>s that are in the <li> but before mapped position.\n      // Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.\n\n      let modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.\n\n      let viewList = viewPos.nodeBefore;\n\n      while (viewList && isList(viewList)) {\n        modelLength += mapper.getModelLength(viewList);\n        viewList = viewList.previousSibling;\n      }\n\n      data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);\n      evt.stop();\n    }\n  };\n}\n/**\n * Post-fixer that reacts to changes on document and fixes incorrect model states.\n *\n * In the example below, there is a correct list structure.\n * Then the middle element is removed so the list structure will become incorrect:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 2</listItem>   <--- this is removed.\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * The list structure after the middle element is removed:\n *\n * \t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 3</listItem>   <--- note that indent got post-fixed.\n *\n * @param {module:engine/model/model~Model} model The data model.\n * @param {module:engine/model/writer~Writer} writer The writer to do changes with.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\n\nexport function modelChangePostFixer(model, writer) {\n  const changes = model.document.differ.getChanges();\n  const itemToListHead = new Map();\n  let applied = false;\n\n  for (const entry of changes) {\n    if (entry.type == 'insert' && entry.name == 'listItem') {\n      _addListToFix(entry.position);\n    } else if (entry.type == 'insert' && entry.name != 'listItem') {\n      if (entry.name != '$text') {\n        // In case of renamed element.\n        const item = entry.position.nodeAfter;\n\n        if (item.hasAttribute('listIndent')) {\n          writer.removeAttribute('listIndent', item);\n          applied = true;\n        }\n\n        if (item.hasAttribute('listType')) {\n          writer.removeAttribute('listType', item);\n          applied = true;\n        }\n\n        if (item.hasAttribute('listStyle')) {\n          writer.removeAttribute('listStyle', item);\n          applied = true;\n        }\n\n        for (const innerItem of Array.from(model.createRangeIn(item)).filter(e => e.item.is('element', 'listItem'))) {\n          _addListToFix(innerItem.previousPosition);\n        }\n      }\n\n      const posAfter = entry.position.getShiftedBy(entry.length);\n\n      _addListToFix(posAfter);\n    } else if (entry.type == 'remove' && entry.name == 'listItem') {\n      _addListToFix(entry.position);\n    } else if (entry.type == 'attribute' && entry.attributeKey == 'listIndent') {\n      _addListToFix(entry.range.start);\n    } else if (entry.type == 'attribute' && entry.attributeKey == 'listType') {\n      _addListToFix(entry.range.start);\n    }\n  }\n\n  for (const listHead of itemToListHead.values()) {\n    _fixListIndents(listHead);\n\n    _fixListTypes(listHead);\n  }\n\n  return applied;\n\n  function _addListToFix(position) {\n    const previousNode = position.nodeBefore;\n\n    if (!previousNode || !previousNode.is('element', 'listItem')) {\n      const item = position.nodeAfter;\n\n      if (item && item.is('element', 'listItem')) {\n        itemToListHead.set(item, item);\n      }\n    } else {\n      let listHead = previousNode;\n\n      if (itemToListHead.has(listHead)) {\n        return;\n      }\n\n      for ( // Cache previousSibling and reuse for performance reasons. See #6581.\n      let previousSibling = listHead.previousSibling; previousSibling && previousSibling.is('element', 'listItem'); previousSibling = listHead.previousSibling) {\n        listHead = previousSibling;\n\n        if (itemToListHead.has(listHead)) {\n          return;\n        }\n      }\n\n      itemToListHead.set(previousNode, listHead);\n    }\n  }\n\n  function _fixListIndents(item) {\n    let maxIndent = 0;\n    let fixBy = null;\n\n    while (item && item.is('element', 'listItem')) {\n      const itemIndent = item.getAttribute('listIndent');\n\n      if (itemIndent > maxIndent) {\n        let newIndent;\n\n        if (fixBy === null) {\n          fixBy = itemIndent - maxIndent;\n          newIndent = maxIndent;\n        } else {\n          if (fixBy > itemIndent) {\n            fixBy = itemIndent;\n          }\n\n          newIndent = itemIndent - fixBy;\n        }\n\n        writer.setAttribute('listIndent', newIndent, item);\n        applied = true;\n      } else {\n        fixBy = null;\n        maxIndent = item.getAttribute('listIndent') + 1;\n      }\n\n      item = item.nextSibling;\n    }\n  }\n\n  function _fixListTypes(item) {\n    let typesStack = [];\n    let prev = null;\n\n    while (item && item.is('element', 'listItem')) {\n      const itemIndent = item.getAttribute('listIndent');\n\n      if (prev && prev.getAttribute('listIndent') > itemIndent) {\n        typesStack = typesStack.slice(0, itemIndent + 1);\n      }\n\n      if (itemIndent != 0) {\n        if (typesStack[itemIndent]) {\n          const type = typesStack[itemIndent];\n\n          if (item.getAttribute('listType') != type) {\n            writer.setAttribute('listType', type, item);\n            applied = true;\n          }\n        } else {\n          typesStack[itemIndent] = item.getAttribute('listType');\n        }\n      }\n\n      prev = item;\n      item = item.nextSibling;\n    }\n  }\n}\n/**\n * A fixer for pasted content that includes list items.\n *\n * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.\n *\n * Example:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>B^</listItem>\n *\t\t// At ^ paste:  <listItem listType=\"bulleted\" listIndent=4>X</listItem>\n *\t\t//              <listItem listType=\"bulleted\" listIndent=5>Y</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>BX</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Y/listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Array} args Arguments of {@link module:engine/model/model~Model#insertContent}.\n */\n\nexport function modelIndentPasteFixer(evt, [content, selectable]) {\n  // Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other\n  // elements before it and there is no need to fix indents, because even if we insert that content into a list,\n  // that list will be broken.\n  // Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2\n  // would create incorrect model.\n  let item = content.is('documentFragment') ? content.getChild(0) : content;\n  let selection;\n\n  if (!selectable) {\n    selection = this.document.selection;\n  } else {\n    selection = this.createSelection(selectable);\n  }\n\n  if (item && item.is('element', 'listItem')) {\n    // Get a reference list item. Inserted list items will be fixed according to that item.\n    const pos = selection.getFirstPosition();\n    let refItem = null;\n\n    if (pos.parent.is('element', 'listItem')) {\n      refItem = pos.parent;\n    } else if (pos.nodeBefore && pos.nodeBefore.is('element', 'listItem')) {\n      refItem = pos.nodeBefore;\n    } // If there is `refItem` it means that we do insert list items into an existing list.\n\n\n    if (refItem) {\n      // First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal\n      // to the indent of reference item. We have to fix the first item and all of it's children and following siblings.\n      // Indent of all those items has to be adjusted to reference item.\n      const indentChange = refItem.getAttribute('listIndent'); // Fix only if there is anything to fix.\n\n      if (indentChange > 0) {\n        // Adjust indent of all \"first\" list items in inserted data.\n        while (item && item.is('element', 'listItem')) {\n          item._setAttribute('listIndent', item.getAttribute('listIndent') + indentChange);\n\n          item = item.nextSibling;\n        }\n      }\n    }\n  }\n} // Helper function that converts children of a given `<li>` view element into corresponding model elements.\n// The function maintains proper order of elements if model `listItem` is split during the conversion\n// due to block children conversion.\n//\n// @param {module:engine/model/element~Element} listItemModel List item model element to which converted children will be inserted.\n// @param {Iterable.<module:engine/view/node~Node>} viewChildren View elements which will be converted.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n// @returns {module:engine/model/position~Position} Position on which next elements should be inserted after children conversion.\n\nfunction viewToModelListItemChildrenConverter(listItemModel, viewChildren, conversionApi) {\n  const {\n    writer,\n    schema\n  } = conversionApi; // A position after the last inserted `listItem`.\n\n  let nextPosition = writer.createPositionAfter(listItemModel); // Check all children of the converted `<li>`. At this point we assume there are no \"whitespace\" view text nodes\n  // in view list, between view list items. This should be handled by `<ul>` and `<ol>` converters.\n\n  for (const child of viewChildren) {\n    if (child.name == 'ul' || child.name == 'ol') {\n      // If the children is a list, we will insert its conversion result after currently handled `listItem`.\n      // Then, next insertion position will be set after all the new list items (and maybe other elements if\n      // something split list item).\n      //\n      // If this is a list, we expect that some `listItem`s and possibly other blocks will be inserted, however `.modelCursor`\n      // should be set after last `listItem` (or block). This is why it feels safe to use it as `nextPosition`\n      nextPosition = conversionApi.convertItem(child, nextPosition).modelCursor;\n    } else {\n      // If this is not a list, try inserting content at the end of the currently handled `listItem`.\n      const result = conversionApi.convertItem(child, writer.createPositionAt(listItemModel, 'end')); // It may end up that the current `listItem` becomes split (if that content cannot be inside `listItem`). For example:\n      //\n      // <li><p>Foo</p></li>\n      //\n      // will be converted to:\n      //\n      // <listItem></listItem><paragraph>Foo</paragraph><listItem></listItem>\n      //\n\n      const convertedChild = result.modelRange.start.nodeAfter;\n      const wasSplit = convertedChild && convertedChild.is('element') && !schema.checkChild(listItemModel, convertedChild.name);\n\n      if (wasSplit) {\n        // As `lastListItem` got split, we need to update it to the second part of the split `listItem` element.\n        //\n        // `modelCursor` should be set to a position where the conversion should continue. There are multiple possible scenarios\n        // that may happen. Usually, `modelCursor` (marked as `#` below) would point to the second list item after conversion:\n        //\n        //\t\t`<li><p>Foo</p></li>` -> `<listItem></listItem><paragraph>Foo</paragraph><listItem>#</listItem>`\n        //\n        // However, in some cases, like auto-paragraphing, the position is placed at the end of the block element:\n        //\n        //\t\t`<li><div>Foo</div></li>` -> `<listItem></listItem><paragraph>Foo#</paragraph><listItem></listItem>`\n        //\n        // or after an element if another element broken auto-paragraphed element:\n        //\n        //\t\t`<li><div><h2>Foo</h2></div></li>` -> `<listItem></listItem><heading1>Foo</heading1>#<listItem></listItem>`\n        //\n        // We need to check for such cases and use proper list item and position based on it.\n        //\n        if (result.modelCursor.parent.is('element', 'listItem')) {\n          // (1).\n          listItemModel = result.modelCursor.parent;\n        } else {\n          // (2), (3).\n          listItemModel = findNextListItem(result.modelCursor);\n        }\n\n        nextPosition = writer.createPositionAfter(listItemModel);\n      }\n    }\n  }\n\n  return nextPosition;\n} // Helper function that seeks for a next list item starting from given `startPosition`.\n\n\nfunction findNextListItem(startPosition) {\n  const treeWalker = new TreeWalker({\n    startPosition\n  });\n  let value;\n\n  do {\n    value = treeWalker.next();\n  } while (!value.value.item.is('element', 'listItem'));\n\n  return value.value.item;\n} // Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according\n// to other given parameters.\n\n\nfunction hoistNestedLists(nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model) {\n  // Find correct previous model list item element.\n  // The element has to have either same or smaller indent than given reference indent.\n  // This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).\n  // Keep in mind that such element might not be found, if removed item was the first item.\n  const prevModelItem = getSiblingListItem(modelRemoveStartPosition.nodeBefore, {\n    sameIndent: true,\n    smallerIndent: true,\n    listIndent: nextIndent,\n    foo: 'b'\n  });\n  const mapper = conversionApi.mapper;\n  const viewWriter = conversionApi.writer; // Indent of found element or `null` if the element has not been found.\n\n  const prevIndent = prevModelItem ? prevModelItem.getAttribute('listIndent') : null;\n  let insertPosition;\n\n  if (!prevModelItem) {\n    // If element has not been found, simply insert lists at the position where the removed item was:\n    //\n    // Lorem ipsum.\n    // 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.\n    //   1.1 --------       <--- this is reference indent.\n    //     1.1.1 --------\n    //     1.1.2 --------\n    //   1.2 --------\n    //\n    // Becomes:\n    //\n    // Lorem ipsum.\n    // 1.1 --------\n    //   1.1.1 --------\n    //   1.1.2 --------\n    // 1.2 --------\n    insertPosition = viewRemoveStartPosition;\n  } else if (prevIndent == nextIndent) {\n    // If element has been found and has same indent as reference indent it means that nested items should\n    // become siblings of found element:\n    //\n    // 1 --------\n    //   1.1 --------\n    //   1.2 --------       <--- this is `prevModelItem`.\n    // 2 --------           <--- this is removed, previous list item has indent same as reference indent.\n    //   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.\n    //   2.2 --------\n    //\n    // Becomes:\n    //\n    // 1 --------\n    //   1.1 --------\n    //   1.2 --------\n    //   2.1 --------\n    //   2.2 --------\n    const prevViewList = mapper.toViewElement(prevModelItem).parent;\n    insertPosition = viewWriter.createPositionAfter(prevViewList);\n  } else {\n    // If element has been found and has smaller indent as reference indent it means that nested items\n    // should become nested items of found item:\n    //\n    // 1 --------           <--- this is `prevModelItem`.\n    //   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.\n    //     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.\n    //     1.1.2 --------\n    //   1.2 --------\n    //\n    // Becomes:\n    //\n    // 1 --------\n    //   1.1.1 --------\n    //   1.1.2 --------\n    //   1.2 --------\n    //\n    // Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,\n    // because following item may have indent bigger only by one. But this is fixed by postfixer.\n    const modelPosition = model.createPositionAt(prevModelItem, 'end');\n    insertPosition = mapper.toViewPosition(modelPosition);\n  }\n\n  insertPosition = positionAfterUiElements(insertPosition); // Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists\n  // are inserted after the first list (no need to recalculate insertion position for them).\n\n  for (const child of [...viewRemovedItem.getChildren()]) {\n    if (isList(child)) {\n      insertPosition = viewWriter.move(viewWriter.createRangeOn(child), insertPosition).end;\n      mergeViewLists(viewWriter, child, child.nextSibling);\n      mergeViewLists(viewWriter, child.previousSibling, child);\n    }\n  }\n} // Checks if view element is a list type (ul or ol).\n//\n// @param {module:engine/view/element~Element} viewElement\n// @returns {Boolean}\n\n\nfunction isList(viewElement) {\n  return viewElement.is('element', 'ol') || viewElement.is('element', 'ul');\n} // Calculates the indent value for a list item. Handles HTML compliant and non-compliant lists.\n//\n// Also, fixes non HTML compliant lists indents:\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> LI (parent LIs: 0)                      |-> LI     (indent: 0)\n//\t\t    |-> OL                                  |-> OL\n//\t\t        |-> OL                                  |\n//\t\t        |   |-> OL                              |\n//\t\t        |       |-> OL                          |\n//\t\t        |           |-> LI (parent LIs: 1)      |-> LI (indent: 1)\n//\t\t        |-> LI (parent LIs: 1)                  |-> LI (indent: 1)\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> OL                                      |\n//\t\t    |-> OL                                  |\n//\t\t         |-> OL                             |\n//\t\t             |-> LI (parent LIs: 0)         |-> LI        (indent: 0)\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> LI (parent LIs: 0)                      |-> LI         (indent: 0)\n//\t\t|-> OL                                          |-> OL\n//\t\t    |-> LI (parent LIs: 0)                          |-> LI (indent: 1)\n//\n// @param {module:engine/view/element~Element} listItem\n// @param {Object} conversionStore\n// @returns {Number}\n\n\nfunction getIndent(listItem) {\n  let indent = 0;\n  let parent = listItem.parent;\n\n  while (parent) {\n    // Each LI in the tree will result in an increased indent for HTML compliant lists.\n    if (parent.is('element', 'li')) {\n      indent++;\n    } else {\n      // If however the list is nested in other list we should check previous sibling of any of the list elements...\n      const previousSibling = parent.previousSibling; // ...because the we might need increase its indent:\n      //\t\tbefore:                           fixed list:\n      //\t\tOL                                OL\n      //\t\t|-> LI (parent LIs: 0)            |-> LI         (indent: 0)\n      //\t\t|-> OL                                |-> OL\n      //\t\t    |-> LI (parent LIs: 0)                |-> LI (indent: 1)\n\n      if (previousSibling && previousSibling.is('element', 'li')) {\n        indent++;\n      }\n    }\n\n    parent = parent.parent;\n  }\n\n  return indent;\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-list/src/converters.js"],"names":["TreeWalker","generateLiInUl","injectViewList","mergeViewLists","getSiblingListItem","positionAfterUiElements","modelViewInsertion","model","evt","data","conversionApi","consumable","test","item","consume","modelItem","viewItem","modelViewRemove","viewPosition","mapper","toViewPosition","position","viewStart","getLastMatchingPosition","value","is","nodeAfter","viewWriter","writer","breakContainer","createPositionBefore","createPositionAfter","viewList","parent","viewListPrev","previousSibling","removeRange","createRangeOn","removed","remove","nextSibling","toModelElement","hoistNestedLists","getAttribute","start","child","createRangeIn","getItems","unbindViewElement","stop","modelViewChangeType","toViewElement","listName","attributeNewValue","rename","modelViewMergeAfterChangeType","getChildren","modelViewChangeIndent","attributeOldValue","range","modelViewSplitOnInsert","name","lists","removeStart","removeEnd","createPositionAt","isEqual","createRange","push","length","i","previousList","nodeBefore","insertedRange","insert","end","mergePos","offset","modelViewMergeAfter","viewItemPrev","viewItemNext","viewModelConverter","listItem","createElement","indent","getIndent","setAttribute","type","safeInsert","modelCursor","nextPosition","viewToModelListItemChildrenConverter","modelRange","updateConversionResult","cleanList","children","Array","from","isWrongElement","isList","_remove","cleanListItem","childCount","foundList","modelToViewPosition","view","isPhantom","modelPosition","topmostViewList","getAncestors","find","walker","getWalker","previousPosition","viewToModelPosition","viewPos","viewParent","isAtEnd","modelNode","modelLength","getModelLength","getShiftedBy","modelChangePostFixer","changes","document","differ","getChanges","itemToListHead","Map","applied","entry","_addListToFix","hasAttribute","removeAttribute","innerItem","filter","e","posAfter","attributeKey","listHead","values","_fixListIndents","_fixListTypes","previousNode","set","has","maxIndent","fixBy","itemIndent","newIndent","typesStack","prev","slice","modelIndentPasteFixer","content","selectable","getChild","selection","createSelection","pos","getFirstPosition","refItem","indentChange","_setAttribute","listItemModel","viewChildren","schema","convertItem","result","convertedChild","wasSplit","checkChild","findNextListItem","startPosition","treeWalker","next","nextIndent","modelRemoveStartPosition","viewRemoveStartPosition","viewRemovedItem","prevModelItem","sameIndent","smallerIndent","listIndent","foo","prevIndent","insertPosition","prevViewList","move","viewElement"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/converters\n */\n\nimport { TreeWalker } from 'ckeditor5/src/engine';\n\nimport {\n\tgenerateLiInUl,\n\tinjectViewList,\n\tmergeViewLists,\n\tgetSiblingListItem,\n\tpositionAfterUiElements\n} from './utils';\n\n/**\n * A model-to-view converter for the `listItem` model element insertion.\n *\n * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct\n * position, and merges the list with surrounding lists (if available).\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewInsertion( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst consumable = conversionApi.consumable;\n\n\t\tif ( !consumable.test( data.item, 'insert' ) ||\n\t\t\t!consumable.test( data.item, 'attribute:listType' ) ||\n\t\t\t!consumable.test( data.item, 'attribute:listIndent' )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsumable.consume( data.item, 'insert' );\n\t\tconsumable.consume( data.item, 'attribute:listType' );\n\t\tconsumable.consume( data.item, 'attribute:listIndent' );\n\n\t\tconst modelItem = data.item;\n\t\tconst viewItem = generateLiInUl( modelItem, conversionApi );\n\n\t\tinjectViewList( modelItem, viewItem, conversionApi, model );\n\t};\n}\n\n/**\n * A model-to-view converter for the `listItem` model element removal.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewRemove( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.position );\n\t\tconst viewStart = viewPosition.getLastMatchingPosition( value => !value.item.is( 'element', 'li' ) );\n\t\tconst viewItem = viewStart.nodeAfter;\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// 1. Break the container after and before the list item.\n\t\t// This will create a view list with one view list item - the one to remove.\n\t\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\t\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t\t// 2. Remove the list with the item to remove.\n\t\tconst viewList = viewItem.parent;\n\t\tconst viewListPrev = viewList.previousSibling;\n\t\tconst removeRange = viewWriter.createRangeOn( viewList );\n\t\tconst removed = viewWriter.remove( removeRange );\n\n\t\t// 3. Merge the whole created by breaking and removing the list.\n\t\tif ( viewListPrev && viewListPrev.nextSibling ) {\n\t\t\tmergeViewLists( viewWriter, viewListPrev, viewListPrev.nextSibling );\n\t\t}\n\n\t\t// 4. Bring back nested list that was in the removed <li>.\n\t\tconst modelItem = conversionApi.mapper.toModelElement( viewItem );\n\n\t\thoistNestedLists( modelItem.getAttribute( 'listIndent' ) + 1, data.position, removeRange.start, viewItem, conversionApi, model );\n\n\t\t// 5. Unbind removed view item and all children.\n\t\tfor ( const child of viewWriter.createRangeIn( removed ).getItems() ) {\n\t\t\tconversionApi.mapper.unbindViewElement( child );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n/**\n * A model-to-view converter for the `type` attribute change on the `listItem` model element.\n *\n * This change means that the `<li>` element parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished\n * by breaking view elements and changing their name. The next {@link module:list/converters~modelViewMergeAfterChangeType}\n * converter will attempt to merge split nodes.\n *\n * Splitting this conversion into 2 steps makes it possible to add an additional conversion in the middle.\n * Check {@link module:list/todolistconverters~modelViewChangeType} to see an example of it.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewChangeType( evt, data, conversionApi ) {\n\tif ( !conversionApi.consumable.consume( data.item, 'attribute:listType' ) ) {\n\t\treturn;\n\t}\n\n\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\tconst viewWriter = conversionApi.writer;\n\n\t// Break the container after and before the list item.\n\t// This will create a view list with one view list item -- the one that changed type.\n\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t// Change name of the view list that holds the changed view item.\n\t// We cannot just change name property, because that would not render properly.\n\tconst viewList = viewItem.parent;\n\tconst listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';\n\n\tviewWriter.rename( listName, viewList );\n}\n\n/**\n * A model-to-view converter that attempts to merge nodes split by {@link module:list/converters~modelViewChangeType}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewMergeAfterChangeType( evt, data, conversionApi ) {\n\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\tconst viewList = viewItem.parent;\n\tconst viewWriter = conversionApi.writer;\n\n\t// Merge the changed view list with other lists, if possible.\n\tmergeViewLists( viewWriter, viewList, viewList.nextSibling );\n\tmergeViewLists( viewWriter, viewList.previousSibling, viewList );\n\n\t// Consumable insertion of children inside the item. They are already handled by re-building the item in view.\n\tfor ( const child of data.item.getChildren() ) {\n\t\tconversionApi.consumable.consume( child, 'insert' );\n\t}\n}\n\n/**\n * A model-to-view converter for the `listIndent` attribute change on the `listItem` model element.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewChangeIndent( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.consume( data.item, 'attribute:listIndent' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// 1. Break the container after and before the list item.\n\t\t// This will create a view list with one view list item -- the one that changed type.\n\t\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\t\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t\t// 2. Extract view list with changed view list item and merge \"hole\" possibly created by breaking and removing elements.\n\t\tconst viewList = viewItem.parent;\n\t\tconst viewListPrev = viewList.previousSibling;\n\t\tconst removeRange = viewWriter.createRangeOn( viewList );\n\t\tviewWriter.remove( removeRange );\n\n\t\tif ( viewListPrev && viewListPrev.nextSibling ) {\n\t\t\tmergeViewLists( viewWriter, viewListPrev, viewListPrev.nextSibling );\n\t\t}\n\n\t\t// 3. Bring back nested list that was in the removed <li>.\n\t\thoistNestedLists( data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model );\n\n\t\t// 4. Inject view list like it is newly inserted.\n\t\tinjectViewList( data.item, viewItem, conversionApi, model );\n\n\t\t// 5. Consume insertion of children inside the item. They are already handled by re-building the item in view.\n\t\tfor ( const child of data.item.getChildren() ) {\n\t\t\tconversionApi.consumable.consume( child, 'insert' );\n\t\t}\n\t};\n}\n\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for\n * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted\n * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the\n * list so the model element is inserted to the view parent element corresponding to its model parent element.\n *\n * The converter prevents such situations:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>\n *\t\t<paragraph>xxx</paragraph>       // Instead of this wrong view state:\n *\t\t<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewSplitOnInsert( evt, data, conversionApi ) {\n\tif ( data.item.name != 'listItem' ) {\n\t\tlet viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst lists = [];\n\n\t\t// Break multiple ULs/OLs if there are.\n\t\t//\n\t\t// Imagine following list:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//     1.1.2 --------\n\t\t//     1.1.3 --------\n\t\t//       1.1.3.1 --------\n\t\t//   1.2 --------\n\t\t//     1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\t// Insert paragraph after item 1.1.1:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//\n\t\t// Lorem ipsum.\n\t\t//\n\t\t//     1.1.2 --------\n\t\t//     1.1.3 --------\n\t\t//       1.1.3.1 --------\n\t\t//   1.2 --------\n\t\t//     1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\t// In this case 1.1.2 has to become beginning of a new list.\n\t\t// We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.\n\t\t// Then we need to move those broken pieces one after another and merge:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//\n\t\t// Lorem ipsum.\n\t\t//\n\t\t// 1.1.2 --------\n\t\t//   1.1.3 --------\n\t\t//     1.1.3.1 --------\n\t\t// 1.2 --------\n\t\t//   1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\twhile ( viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol' ) {\n\t\t\tviewPosition = viewWriter.breakContainer( viewPosition );\n\n\t\t\tif ( viewPosition.parent.name != 'li' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Remove lists that are after inserted element.\n\t\t\t// They will be brought back later, below the inserted element.\n\t\t\tconst removeStart = viewPosition;\n\t\t\tconst removeEnd = viewWriter.createPositionAt( viewPosition.parent, 'end' );\n\n\t\t\t// Don't remove if there is nothing to remove.\n\t\t\tif ( !removeStart.isEqual( removeEnd ) ) {\n\t\t\t\tconst removed = viewWriter.remove( viewWriter.createRange( removeStart, removeEnd ) );\n\t\t\t\tlists.push( removed );\n\t\t\t}\n\n\t\t\tviewPosition = viewWriter.createPositionAfter( viewPosition.parent );\n\t\t}\n\n\t\t// Bring back removed lists.\n\t\tif ( lists.length > 0 ) {\n\t\t\tfor ( let i = 0; i < lists.length; i++ ) {\n\t\t\t\tconst previousList = viewPosition.nodeBefore;\n\t\t\t\tconst insertedRange = viewWriter.insert( viewPosition, lists[ i ] );\n\t\t\t\tviewPosition = insertedRange.end;\n\n\t\t\t\t// Don't merge first list! We want a split in that place (this is why this converter is introduced).\n\t\t\t\tif ( i > 0 ) {\n\t\t\t\t\tconst mergePos = mergeViewLists( viewWriter, previousList, previousList.nextSibling );\n\n\t\t\t\t\t// If `mergePos` is in `previousList` it means that the lists got merged.\n\t\t\t\t\t// In this case, we need to fix insert position.\n\t\t\t\t\tif ( mergePos && mergePos.parent == previousList ) {\n\t\t\t\t\t\tviewPosition.offset--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Merge last inserted list with element after it.\n\t\t\tmergeViewLists( viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter );\n\t\t}\n\t}\n}\n\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of\n * merging view lists after something is removed or moved from near them.\n *\n * Example:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul>\n *\t\t<paragraph>xxx</paragraph>       <p>xxx</p>\n *\t\t<listItem>bar</listItem>         <ul><li>bar</li></ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewMergeAfter( evt, data, conversionApi ) {\n\tconst viewPosition = conversionApi.mapper.toViewPosition( data.position );\n\tconst viewItemPrev = viewPosition.nodeBefore;\n\tconst viewItemNext = viewPosition.nodeAfter;\n\n\t// Merge lists if something (remove, move) was done from inside of list.\n\t// Merging will be done only if both items are view lists of the same type.\n\t// The check is done inside the helper function.\n\tmergeViewLists( conversionApi.writer, viewItemPrev, viewItemNext );\n}\n\n/**\n * A view-to-model converter that converts the `<li>` view elements into the `listItem` model elements.\n *\n * To set correct values of the `listType` and `listIndent` attributes the converter:\n * * checks `<li>`'s parent,\n * * stores and increases the `conversionApi.store.indent` value when `<li>`'s sub-items are converted.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function viewModelConverter( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\tconst writer = conversionApi.writer;\n\n\t\t// 1. Create `listItem` model element.\n\t\tconst listItem = writer.createElement( 'listItem' );\n\n\t\t// 2. Handle `listItem` model element attributes.\n\t\tconst indent = getIndent( data.viewItem );\n\n\t\twriter.setAttribute( 'listIndent', indent, listItem );\n\n\t\t// Set 'bulleted' as default. If this item is pasted into a context,\n\t\tconst type = data.viewItem.parent && data.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted';\n\t\twriter.setAttribute( 'listType', type, listItem );\n\n\t\tif ( !conversionApi.safeInsert( listItem, data.modelCursor ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextPosition = viewToModelListItemChildrenConverter( listItem, data.viewItem.getChildren(), conversionApi );\n\n\t\t// Result range starts before the first item and ends after the last.\n\t\tdata.modelRange = writer.createRange( data.modelCursor, nextPosition );\n\n\t\tconversionApi.updateConversionResult( listItem, data );\n\t}\n}\n\n/**\n * A view-to-model converter for the `<ul>` and `<ol>` view elements that cleans the input view of garbage.\n * This is mostly to clean whitespaces from between the `<li>` view elements inside the view list element, however, also\n * incorrect data can be cleared if the view was incorrect.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function cleanList( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.test( data.viewItem, { name: true } ) ) {\n\t\t// Caching children because when we start removing them iterating fails.\n\t\tconst children = Array.from( data.viewItem.getChildren() );\n\n\t\tfor ( const child of children ) {\n\t\t\tconst isWrongElement = !( child.is( 'element', 'li' ) || isList( child ) );\n\n\t\t\tif ( isWrongElement ) {\n\t\t\t\tchild._remove();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A view-to-model converter for the `<li>` elements that cleans whitespace formatting from the input view.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function cleanListItem( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.test( data.viewItem, { name: true } ) ) {\n\t\tif ( data.viewItem.childCount === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst children = [ ...data.viewItem.getChildren() ];\n\n\t\tlet foundList = false;\n\n\t\tfor ( const child of children ) {\n\t\t\tif ( foundList && !isList( child ) ) {\n\t\t\t\tchild._remove();\n\t\t\t}\n\n\t\t\tif ( isList( child ) ) {\n\t\t\t\t// If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.\n\t\t\t\tfoundList = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Returns a callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `listItem` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:modelToViewPosition\n * @param {module:engine/view/view~View} view A view instance.\n * @returns {Function}\n */\nexport function modelToViewPosition( view ) {\n\treturn ( evt, data ) => {\n\t\tif ( data.isPhantom ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelItem = data.modelPosition.nodeBefore;\n\n\t\tif ( modelItem && modelItem.is( 'element', 'listItem' ) ) {\n\t\t\tconst viewItem = data.mapper.toViewElement( modelItem );\n\t\t\tconst topmostViewList = viewItem.getAncestors().find( isList );\n\t\t\tconst walker = view.createPositionAt( viewItem, 0 ).getWalker();\n\n\t\t\tfor ( const value of walker ) {\n\t\t\t\tif ( value.type == 'elementStart' && value.item.is( 'element', 'li' ) ) {\n\t\t\t\t\tdata.viewPosition = value.previousPosition;\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( value.type == 'elementEnd' && value.item == topmostViewList ) {\n\t\t\t\t\tdata.viewPosition = value.nextPosition;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `<li>` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function viewToModelPosition( model ) {\n\treturn ( evt, data ) => {\n\t\tconst viewPos = data.viewPosition;\n\t\tconst viewParent = viewPos.parent;\n\t\tconst mapper = data.mapper;\n\n\t\tif ( viewParent.name == 'ul' || viewParent.name == 'ol' ) {\n\t\t\t// Position is directly in <ul> or <ol>.\n\t\t\tif ( !viewPos.isAtEnd ) {\n\t\t\t\t// If position is not at the end, it must be before <li>.\n\t\t\t\t// Get that <li>, map it to `listItem` and set model position before that `listItem`.\n\t\t\t\tconst modelNode = mapper.toModelElement( viewPos.nodeAfter );\n\n\t\t\t\tdata.modelPosition = model.createPositionBefore( modelNode );\n\t\t\t} else {\n\t\t\t\t// Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.\n\t\t\t\t// There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,\n\t\t\t\t// because that <li> may contain nested items.\n\t\t\t\t// We will check \"model length\" of that <li>, in other words - how many `listItem`s are in that <li>.\n\t\t\t\tconst modelNode = mapper.toModelElement( viewPos.nodeBefore );\n\t\t\t\tconst modelLength = mapper.getModelLength( viewPos.nodeBefore );\n\n\t\t\t\t// Then we get model position before mapped `listItem` and shift it accordingly.\n\t\t\t\tdata.modelPosition = model.createPositionBefore( modelNode ).getShiftedBy( modelLength );\n\t\t\t}\n\n\t\t\tevt.stop();\n\t\t} else if (\n\t\t\tviewParent.name == 'li' &&\n\t\t\tviewPos.nodeBefore &&\n\t\t\t( viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol' )\n\t\t) {\n\t\t\t// In most cases when view position is in <li> it is in text and this is a correct position.\n\t\t\t// However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.\n\t\t\tconst modelNode = mapper.toModelElement( viewParent );\n\n\t\t\t// Check all <ul>s and <ol>s that are in the <li> but before mapped position.\n\t\t\t// Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.\n\t\t\tlet modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.\n\t\t\tlet viewList = viewPos.nodeBefore;\n\n\t\t\twhile ( viewList && isList( viewList ) ) {\n\t\t\t\tmodelLength += mapper.getModelLength( viewList );\n\n\t\t\t\tviewList = viewList.previousSibling;\n\t\t\t}\n\n\t\t\tdata.modelPosition = model.createPositionBefore( modelNode ).getShiftedBy( modelLength );\n\n\t\t\tevt.stop();\n\t\t}\n\t};\n}\n\n/**\n * Post-fixer that reacts to changes on document and fixes incorrect model states.\n *\n * In the example below, there is a correct list structure.\n * Then the middle element is removed so the list structure will become incorrect:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 2</listItem>   <--- this is removed.\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * The list structure after the middle element is removed:\n *\n * \t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 3</listItem>   <--- note that indent got post-fixed.\n *\n * @param {module:engine/model/model~Model} model The data model.\n * @param {module:engine/model/writer~Writer} writer The writer to do changes with.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\nexport function modelChangePostFixer( model, writer ) {\n\tconst changes = model.document.differ.getChanges();\n\tconst itemToListHead = new Map();\n\n\tlet applied = false;\n\n\tfor ( const entry of changes ) {\n\t\tif ( entry.type == 'insert' && entry.name == 'listItem' ) {\n\t\t\t_addListToFix( entry.position );\n\t\t} else if ( entry.type == 'insert' && entry.name != 'listItem' ) {\n\t\t\tif ( entry.name != '$text' ) {\n\t\t\t\t// In case of renamed element.\n\t\t\t\tconst item = entry.position.nodeAfter;\n\n\t\t\t\tif ( item.hasAttribute( 'listIndent' ) ) {\n\t\t\t\t\twriter.removeAttribute( 'listIndent', item );\n\n\t\t\t\t\tapplied = true;\n\t\t\t\t}\n\n\t\t\t\tif ( item.hasAttribute( 'listType' ) ) {\n\t\t\t\t\twriter.removeAttribute( 'listType', item );\n\n\t\t\t\t\tapplied = true;\n\t\t\t\t}\n\n\t\t\t\tif ( item.hasAttribute( 'listStyle' ) ) {\n\t\t\t\t\twriter.removeAttribute( 'listStyle', item );\n\n\t\t\t\t\tapplied = true;\n\t\t\t\t}\n\n\t\t\t\tfor ( const innerItem of Array.from( model.createRangeIn( item ) ).filter( e => e.item.is( 'element', 'listItem' ) ) ) {\n\t\t\t\t\t_addListToFix( innerItem.previousPosition );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst posAfter = entry.position.getShiftedBy( entry.length );\n\n\t\t\t_addListToFix( posAfter );\n\t\t} else if ( entry.type == 'remove' && entry.name == 'listItem' ) {\n\t\t\t_addListToFix( entry.position );\n\t\t} else if ( entry.type == 'attribute' && entry.attributeKey == 'listIndent' ) {\n\t\t\t_addListToFix( entry.range.start );\n\t\t} else if ( entry.type == 'attribute' && entry.attributeKey == 'listType' ) {\n\t\t\t_addListToFix( entry.range.start );\n\t\t}\n\t}\n\n\tfor ( const listHead of itemToListHead.values() ) {\n\t\t_fixListIndents( listHead );\n\t\t_fixListTypes( listHead );\n\t}\n\n\treturn applied;\n\n\tfunction _addListToFix( position ) {\n\t\tconst previousNode = position.nodeBefore;\n\n\t\tif ( !previousNode || !previousNode.is( 'element', 'listItem' ) ) {\n\t\t\tconst item = position.nodeAfter;\n\n\t\t\tif ( item && item.is( 'element', 'listItem' ) ) {\n\t\t\t\titemToListHead.set( item, item );\n\t\t\t}\n\t\t} else {\n\t\t\tlet listHead = previousNode;\n\n\t\t\tif ( itemToListHead.has( listHead ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (\n\t\t\t\t// Cache previousSibling and reuse for performance reasons. See #6581.\n\t\t\t\tlet previousSibling = listHead.previousSibling;\n\t\t\t\tpreviousSibling && previousSibling.is( 'element', 'listItem' );\n\t\t\t\tpreviousSibling = listHead.previousSibling\n\t\t\t) {\n\t\t\t\tlistHead = previousSibling;\n\n\t\t\t\tif ( itemToListHead.has( listHead ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titemToListHead.set( previousNode, listHead );\n\t\t}\n\t}\n\n\tfunction _fixListIndents( item ) {\n\t\tlet maxIndent = 0;\n\t\tlet fixBy = null;\n\n\t\twhile ( item && item.is( 'element', 'listItem' ) ) {\n\t\t\tconst itemIndent = item.getAttribute( 'listIndent' );\n\n\t\t\tif ( itemIndent > maxIndent ) {\n\t\t\t\tlet newIndent;\n\n\t\t\t\tif ( fixBy === null ) {\n\t\t\t\t\tfixBy = itemIndent - maxIndent;\n\t\t\t\t\tnewIndent = maxIndent;\n\t\t\t\t} else {\n\t\t\t\t\tif ( fixBy > itemIndent ) {\n\t\t\t\t\t\tfixBy = itemIndent;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewIndent = itemIndent - fixBy;\n\t\t\t\t}\n\n\t\t\t\twriter.setAttribute( 'listIndent', newIndent, item );\n\n\t\t\t\tapplied = true;\n\t\t\t} else {\n\t\t\t\tfixBy = null;\n\t\t\t\tmaxIndent = item.getAttribute( 'listIndent' ) + 1;\n\t\t\t}\n\n\t\t\titem = item.nextSibling;\n\t\t}\n\t}\n\n\tfunction _fixListTypes( item ) {\n\t\tlet typesStack = [];\n\t\tlet prev = null;\n\n\t\twhile ( item && item.is( 'element', 'listItem' ) ) {\n\t\t\tconst itemIndent = item.getAttribute( 'listIndent' );\n\n\t\t\tif ( prev && prev.getAttribute( 'listIndent' ) > itemIndent ) {\n\t\t\t\ttypesStack = typesStack.slice( 0, itemIndent + 1 );\n\t\t\t}\n\n\t\t\tif ( itemIndent != 0 ) {\n\t\t\t\tif ( typesStack[ itemIndent ] ) {\n\t\t\t\t\tconst type = typesStack[ itemIndent ];\n\n\t\t\t\t\tif ( item.getAttribute( 'listType' ) != type ) {\n\t\t\t\t\t\twriter.setAttribute( 'listType', type, item );\n\n\t\t\t\t\t\tapplied = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttypesStack[ itemIndent ] = item.getAttribute( 'listType' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev = item;\n\t\t\titem = item.nextSibling;\n\t\t}\n\t}\n}\n\n/**\n * A fixer for pasted content that includes list items.\n *\n * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.\n *\n * Example:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>B^</listItem>\n *\t\t// At ^ paste:  <listItem listType=\"bulleted\" listIndent=4>X</listItem>\n *\t\t//              <listItem listType=\"bulleted\" listIndent=5>Y</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>BX</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Y/listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Array} args Arguments of {@link module:engine/model/model~Model#insertContent}.\n */\nexport function modelIndentPasteFixer( evt, [ content, selectable ] ) {\n\t// Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other\n\t// elements before it and there is no need to fix indents, because even if we insert that content into a list,\n\t// that list will be broken.\n\t// Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2\n\t// would create incorrect model.\n\tlet item = content.is( 'documentFragment' ) ? content.getChild( 0 ) : content;\n\n\tlet selection;\n\n\tif ( !selectable ) {\n\t\tselection = this.document.selection;\n\t} else {\n\t\tselection = this.createSelection( selectable );\n\t}\n\n\tif ( item && item.is( 'element', 'listItem' ) ) {\n\t\t// Get a reference list item. Inserted list items will be fixed according to that item.\n\t\tconst pos = selection.getFirstPosition();\n\t\tlet refItem = null;\n\n\t\tif ( pos.parent.is( 'element', 'listItem' ) ) {\n\t\t\trefItem = pos.parent;\n\t\t} else if ( pos.nodeBefore && pos.nodeBefore.is( 'element', 'listItem' ) ) {\n\t\t\trefItem = pos.nodeBefore;\n\t\t}\n\n\t\t// If there is `refItem` it means that we do insert list items into an existing list.\n\t\tif ( refItem ) {\n\t\t\t// First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal\n\t\t\t// to the indent of reference item. We have to fix the first item and all of it's children and following siblings.\n\t\t\t// Indent of all those items has to be adjusted to reference item.\n\t\t\tconst indentChange = refItem.getAttribute( 'listIndent' );\n\n\t\t\t// Fix only if there is anything to fix.\n\t\t\tif ( indentChange > 0 ) {\n\t\t\t\t// Adjust indent of all \"first\" list items in inserted data.\n\t\t\t\twhile ( item && item.is( 'element', 'listItem' ) ) {\n\t\t\t\t\titem._setAttribute( 'listIndent', item.getAttribute( 'listIndent' ) + indentChange );\n\n\t\t\t\t\titem = item.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helper function that converts children of a given `<li>` view element into corresponding model elements.\n// The function maintains proper order of elements if model `listItem` is split during the conversion\n// due to block children conversion.\n//\n// @param {module:engine/model/element~Element} listItemModel List item model element to which converted children will be inserted.\n// @param {Iterable.<module:engine/view/node~Node>} viewChildren View elements which will be converted.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n// @returns {module:engine/model/position~Position} Position on which next elements should be inserted after children conversion.\nfunction viewToModelListItemChildrenConverter( listItemModel, viewChildren, conversionApi ) {\n\tconst { writer, schema } = conversionApi;\n\n\t// A position after the last inserted `listItem`.\n\tlet nextPosition = writer.createPositionAfter( listItemModel );\n\n\t// Check all children of the converted `<li>`. At this point we assume there are no \"whitespace\" view text nodes\n\t// in view list, between view list items. This should be handled by `<ul>` and `<ol>` converters.\n\tfor ( const child of viewChildren ) {\n\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t\t\t// If the children is a list, we will insert its conversion result after currently handled `listItem`.\n\t\t\t// Then, next insertion position will be set after all the new list items (and maybe other elements if\n\t\t\t// something split list item).\n\t\t\t//\n\t\t\t// If this is a list, we expect that some `listItem`s and possibly other blocks will be inserted, however `.modelCursor`\n\t\t\t// should be set after last `listItem` (or block). This is why it feels safe to use it as `nextPosition`\n\t\t\tnextPosition = conversionApi.convertItem( child, nextPosition ).modelCursor;\n\t\t} else {\n\t\t\t// If this is not a list, try inserting content at the end of the currently handled `listItem`.\n\t\t\tconst result = conversionApi.convertItem( child, writer.createPositionAt( listItemModel, 'end' ) );\n\n\t\t\t// It may end up that the current `listItem` becomes split (if that content cannot be inside `listItem`). For example:\n\t\t\t//\n\t\t\t// <li><p>Foo</p></li>\n\t\t\t//\n\t\t\t// will be converted to:\n\t\t\t//\n\t\t\t// <listItem></listItem><paragraph>Foo</paragraph><listItem></listItem>\n\t\t\t//\n\t\t\tconst convertedChild = result.modelRange.start.nodeAfter;\n\t\t\tconst wasSplit = convertedChild && convertedChild.is( 'element' ) && !schema.checkChild( listItemModel, convertedChild.name );\n\n\t\t\tif ( wasSplit ) {\n\t\t\t\t// As `lastListItem` got split, we need to update it to the second part of the split `listItem` element.\n\t\t\t\t//\n\t\t\t\t// `modelCursor` should be set to a position where the conversion should continue. There are multiple possible scenarios\n\t\t\t\t// that may happen. Usually, `modelCursor` (marked as `#` below) would point to the second list item after conversion:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><p>Foo</p></li>` -> `<listItem></listItem><paragraph>Foo</paragraph><listItem>#</listItem>`\n\t\t\t\t//\n\t\t\t\t// However, in some cases, like auto-paragraphing, the position is placed at the end of the block element:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><div>Foo</div></li>` -> `<listItem></listItem><paragraph>Foo#</paragraph><listItem></listItem>`\n\t\t\t\t//\n\t\t\t\t// or after an element if another element broken auto-paragraphed element:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><div><h2>Foo</h2></div></li>` -> `<listItem></listItem><heading1>Foo</heading1>#<listItem></listItem>`\n\t\t\t\t//\n\t\t\t\t// We need to check for such cases and use proper list item and position based on it.\n\t\t\t\t//\n\t\t\t\tif ( result.modelCursor.parent.is( 'element', 'listItem' ) ) {\n\t\t\t\t\t// (1).\n\t\t\t\t\tlistItemModel = result.modelCursor.parent;\n\t\t\t\t} else {\n\t\t\t\t\t// (2), (3).\n\t\t\t\t\tlistItemModel = findNextListItem( result.modelCursor );\n\t\t\t\t}\n\n\t\t\t\tnextPosition = writer.createPositionAfter( listItemModel );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nextPosition;\n}\n\n// Helper function that seeks for a next list item starting from given `startPosition`.\nfunction findNextListItem( startPosition ) {\n\tconst treeWalker = new TreeWalker( { startPosition } );\n\n\tlet value;\n\n\tdo {\n\t\tvalue = treeWalker.next();\n\t} while ( !value.value.item.is( 'element', 'listItem' ) );\n\n\treturn value.value.item;\n}\n\n// Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according\n// to other given parameters.\nfunction hoistNestedLists( nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model ) {\n\t// Find correct previous model list item element.\n\t// The element has to have either same or smaller indent than given reference indent.\n\t// This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).\n\t// Keep in mind that such element might not be found, if removed item was the first item.\n\tconst prevModelItem = getSiblingListItem( modelRemoveStartPosition.nodeBefore, {\n\t\tsameIndent: true,\n\t\tsmallerIndent: true,\n\t\tlistIndent: nextIndent,\n\t\tfoo: 'b'\n\t} );\n\n\tconst mapper = conversionApi.mapper;\n\tconst viewWriter = conversionApi.writer;\n\n\t// Indent of found element or `null` if the element has not been found.\n\tconst prevIndent = prevModelItem ? prevModelItem.getAttribute( 'listIndent' ) : null;\n\n\tlet insertPosition;\n\n\tif ( !prevModelItem ) {\n\t\t// If element has not been found, simply insert lists at the position where the removed item was:\n\t\t//\n\t\t// Lorem ipsum.\n\t\t// 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.\n\t\t//   1.1 --------       <--- this is reference indent.\n\t\t//     1.1.1 --------\n\t\t//     1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// Lorem ipsum.\n\t\t// 1.1 --------\n\t\t//   1.1.1 --------\n\t\t//   1.1.2 --------\n\t\t// 1.2 --------\n\t\tinsertPosition = viewRemoveStartPosition;\n\t} else if ( prevIndent == nextIndent ) {\n\t\t// If element has been found and has same indent as reference indent it means that nested items should\n\t\t// become siblings of found element:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//   1.2 --------       <--- this is `prevModelItem`.\n\t\t// 2 --------           <--- this is removed, previous list item has indent same as reference indent.\n\t\t//   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.\n\t\t//   2.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//   1.2 --------\n\t\t//   2.1 --------\n\t\t//   2.2 --------\n\t\tconst prevViewList = mapper.toViewElement( prevModelItem ).parent;\n\t\tinsertPosition = viewWriter.createPositionAfter( prevViewList );\n\t} else {\n\t\t// If element has been found and has smaller indent as reference indent it means that nested items\n\t\t// should become nested items of found item:\n\t\t//\n\t\t// 1 --------           <--- this is `prevModelItem`.\n\t\t//   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.\n\t\t//     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.\n\t\t//     1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1.1 --------\n\t\t//   1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,\n\t\t// because following item may have indent bigger only by one. But this is fixed by postfixer.\n\t\tconst modelPosition = model.createPositionAt( prevModelItem, 'end' );\n\t\tinsertPosition = mapper.toViewPosition( modelPosition );\n\t}\n\n\tinsertPosition = positionAfterUiElements( insertPosition );\n\n\t// Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists\n\t// are inserted after the first list (no need to recalculate insertion position for them).\n\tfor ( const child of [ ...viewRemovedItem.getChildren() ] ) {\n\t\tif ( isList( child ) ) {\n\t\t\tinsertPosition = viewWriter.move( viewWriter.createRangeOn( child ), insertPosition ).end;\n\n\t\t\tmergeViewLists( viewWriter, child, child.nextSibling );\n\t\t\tmergeViewLists( viewWriter, child.previousSibling, child );\n\t\t}\n\t}\n}\n\n// Checks if view element is a list type (ul or ol).\n//\n// @param {module:engine/view/element~Element} viewElement\n// @returns {Boolean}\nfunction isList( viewElement ) {\n\treturn viewElement.is( 'element', 'ol' ) || viewElement.is( 'element', 'ul' );\n}\n\n// Calculates the indent value for a list item. Handles HTML compliant and non-compliant lists.\n//\n// Also, fixes non HTML compliant lists indents:\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> LI (parent LIs: 0)                      |-> LI     (indent: 0)\n//\t\t    |-> OL                                  |-> OL\n//\t\t        |-> OL                                  |\n//\t\t        |   |-> OL                              |\n//\t\t        |       |-> OL                          |\n//\t\t        |           |-> LI (parent LIs: 1)      |-> LI (indent: 1)\n//\t\t        |-> LI (parent LIs: 1)                  |-> LI (indent: 1)\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> OL                                      |\n//\t\t    |-> OL                                  |\n//\t\t         |-> OL                             |\n//\t\t             |-> LI (parent LIs: 0)         |-> LI        (indent: 0)\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> LI (parent LIs: 0)                      |-> LI         (indent: 0)\n//\t\t|-> OL                                          |-> OL\n//\t\t    |-> LI (parent LIs: 0)                          |-> LI (indent: 1)\n//\n// @param {module:engine/view/element~Element} listItem\n// @param {Object} conversionStore\n// @returns {Number}\nfunction getIndent( listItem ) {\n\tlet indent = 0;\n\n\tlet parent = listItem.parent;\n\n\twhile ( parent ) {\n\t\t// Each LI in the tree will result in an increased indent for HTML compliant lists.\n\t\tif ( parent.is( 'element', 'li' ) ) {\n\t\t\tindent++;\n\t\t} else {\n\t\t\t// If however the list is nested in other list we should check previous sibling of any of the list elements...\n\t\t\tconst previousSibling = parent.previousSibling;\n\n\t\t\t// ...because the we might need increase its indent:\n\t\t\t//\t\tbefore:                           fixed list:\n\t\t\t//\t\tOL                                OL\n\t\t\t//\t\t|-> LI (parent LIs: 0)            |-> LI         (indent: 0)\n\t\t\t//\t\t|-> OL                                |-> OL\n\t\t\t//\t\t    |-> LI (parent LIs: 0)                |-> LI (indent: 1)\n\t\t\tif ( previousSibling && previousSibling.is( 'element', 'li' ) ) {\n\t\t\t\tindent++;\n\t\t\t}\n\t\t}\n\n\t\tparent = parent.parent;\n\t}\n\n\treturn indent;\n}\n"]},"metadata":{},"sourceType":"module"}