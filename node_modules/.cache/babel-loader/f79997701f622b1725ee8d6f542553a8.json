{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injectunsafekeystrokeshandling\n */\nimport { getCode } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { isShiftDeleteOnNonCollapsedSelection } from './utils';\n/**\n * Handles keystrokes which are unsafe for typing. This handler's logic is explained\n * in https://github.com/ckeditor/ckeditor5-typing/issues/83#issuecomment-398690251.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\n\nexport default function injectUnsafeKeystrokesHandling(editor) {\n  let latestCompositionSelection = null;\n  const model = editor.model;\n  const view = editor.editing.view;\n  const inputCommand = editor.commands.get('input'); // For Android, we want to handle keystrokes on `beforeinput` to be sure that code in `DeleteObserver` already had a chance to be fired.\n\n  if (env.isAndroid) {\n    view.document.on('beforeinput', (evt, evtData) => handleUnsafeKeystroke(evtData), {\n      priority: 'lowest'\n    });\n  } else {\n    view.document.on('keydown', (evt, evtData) => handleUnsafeKeystroke(evtData), {\n      priority: 'lowest'\n    });\n  }\n\n  view.document.on('compositionstart', handleCompositionStart, {\n    priority: 'lowest'\n  });\n  view.document.on('compositionend', () => {\n    latestCompositionSelection = model.createSelection(model.document.selection);\n  }, {\n    priority: 'lowest'\n  }); // Handles the keydown event. We need to guess whether such keystroke is going to result\n  // in typing. If so, then before character insertion happens, any selected content needs\n  // to be deleted. Otherwise the default browser deletion mechanism would be\n  // triggered, resulting in:\n  //\n  // * Hundreds of mutations which could not be handled.\n  // * But most importantly, loss of control over how the content is being deleted.\n  //\n  // The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)\n  // to handle the event.\n  //\n  // @param {module:engine/view/observer/keyobserver~KeyEventData} evtData\n\n  function handleUnsafeKeystroke(evtData) {\n    // Do not delete the content, if Shift + Delete key combination was pressed on a non-collapsed selection on Windows.\n    //\n    // The Shift + Delete key combination should work in the same way as the `cut` event on a non-collapsed selection on Windows.\n    // In fact, the native `cut` event is actually emitted in this case, but with lower priority. Therefore, in order to handle the\n    // Shift + Delete key combination correctly, it is enough to prevent the content deletion here.\n    if (env.isWindows && isShiftDeleteOnNonCollapsedSelection(evtData, view.document)) {\n      return;\n    }\n\n    const doc = model.document;\n    const isComposing = view.document.isComposing;\n    const isSelectionUnchanged = latestCompositionSelection && latestCompositionSelection.isEqual(doc.selection); // Reset stored composition selection.\n\n    latestCompositionSelection = null; // By relying on the state of the input command we allow disabling the entire input easily\n    // by just disabling the input command. We could’ve used here the delete command but that\n    // would mean requiring the delete feature which would block loading one without the other.\n    // We could also check the editor.isReadOnly property, but that wouldn't allow to block\n    // the input without blocking other features.\n\n    if (!inputCommand.isEnabled) {\n      return;\n    }\n\n    if (isNonTypingKeystroke(evtData) || doc.selection.isCollapsed) {\n      return;\n    } // If during composition, deletion should be prevented as it may remove composed sequence (#83).\n\n\n    if (isComposing && evtData.keyCode === 229) {\n      return;\n    } // If there is a `keydown` event fired with '229' keycode it might be related\n    // to recent composition. Check if selection is the same as upon ending recent composition,\n    // if so do not remove selected content as it will remove composed sequence (#83).\n\n\n    if (!isComposing && evtData.keyCode === 229 && isSelectionUnchanged) {\n      return;\n    }\n\n    deleteSelectionContent();\n  } // Handles the `compositionstart` event. It is used only in special cases to remove the contents\n  // of a non-collapsed selection so composition itself does not result in complex mutations.\n  //\n  // The special case mentioned above is a situation in which the `keydown` event is fired after\n  // `compositionstart` event. In such cases {@link #handleKeydown} cannot clear current selection\n  // contents (because it is too late and will break the composition) so the composition handler takes care of it.\n\n\n  function handleCompositionStart() {\n    const doc = model.document;\n    const isFlatSelection = doc.selection.rangeCount === 1 ? doc.selection.getFirstRange().isFlat : true; // If on `compositionstart` there is a non-collapsed selection which start and end have different parents\n    // it means the `handleKeydown()` method did not remove its contents. It happens usually because\n    // of different order of events (`compositionstart` before `keydown` - in Safari). In such cases\n    // we need to remove selection contents on composition start (#83).\n\n    if (doc.selection.isCollapsed || isFlatSelection) {\n      return;\n    }\n\n    deleteSelectionContent();\n  }\n\n  function deleteSelectionContent() {\n    const buffer = inputCommand.buffer;\n    buffer.lock();\n    const batch = buffer.batch;\n\n    inputCommand._batches.add(batch);\n\n    model.enqueueChange(batch, () => {\n      model.deleteContent(model.document.selection);\n    });\n    buffer.unlock();\n  }\n}\nconst safeKeycodes = [getCode('arrowUp'), getCode('arrowRight'), getCode('arrowDown'), getCode('arrowLeft'), 9, // Tab\n16, // Shift\n17, // Ctrl\n18, // Alt\n19, // Pause\n20, // CapsLock\n27, // Escape\n33, // PageUp\n34, // PageDown\n35, // Home\n36, // End,\n45, // Insert,\n91, // Windows,\n93, // Menu key,\n144, // NumLock\n145, // ScrollLock,\n173, // Mute/Unmute\n174, // Volume up\n175, // Volume down,\n176, // Next song,\n177, // Previous song,\n178, // Stop,\n179, // Play/Pause,\n255 // Display brightness (increase and decrease)\n]; // Function keys.\n\nfor (let code = 112; code <= 135; code++) {\n  safeKeycodes.push(code);\n}\n/**\n * Returns `true` if a keystroke will **not** result in \"typing\".\n *\n * For instance, keystrokes that result in typing are letters \"a-zA-Z\", numbers \"0-9\", delete, backspace, etc.\n *\n * Keystrokes that do not cause typing are, for instance, Fn keys (F5, F8, etc.), arrow keys (←, →, ↑, ↓),\n * Tab (↹), \"Windows logo key\" (⊞ Win), etc.\n *\n * Note: This implementation is very simple and will need to be refined with time.\n *\n * @param {module:engine/view/observer/keyobserver~KeyEventData} keyData\n * @returns {Boolean}\n */\n\n\nexport function isNonTypingKeystroke(keyData) {\n  // Keystrokes which contain Ctrl or Cmd don't represent typing.\n  if (keyData.ctrlKey || keyData.metaKey) {\n    return true;\n  }\n\n  return safeKeycodes.includes(keyData.keyCode);\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling.js"],"names":["getCode","env","isShiftDeleteOnNonCollapsedSelection","injectUnsafeKeystrokesHandling","editor","latestCompositionSelection","model","view","editing","inputCommand","commands","get","isAndroid","document","on","evt","evtData","handleUnsafeKeystroke","priority","handleCompositionStart","createSelection","selection","isWindows","doc","isComposing","isSelectionUnchanged","isEqual","isEnabled","isNonTypingKeystroke","isCollapsed","keyCode","deleteSelectionContent","isFlatSelection","rangeCount","getFirstRange","isFlat","buffer","lock","batch","_batches","add","enqueueChange","deleteContent","unlock","safeKeycodes","code","push","keyData","ctrlKey","metaKey","includes"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injectunsafekeystrokeshandling\n */\n\nimport { getCode } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { isShiftDeleteOnNonCollapsedSelection } from './utils';\n\n/**\n * Handles keystrokes which are unsafe for typing. This handler's logic is explained\n * in https://github.com/ckeditor/ckeditor5-typing/issues/83#issuecomment-398690251.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\nexport default function injectUnsafeKeystrokesHandling( editor ) {\n\tlet latestCompositionSelection = null;\n\n\tconst model = editor.model;\n\tconst view = editor.editing.view;\n\tconst inputCommand = editor.commands.get( 'input' );\n\n\t// For Android, we want to handle keystrokes on `beforeinput` to be sure that code in `DeleteObserver` already had a chance to be fired.\n\tif ( env.isAndroid ) {\n\t\tview.document.on( 'beforeinput', ( evt, evtData ) => handleUnsafeKeystroke( evtData ), { priority: 'lowest' } );\n\t} else {\n\t\tview.document.on( 'keydown', ( evt, evtData ) => handleUnsafeKeystroke( evtData ), { priority: 'lowest' } );\n\t}\n\n\tview.document.on( 'compositionstart', handleCompositionStart, { priority: 'lowest' } );\n\n\tview.document.on( 'compositionend', () => {\n\t\tlatestCompositionSelection = model.createSelection( model.document.selection );\n\t}, { priority: 'lowest' } );\n\n\t// Handles the keydown event. We need to guess whether such keystroke is going to result\n\t// in typing. If so, then before character insertion happens, any selected content needs\n\t// to be deleted. Otherwise the default browser deletion mechanism would be\n\t// triggered, resulting in:\n\t//\n\t// * Hundreds of mutations which could not be handled.\n\t// * But most importantly, loss of control over how the content is being deleted.\n\t//\n\t// The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)\n\t// to handle the event.\n\t//\n\t// @param {module:engine/view/observer/keyobserver~KeyEventData} evtData\n\tfunction handleUnsafeKeystroke( evtData ) {\n\t\t// Do not delete the content, if Shift + Delete key combination was pressed on a non-collapsed selection on Windows.\n\t\t//\n\t\t// The Shift + Delete key combination should work in the same way as the `cut` event on a non-collapsed selection on Windows.\n\t\t// In fact, the native `cut` event is actually emitted in this case, but with lower priority. Therefore, in order to handle the\n\t\t// Shift + Delete key combination correctly, it is enough to prevent the content deletion here.\n\t\tif ( env.isWindows && isShiftDeleteOnNonCollapsedSelection( evtData, view.document ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst doc = model.document;\n\t\tconst isComposing = view.document.isComposing;\n\t\tconst isSelectionUnchanged = latestCompositionSelection && latestCompositionSelection.isEqual( doc.selection );\n\n\t\t// Reset stored composition selection.\n\t\tlatestCompositionSelection = null;\n\n\t\t// By relying on the state of the input command we allow disabling the entire input easily\n\t\t// by just disabling the input command. We could’ve used here the delete command but that\n\t\t// would mean requiring the delete feature which would block loading one without the other.\n\t\t// We could also check the editor.isReadOnly property, but that wouldn't allow to block\n\t\t// the input without blocking other features.\n\t\tif ( !inputCommand.isEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( isNonTypingKeystroke( evtData ) || doc.selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If during composition, deletion should be prevented as it may remove composed sequence (#83).\n\t\tif ( isComposing && evtData.keyCode === 229 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there is a `keydown` event fired with '229' keycode it might be related\n\t\t// to recent composition. Check if selection is the same as upon ending recent composition,\n\t\t// if so do not remove selected content as it will remove composed sequence (#83).\n\t\tif ( !isComposing && evtData.keyCode === 229 && isSelectionUnchanged ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeleteSelectionContent();\n\t}\n\n\t// Handles the `compositionstart` event. It is used only in special cases to remove the contents\n\t// of a non-collapsed selection so composition itself does not result in complex mutations.\n\t//\n\t// The special case mentioned above is a situation in which the `keydown` event is fired after\n\t// `compositionstart` event. In such cases {@link #handleKeydown} cannot clear current selection\n\t// contents (because it is too late and will break the composition) so the composition handler takes care of it.\n\tfunction handleCompositionStart() {\n\t\tconst doc = model.document;\n\t\tconst isFlatSelection = doc.selection.rangeCount === 1 ? doc.selection.getFirstRange().isFlat : true;\n\n\t\t// If on `compositionstart` there is a non-collapsed selection which start and end have different parents\n\t\t// it means the `handleKeydown()` method did not remove its contents. It happens usually because\n\t\t// of different order of events (`compositionstart` before `keydown` - in Safari). In such cases\n\t\t// we need to remove selection contents on composition start (#83).\n\t\tif ( doc.selection.isCollapsed || isFlatSelection ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeleteSelectionContent();\n\t}\n\n\tfunction deleteSelectionContent() {\n\t\tconst buffer = inputCommand.buffer;\n\n\t\tbuffer.lock();\n\n\t\tconst batch = buffer.batch;\n\t\tinputCommand._batches.add( batch );\n\n\t\tmodel.enqueueChange( batch, () => {\n\t\t\tmodel.deleteContent( model.document.selection );\n\t\t} );\n\n\t\tbuffer.unlock();\n\t}\n}\n\nconst safeKeycodes = [\n\tgetCode( 'arrowUp' ),\n\tgetCode( 'arrowRight' ),\n\tgetCode( 'arrowDown' ),\n\tgetCode( 'arrowLeft' ),\n\t9, // Tab\n\t16, // Shift\n\t17, // Ctrl\n\t18, // Alt\n\t19, // Pause\n\t20, // CapsLock\n\t27, // Escape\n\t33, // PageUp\n\t34, // PageDown\n\t35, // Home\n\t36, // End,\n\t45, // Insert,\n\t91, // Windows,\n\t93, // Menu key,\n\t144, // NumLock\n\t145, // ScrollLock,\n\t173, // Mute/Unmute\n\t174, // Volume up\n\t175, // Volume down,\n\t176, // Next song,\n\t177, // Previous song,\n\t178, // Stop,\n\t179, // Play/Pause,\n\t255 // Display brightness (increase and decrease)\n];\n\n// Function keys.\nfor ( let code = 112; code <= 135; code++ ) {\n\tsafeKeycodes.push( code );\n}\n\n/**\n * Returns `true` if a keystroke will **not** result in \"typing\".\n *\n * For instance, keystrokes that result in typing are letters \"a-zA-Z\", numbers \"0-9\", delete, backspace, etc.\n *\n * Keystrokes that do not cause typing are, for instance, Fn keys (F5, F8, etc.), arrow keys (←, →, ↑, ↓),\n * Tab (↹), \"Windows logo key\" (⊞ Win), etc.\n *\n * Note: This implementation is very simple and will need to be refined with time.\n *\n * @param {module:engine/view/observer/keyobserver~KeyEventData} keyData\n * @returns {Boolean}\n */\nexport function isNonTypingKeystroke( keyData ) {\n\t// Keystrokes which contain Ctrl or Cmd don't represent typing.\n\tif ( keyData.ctrlKey || keyData.metaKey ) {\n\t\treturn true;\n\t}\n\n\treturn safeKeycodes.includes( keyData.keyCode );\n}\n"]},"metadata":{},"sourceType":"module"}