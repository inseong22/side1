{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/filters/image\n */\n\n/* globals btoa */\nimport { Matcher, UpcastWriter } from 'ckeditor5/src/engine';\n/**\n * Replaces source attribute of all `<img>` elements representing regular\n * images (not the Word shapes) with inlined base64 image representation extracted from RTF or Blob data.\n *\n * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment on which transform images.\n * @param {String} rtfData The RTF data from which images representation will be used.\n */\n\nexport function replaceImagesSourceWithBase64(documentFragment, rtfData) {\n  if (!documentFragment.childCount) {\n    return;\n  }\n\n  const upcastWriter = new UpcastWriter();\n  const shapesIds = findAllShapesIds(documentFragment, upcastWriter);\n  removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);\n  removeAllShapeElements(documentFragment, upcastWriter);\n  const images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);\n\n  if (images.length) {\n    replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);\n  }\n}\n/**\n * Converts given HEX string to base64 representation.\n *\n * @protected\n * @param {String} hexString The HEX string to be converted.\n * @returns {String} Base64 representation of a given HEX string.\n */\n\nexport function _convertHexToBase64(hexString) {\n  return btoa(hexString.match(/\\w{2}/g).map(char => {\n    return String.fromCharCode(parseInt(char, 16));\n  }).join(''));\n} // Finds all shapes (`<v:*>...</v:*>`) ids. Shapes can represent images (canvas)\n// or Word shapes (which does not have RTF or Blob representation).\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment\n// from which to extract shape ids.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Array.<String>} Array of shape ids.\n\nfunction findAllShapesIds(documentFragment, writer) {\n  const range = writer.createRangeIn(documentFragment);\n  const shapeElementsMatcher = new Matcher({\n    name: /v:(.+)/\n  });\n  const shapesIds = [];\n\n  for (const value of range) {\n    if (value.type != 'elementStart') {\n      continue;\n    }\n\n    const el = value.item;\n    const prevSiblingName = el.previousSibling && el.previousSibling.name || null; // If shape element have 'o:gfxdata' attribute and is not directly before `<v:shapetype>` element it means it represent Word shape.\n\n    if (shapeElementsMatcher.match(el) && el.getAttribute('o:gfxdata') && prevSiblingName !== 'v:shapetype') {\n      shapesIds.push(value.item.getAttribute('id'));\n    }\n  }\n\n  return shapesIds;\n} // Removes all `<img>` elements which represents Word shapes and not regular images.\n//\n// @param {Array.<String>} shapesIds Shape ids which will be checked against `<img>` elements.\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment from which to remove `<img>` elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n\n\nfunction removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {\n  const range = writer.createRangeIn(documentFragment);\n  const imageElementsMatcher = new Matcher({\n    name: 'img'\n  });\n  const imgs = [];\n\n  for (const value of range) {\n    if (imageElementsMatcher.match(value.item)) {\n      const el = value.item;\n      const shapes = el.getAttribute('v:shapes') ? el.getAttribute('v:shapes').split(' ') : [];\n\n      if (shapes.length && shapes.every(shape => shapesIds.indexOf(shape) > -1)) {\n        imgs.push(el); // Shapes may also have empty source while content is paste in some browsers (Safari).\n      } else if (!el.getAttribute('src')) {\n        imgs.push(el);\n      }\n    }\n  }\n\n  for (const img of imgs) {\n    writer.remove(img);\n  }\n} // Removes all shape elements (`<v:*>...</v:*>`) so they do not pollute the output structure.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment from which to remove shape elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n\n\nfunction removeAllShapeElements(documentFragment, writer) {\n  const range = writer.createRangeIn(documentFragment);\n  const shapeElementsMatcher = new Matcher({\n    name: /v:(.+)/\n  });\n  const shapes = [];\n\n  for (const value of range) {\n    if (value.type == 'elementStart' && shapeElementsMatcher.match(value.item)) {\n      shapes.push(value.item);\n    }\n  }\n\n  for (const shape of shapes) {\n    writer.remove(shape);\n  }\n} // Finds all `<img>` elements in a given document fragment which have source pointing to local `file://` resource.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment in which to look for `<img>` elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Object} result All found images grouped by source type.\n// @returns {Array.<module:engine/view/element~Element>} result.file Array of found `<img>` elements with `file://` source.\n// @returns {Array.<module:engine/view/element~Element>} result.blob Array of found `<img>` elements with `blob:` source.\n\n\nfunction findAllImageElementsWithLocalSource(documentFragment, writer) {\n  const range = writer.createRangeIn(documentFragment);\n  const imageElementsMatcher = new Matcher({\n    name: 'img'\n  });\n  const imgs = [];\n\n  for (const value of range) {\n    if (imageElementsMatcher.match(value.item)) {\n      if (value.item.getAttribute('src').startsWith('file://')) {\n        imgs.push(value.item);\n      }\n    }\n  }\n\n  return imgs;\n} // Extracts all images HEX representations from a given RTF data.\n//\n// @param {String} rtfData The RTF data from which to extract images HEX representation.\n// @returns {Array.<Object>} Array of found HEX representations. Each array item is an object containing:\n//\n// \t\t* {String} hex Image representation in HEX format.\n// \t\t* {string} type Type of image, `image/png` or `image/jpeg`.\n\n\nfunction extractImageDataFromRtf(rtfData) {\n  if (!rtfData) {\n    return [];\n  }\n\n  const regexPictureHeader = /{\\\\pict[\\s\\S]+?\\\\bliptag-?\\d+(\\\\blipupi-?\\d+)?({\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)?[\\s}]*?/;\n  const regexPicture = new RegExp('(?:(' + regexPictureHeader.source + '))([\\\\da-fA-F\\\\s]+)\\\\}', 'g');\n  const images = rtfData.match(regexPicture);\n  const result = [];\n\n  if (images) {\n    for (const image of images) {\n      let imageType = false;\n\n      if (image.includes('\\\\pngblip')) {\n        imageType = 'image/png';\n      } else if (image.includes('\\\\jpegblip')) {\n        imageType = 'image/jpeg';\n      }\n\n      if (imageType) {\n        result.push({\n          hex: image.replace(regexPictureHeader, '').replace(/[^\\da-fA-F]/g, ''),\n          type: imageType\n        });\n      }\n    }\n  }\n\n  return result;\n} // Replaces `src` attribute value of all given images with the corresponding base64 image representation.\n//\n// @param {Array.<module:engine/view/element~Element>} imageElements Array of image elements which will have its source replaced.\n// @param {Array.<Object>} imagesHexSources Array of images hex sources (usually the result of `extractImageDataFromRtf()` function).\n// The array should be the same length as `imageElements` parameter.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n\n\nfunction replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {\n  // Assume there is an equal amount of image elements and images HEX sources so they can be matched accordingly based on existing order.\n  if (imageElements.length === imagesHexSources.length) {\n    for (let i = 0; i < imageElements.length; i++) {\n      const newSrc = `data:${imagesHexSources[i].type};base64,${_convertHexToBase64(imagesHexSources[i].hex)}`;\n      writer.setAttribute('src', newSrc, imageElements[i]);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/image.js"],"names":["Matcher","UpcastWriter","replaceImagesSourceWithBase64","documentFragment","rtfData","childCount","upcastWriter","shapesIds","findAllShapesIds","removeAllImgElementsRepresentingShapes","removeAllShapeElements","images","findAllImageElementsWithLocalSource","length","replaceImagesFileSourceWithInlineRepresentation","extractImageDataFromRtf","_convertHexToBase64","hexString","btoa","match","map","char","String","fromCharCode","parseInt","join","writer","range","createRangeIn","shapeElementsMatcher","name","value","type","el","item","prevSiblingName","previousSibling","getAttribute","push","imageElementsMatcher","imgs","shapes","split","every","shape","indexOf","img","remove","startsWith","regexPictureHeader","regexPicture","RegExp","source","result","image","imageType","includes","hex","replace","imageElements","imagesHexSources","i","newSrc","setAttribute"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/filters/image\n */\n\n/* globals btoa */\n\nimport { Matcher, UpcastWriter } from 'ckeditor5/src/engine';\n\n/**\n * Replaces source attribute of all `<img>` elements representing regular\n * images (not the Word shapes) with inlined base64 image representation extracted from RTF or Blob data.\n *\n * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment on which transform images.\n * @param {String} rtfData The RTF data from which images representation will be used.\n */\nexport function replaceImagesSourceWithBase64( documentFragment, rtfData ) {\n\tif ( !documentFragment.childCount ) {\n\t\treturn;\n\t}\n\n\tconst upcastWriter = new UpcastWriter();\n\tconst shapesIds = findAllShapesIds( documentFragment, upcastWriter );\n\n\tremoveAllImgElementsRepresentingShapes( shapesIds, documentFragment, upcastWriter );\n\tremoveAllShapeElements( documentFragment, upcastWriter );\n\n\tconst images = findAllImageElementsWithLocalSource( documentFragment, upcastWriter );\n\n\tif ( images.length ) {\n\t\treplaceImagesFileSourceWithInlineRepresentation( images, extractImageDataFromRtf( rtfData ), upcastWriter );\n\t}\n}\n\n/**\n * Converts given HEX string to base64 representation.\n *\n * @protected\n * @param {String} hexString The HEX string to be converted.\n * @returns {String} Base64 representation of a given HEX string.\n */\nexport function _convertHexToBase64( hexString ) {\n\treturn btoa( hexString.match( /\\w{2}/g ).map( char => {\n\t\treturn String.fromCharCode( parseInt( char, 16 ) );\n\t} ).join( '' ) );\n}\n\n// Finds all shapes (`<v:*>...</v:*>`) ids. Shapes can represent images (canvas)\n// or Word shapes (which does not have RTF or Blob representation).\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment\n// from which to extract shape ids.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Array.<String>} Array of shape ids.\nfunction findAllShapesIds( documentFragment, writer ) {\n\tconst range = writer.createRangeIn( documentFragment );\n\n\tconst shapeElementsMatcher = new Matcher( {\n\t\tname: /v:(.+)/\n\t} );\n\n\tconst shapesIds = [];\n\n\tfor ( const value of range ) {\n\t\tif ( value.type != 'elementStart' ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst el = value.item;\n\t\tconst prevSiblingName = el.previousSibling && el.previousSibling.name || null;\n\n\t\t// If shape element have 'o:gfxdata' attribute and is not directly before `<v:shapetype>` element it means it represent Word shape.\n\t\tif ( shapeElementsMatcher.match( el ) && el.getAttribute( 'o:gfxdata' ) && prevSiblingName !== 'v:shapetype' ) {\n\t\t\tshapesIds.push( value.item.getAttribute( 'id' ) );\n\t\t}\n\t}\n\n\treturn shapesIds;\n}\n\n// Removes all `<img>` elements which represents Word shapes and not regular images.\n//\n// @param {Array.<String>} shapesIds Shape ids which will be checked against `<img>` elements.\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment from which to remove `<img>` elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\nfunction removeAllImgElementsRepresentingShapes( shapesIds, documentFragment, writer ) {\n\tconst range = writer.createRangeIn( documentFragment );\n\n\tconst imageElementsMatcher = new Matcher( {\n\t\tname: 'img'\n\t} );\n\n\tconst imgs = [];\n\n\tfor ( const value of range ) {\n\t\tif ( imageElementsMatcher.match( value.item ) ) {\n\t\t\tconst el = value.item;\n\t\t\tconst shapes = el.getAttribute( 'v:shapes' ) ? el.getAttribute( 'v:shapes' ).split( ' ' ) : [];\n\n\t\t\tif ( shapes.length && shapes.every( shape => shapesIds.indexOf( shape ) > -1 ) ) {\n\t\t\t\timgs.push( el );\n\t\t\t// Shapes may also have empty source while content is paste in some browsers (Safari).\n\t\t\t} else if ( !el.getAttribute( 'src' ) ) {\n\t\t\t\timgs.push( el );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( const img of imgs ) {\n\t\twriter.remove( img );\n\t}\n}\n\n// Removes all shape elements (`<v:*>...</v:*>`) so they do not pollute the output structure.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment from which to remove shape elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\nfunction removeAllShapeElements( documentFragment, writer ) {\n\tconst range = writer.createRangeIn( documentFragment );\n\n\tconst shapeElementsMatcher = new Matcher( {\n\t\tname: /v:(.+)/\n\t} );\n\n\tconst shapes = [];\n\n\tfor ( const value of range ) {\n\t\tif ( value.type == 'elementStart' && shapeElementsMatcher.match( value.item ) ) {\n\t\t\tshapes.push( value.item );\n\t\t}\n\t}\n\n\tfor ( const shape of shapes ) {\n\t\twriter.remove( shape );\n\t}\n}\n\n// Finds all `<img>` elements in a given document fragment which have source pointing to local `file://` resource.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment in which to look for `<img>` elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Object} result All found images grouped by source type.\n// @returns {Array.<module:engine/view/element~Element>} result.file Array of found `<img>` elements with `file://` source.\n// @returns {Array.<module:engine/view/element~Element>} result.blob Array of found `<img>` elements with `blob:` source.\nfunction findAllImageElementsWithLocalSource( documentFragment, writer ) {\n\tconst range = writer.createRangeIn( documentFragment );\n\n\tconst imageElementsMatcher = new Matcher( {\n\t\tname: 'img'\n\t} );\n\n\tconst imgs = [];\n\n\tfor ( const value of range ) {\n\t\tif ( imageElementsMatcher.match( value.item ) ) {\n\t\t\tif ( value.item.getAttribute( 'src' ).startsWith( 'file://' ) ) {\n\t\t\t\timgs.push( value.item );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn imgs;\n}\n\n// Extracts all images HEX representations from a given RTF data.\n//\n// @param {String} rtfData The RTF data from which to extract images HEX representation.\n// @returns {Array.<Object>} Array of found HEX representations. Each array item is an object containing:\n//\n// \t\t* {String} hex Image representation in HEX format.\n// \t\t* {string} type Type of image, `image/png` or `image/jpeg`.\nfunction extractImageDataFromRtf( rtfData ) {\n\tif ( !rtfData ) {\n\t\treturn [];\n\t}\n\n\tconst regexPictureHeader = /{\\\\pict[\\s\\S]+?\\\\bliptag-?\\d+(\\\\blipupi-?\\d+)?({\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)?[\\s}]*?/;\n\tconst regexPicture = new RegExp( '(?:(' + regexPictureHeader.source + '))([\\\\da-fA-F\\\\s]+)\\\\}', 'g' );\n\tconst images = rtfData.match( regexPicture );\n\tconst result = [];\n\n\tif ( images ) {\n\t\tfor ( const image of images ) {\n\t\t\tlet imageType = false;\n\n\t\t\tif ( image.includes( '\\\\pngblip' ) ) {\n\t\t\t\timageType = 'image/png';\n\t\t\t} else if ( image.includes( '\\\\jpegblip' ) ) {\n\t\t\t\timageType = 'image/jpeg';\n\t\t\t}\n\n\t\t\tif ( imageType ) {\n\t\t\t\tresult.push( {\n\t\t\t\t\thex: image.replace( regexPictureHeader, '' ).replace( /[^\\da-fA-F]/g, '' ),\n\t\t\t\t\ttype: imageType\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// Replaces `src` attribute value of all given images with the corresponding base64 image representation.\n//\n// @param {Array.<module:engine/view/element~Element>} imageElements Array of image elements which will have its source replaced.\n// @param {Array.<Object>} imagesHexSources Array of images hex sources (usually the result of `extractImageDataFromRtf()` function).\n// The array should be the same length as `imageElements` parameter.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\nfunction replaceImagesFileSourceWithInlineRepresentation( imageElements, imagesHexSources, writer ) {\n\t// Assume there is an equal amount of image elements and images HEX sources so they can be matched accordingly based on existing order.\n\tif ( imageElements.length === imagesHexSources.length ) {\n\t\tfor ( let i = 0; i < imageElements.length; i++ ) {\n\t\t\tconst newSrc = `data:${ imagesHexSources[ i ].type };base64,${ _convertHexToBase64( imagesHexSources[ i ].hex ) }`;\n\t\t\twriter.setAttribute( 'src', newSrc, imageElements[ i ] );\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}