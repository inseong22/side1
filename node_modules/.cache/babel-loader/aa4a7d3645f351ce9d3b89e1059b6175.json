{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/utils\n */\nimport { TreeWalker, getFillerOffset } from 'ckeditor5/src/engine';\nimport { ButtonView } from 'ckeditor5/src/ui';\n/**\n * Creates a list item {@link module:engine/view/containerelement~ContainerElement}.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer The writer instance.\n * @returns {module:engine/view/containerelement~ContainerElement}\n */\n\nexport function createViewListItemElement(writer) {\n  const viewItem = writer.createContainerElement('li');\n  viewItem.getFillerOffset = getListItemFillerOffset;\n  return viewItem;\n}\n/**\n * Helper function that creates a `<ul><li></li></ul>` or (`<ol>`) structure out of the given `modelItem` model `listItem` element.\n * Then, it binds the created view list item (`<li>`) with the model `listItem` element.\n * The function then returns the created view list item (`<li>`).\n *\n * @param {module:engine/model/item~Item} modelItem Model list item.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface.\n * @returns {module:engine/view/containerelement~ContainerElement} View list element.\n */\n\nexport function generateLiInUl(modelItem, conversionApi) {\n  const mapper = conversionApi.mapper;\n  const viewWriter = conversionApi.writer;\n  const listType = modelItem.getAttribute('listType') == 'numbered' ? 'ol' : 'ul';\n  const viewItem = createViewListItemElement(viewWriter);\n  const viewList = viewWriter.createContainerElement(listType, null);\n  viewWriter.insert(viewWriter.createPositionAt(viewList, 0), viewItem);\n  mapper.bindElements(modelItem, viewItem);\n  return viewItem;\n}\n/**\n * Helper function that inserts a view list at a correct place and merges it with its siblings.\n * It takes a model list item element (`modelItem`) and a corresponding view list item element (`injectedItem`). The view list item\n * should be in a view list element (`<ul>` or `<ol>`) and should be its only child.\n * See comments below to better understand the algorithm.\n *\n * @param {module:engine/view/item~Item} modelItem Model list item.\n * @param {module:engine/view/containerelement~ContainerElement} injectedItem\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface.\n * @param {module:engine/model/model~Model} model The model instance.\n */\n\nexport function injectViewList(modelItem, injectedItem, conversionApi, model) {\n  const injectedList = injectedItem.parent;\n  const mapper = conversionApi.mapper;\n  const viewWriter = conversionApi.writer; // The position where the view list will be inserted.\n\n  let insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem)); // 1. Find the previous list item that has the same or smaller indent. Basically we are looking for the first model item\n  // that is a \"parent\" or \"sibling\" of the injected model item.\n  // If there is no such list item, it means that the injected list item is the first item in \"its list\".\n\n  const refItem = getSiblingListItem(modelItem.previousSibling, {\n    sameIndent: true,\n    smallerIndent: true,\n    listIndent: modelItem.getAttribute('listIndent')\n  });\n  const prevItem = modelItem.previousSibling;\n\n  if (refItem && refItem.getAttribute('listIndent') == modelItem.getAttribute('listIndent')) {\n    // There is a list item with the same indent - we found the same-level sibling.\n    // Break the list after it. The inserted view item will be added in the broken space.\n    const viewItem = mapper.toViewElement(refItem);\n    insertPosition = viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));\n  } else {\n    // There is no list item with the same indent. Check the previous model item.\n    if (prevItem && prevItem.name == 'listItem') {\n      // If it is a list item, it has to have a lower indent.\n      // It means that the inserted item should be added to it as its nested item.\n      insertPosition = mapper.toViewPosition(model.createPositionAt(prevItem, 'end')); // There could be some not mapped elements (eg. span in to-do list) but we need to insert\n      // a nested list directly inside the li element.\n\n      const mappedViewAncestor = mapper.findMappedViewAncestor(insertPosition);\n      const nestedList = findNestedList(mappedViewAncestor); // If there already is some nested list, then use it's position.\n\n      if (nestedList) {\n        insertPosition = viewWriter.createPositionBefore(nestedList);\n      } else {\n        // Else just put new list on the end of list item content.\n        insertPosition = viewWriter.createPositionAt(mappedViewAncestor, 'end');\n      }\n    } else {\n      // The previous item is not a list item (or does not exist at all).\n      // Just map the position and insert the view item at the mapped position.\n      insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));\n    }\n  }\n\n  insertPosition = positionAfterUiElements(insertPosition); // Insert the view item.\n\n  viewWriter.insert(insertPosition, injectedList); // 2. Handle possible children of the injected model item.\n\n  if (prevItem && prevItem.name == 'listItem') {\n    const prevView = mapper.toViewElement(prevItem);\n    const walkerBoundaries = viewWriter.createRange(viewWriter.createPositionAt(prevView, 0), insertPosition);\n    const walker = walkerBoundaries.getWalker({\n      ignoreElementEnd: true\n    });\n\n    for (const value of walker) {\n      if (value.item.is('element', 'li')) {\n        const breakPosition = viewWriter.breakContainer(viewWriter.createPositionBefore(value.item));\n        const viewList = value.item.parent;\n        const targetPosition = viewWriter.createPositionAt(injectedItem, 'end');\n        mergeViewLists(viewWriter, targetPosition.nodeBefore, targetPosition.nodeAfter);\n        viewWriter.move(viewWriter.createRangeOn(viewList), targetPosition);\n        walker.position = breakPosition;\n      }\n    }\n  } else {\n    const nextViewList = injectedList.nextSibling;\n\n    if (nextViewList && (nextViewList.is('element', 'ul') || nextViewList.is('element', 'ol'))) {\n      let lastSubChild = null;\n\n      for (const child of nextViewList.getChildren()) {\n        const modelChild = mapper.toModelElement(child);\n\n        if (modelChild && modelChild.getAttribute('listIndent') > modelItem.getAttribute('listIndent')) {\n          lastSubChild = child;\n        } else {\n          break;\n        }\n      }\n\n      if (lastSubChild) {\n        viewWriter.breakContainer(viewWriter.createPositionAfter(lastSubChild));\n        viewWriter.move(viewWriter.createRangeOn(lastSubChild.parent), viewWriter.createPositionAt(injectedItem, 'end'));\n      }\n    }\n  } // Merge the inserted view list with its possible neighbor lists.\n\n\n  mergeViewLists(viewWriter, injectedList, injectedList.nextSibling);\n  mergeViewLists(viewWriter, injectedList.previousSibling, injectedList);\n}\n/**\n * Helper function that takes two parameters that are expected to be view list elements, and merges them.\n * The merge happens only if both parameters are list elements of the same type (the same element name and the same class attributes).\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter The writer instance.\n * @param {module:engine/view/item~Item} firstList The first element to compare.\n * @param {module:engine/view/item~Item} secondList The second element to compare.\n * @returns {module:engine/view/position~Position|null} The position after merge or `null` when there was no merge.\n */\n\nexport function mergeViewLists(viewWriter, firstList, secondList) {\n  // Check if two lists are going to be merged.\n  if (!firstList || !secondList || firstList.name != 'ul' && firstList.name != 'ol') {\n    return null;\n  } // Both parameters are list elements, so compare types now.\n\n\n  if (firstList.name != secondList.name || firstList.getAttribute('class') !== secondList.getAttribute('class')) {\n    return null;\n  }\n\n  return viewWriter.mergeContainers(viewWriter.createPositionAfter(firstList));\n}\n/**\n * Helper function that for a given `view.Position`, returns a `view.Position` that is after all `view.UIElement`s that\n * are after the given position.\n *\n * For example:\n * `<container:p>foo^<ui:span></ui:span><ui:span></ui:span>bar</container:p>`\n * For position ^, the position before \"bar\" will be returned.\n *\n * @param {module:engine/view/position~Position} viewPosition\n * @returns {module:engine/view/position~Position}\n */\n\nexport function positionAfterUiElements(viewPosition) {\n  return viewPosition.getLastMatchingPosition(value => value.item.is('uiElement'));\n}\n/**\n * Helper function that searches for a previous list item sibling of a given model item that meets the given criteria\n * passed by the options object.\n *\n * @param {module:engine/model/item~Item} modelItem\n * @param {Object} options Search criteria.\n * @param {Boolean} [options.sameIndent=false] Whether the sought sibling should have the same indentation.\n * @param {Boolean} [options.smallerIndent=false] Whether the sought sibling should have a smaller indentation.\n * @param {Number} [options.listIndent] The reference indentation.\n * @param {'forward'|'backward'} [options.direction='backward'] Walking direction.\n * @returns {module:engine/model/item~Item|null}\n */\n\nexport function getSiblingListItem(modelItem, options) {\n  const sameIndent = !!options.sameIndent;\n  const smallerIndent = !!options.smallerIndent;\n  const indent = options.listIndent;\n  let item = modelItem;\n\n  while (item && item.name == 'listItem') {\n    const itemIndent = item.getAttribute('listIndent');\n\n    if (sameIndent && indent == itemIndent || smallerIndent && indent > itemIndent) {\n      return item;\n    }\n\n    if (options.direction === 'forward') {\n      item = item.nextSibling;\n    } else {\n      item = item.previousSibling;\n    }\n  }\n\n  return null;\n}\n/**\n * Helper method for creating a UI button and linking it with an appropriate command.\n *\n * @private\n * @param {module:core/editor/editor~Editor} editor The editor instance to which the UI component will be added.\n * @param {String} commandName The name of the command.\n * @param {String} label The button label.\n * @param {String} icon The source of the icon.\n */\n\nexport function createUIComponent(editor, commandName, label, icon) {\n  editor.ui.componentFactory.add(commandName, locale => {\n    const command = editor.commands.get(commandName);\n    const buttonView = new ButtonView(locale);\n    buttonView.set({\n      label,\n      icon,\n      tooltip: true,\n      isToggleable: true\n    }); // Bind button model to command.\n\n    buttonView.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled'); // Execute command.\n\n    buttonView.on('execute', () => {\n      editor.execute(commandName);\n      editor.editing.view.focus();\n    });\n    return buttonView;\n  });\n}\n/**\n * Returns a first list view element that is direct child of the given view element.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @return {module:engine/view/element~Element|null}\n */\n\nexport function findNestedList(viewElement) {\n  for (const node of viewElement.getChildren()) {\n    if (node.name == 'ul' || node.name == 'ol') {\n      return node;\n    }\n  }\n\n  return null;\n}\n/**\n * Returns an array with all `listItem` elements that represents the same list.\n *\n * It means that values for `listIndent`, `listType`, and `listStyle` for all items are equal.\n *\n * @param {module:engine/model/position~Position} position Starting position.\n * @param {'forward'|'backward'} direction Walking direction.\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\nexport function getSiblingNodes(position, direction) {\n  const items = [];\n  const listItem = position.parent;\n  const walkerOptions = {\n    ignoreElementEnd: true,\n    startPosition: position,\n    shallow: true,\n    direction\n  };\n  const limitIndent = listItem.getAttribute('listIndent');\n  const nodes = [...new TreeWalker(walkerOptions)].filter(value => value.item.is('element')).map(value => value.item);\n\n  for (const element of nodes) {\n    // If found something else than `listItem`, we're out of the list scope.\n    if (!element.is('element', 'listItem')) {\n      break;\n    } // If current parsed item has lower indent that element that the element that was a starting point,\n    // it means we left a nested list. Abort searching items.\n    //\n    // ■ List item 1.       [listIndent=0]\n    //     ○ List item 2.[] [listIndent=1], limitIndent = 1,\n    //     ○ List item 3.   [listIndent=1]\n    // ■ List item 4.       [listIndent=0]\n    //\n    // Abort searching when leave nested list.\n\n\n    if (element.getAttribute('listIndent') < limitIndent) {\n      break;\n    } // ■ List item 1.[]     [listIndent=0] limitIndent = 0,\n    //     ○ List item 2.   [listIndent=1]\n    //     ○ List item 3.   [listIndent=1]\n    // ■ List item 4.       [listIndent=0]\n    //\n    // Ignore nested lists.\n\n\n    if (element.getAttribute('listIndent') > limitIndent) {\n      continue;\n    } // ■ List item 1.[]  [listType=bulleted]\n    // 1. List item 2.   [listType=numbered]\n    // 2.List item 3.    [listType=numbered]\n    //\n    // Abort searching when found a different kind of a list.\n\n\n    if (element.getAttribute('listType') !== listItem.getAttribute('listType')) {\n      break;\n    } // ■ List item 1.[]  [listType=bulleted]\n    // ■ List item 2.    [listType=bulleted]\n    // ○ List item 3.    [listType=bulleted]\n    // ○ List item 4.    [listType=bulleted]\n    //\n    // Abort searching when found a different list style.\n\n\n    if (element.getAttribute('listStyle') !== listItem.getAttribute('listStyle')) {\n      break;\n    }\n\n    if (direction === 'backward') {\n      items.unshift(element);\n    } else {\n      items.push(element);\n    }\n  }\n\n  return items;\n} // Implementation of getFillerOffset for view list item element.\n//\n// @returns {Number|null} Block filler offset or `null` if block filler is not needed.\n\nfunction getListItemFillerOffset() {\n  const hasOnlyLists = !this.isEmpty && (this.getChild(0).name == 'ul' || this.getChild(0).name == 'ol');\n\n  if (this.isEmpty || hasOnlyLists) {\n    return 0;\n  }\n\n  return getFillerOffset.call(this);\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-list/src/utils.js"],"names":["TreeWalker","getFillerOffset","ButtonView","createViewListItemElement","writer","viewItem","createContainerElement","getListItemFillerOffset","generateLiInUl","modelItem","conversionApi","mapper","viewWriter","listType","getAttribute","viewList","insert","createPositionAt","bindElements","injectViewList","injectedItem","model","injectedList","parent","insertPosition","toViewPosition","createPositionBefore","refItem","getSiblingListItem","previousSibling","sameIndent","smallerIndent","listIndent","prevItem","toViewElement","breakContainer","createPositionAfter","name","mappedViewAncestor","findMappedViewAncestor","nestedList","findNestedList","positionAfterUiElements","prevView","walkerBoundaries","createRange","walker","getWalker","ignoreElementEnd","value","item","is","breakPosition","targetPosition","mergeViewLists","nodeBefore","nodeAfter","move","createRangeOn","position","nextViewList","nextSibling","lastSubChild","child","getChildren","modelChild","toModelElement","firstList","secondList","mergeContainers","viewPosition","getLastMatchingPosition","options","indent","itemIndent","direction","createUIComponent","editor","commandName","label","icon","ui","componentFactory","add","locale","command","commands","get","buttonView","set","tooltip","isToggleable","bind","to","on","execute","editing","view","focus","viewElement","node","getSiblingNodes","items","listItem","walkerOptions","startPosition","shallow","limitIndent","nodes","filter","map","element","unshift","push","hasOnlyLists","isEmpty","getChild","call"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/utils\n */\n\nimport { TreeWalker, getFillerOffset } from 'ckeditor5/src/engine';\nimport { ButtonView } from 'ckeditor5/src/ui';\n\n/**\n * Creates a list item {@link module:engine/view/containerelement~ContainerElement}.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer The writer instance.\n * @returns {module:engine/view/containerelement~ContainerElement}\n */\nexport function createViewListItemElement( writer ) {\n\tconst viewItem = writer.createContainerElement( 'li' );\n\n\tviewItem.getFillerOffset = getListItemFillerOffset;\n\n\treturn viewItem;\n}\n\n/**\n * Helper function that creates a `<ul><li></li></ul>` or (`<ol>`) structure out of the given `modelItem` model `listItem` element.\n * Then, it binds the created view list item (`<li>`) with the model `listItem` element.\n * The function then returns the created view list item (`<li>`).\n *\n * @param {module:engine/model/item~Item} modelItem Model list item.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface.\n * @returns {module:engine/view/containerelement~ContainerElement} View list element.\n */\nexport function generateLiInUl( modelItem, conversionApi ) {\n\tconst mapper = conversionApi.mapper;\n\tconst viewWriter = conversionApi.writer;\n\tconst listType = modelItem.getAttribute( 'listType' ) == 'numbered' ? 'ol' : 'ul';\n\tconst viewItem = createViewListItemElement( viewWriter );\n\n\tconst viewList = viewWriter.createContainerElement( listType, null );\n\n\tviewWriter.insert( viewWriter.createPositionAt( viewList, 0 ), viewItem );\n\n\tmapper.bindElements( modelItem, viewItem );\n\n\treturn viewItem;\n}\n\n/**\n * Helper function that inserts a view list at a correct place and merges it with its siblings.\n * It takes a model list item element (`modelItem`) and a corresponding view list item element (`injectedItem`). The view list item\n * should be in a view list element (`<ul>` or `<ol>`) and should be its only child.\n * See comments below to better understand the algorithm.\n *\n * @param {module:engine/view/item~Item} modelItem Model list item.\n * @param {module:engine/view/containerelement~ContainerElement} injectedItem\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface.\n * @param {module:engine/model/model~Model} model The model instance.\n */\nexport function injectViewList( modelItem, injectedItem, conversionApi, model ) {\n\tconst injectedList = injectedItem.parent;\n\tconst mapper = conversionApi.mapper;\n\tconst viewWriter = conversionApi.writer;\n\n\t// The position where the view list will be inserted.\n\tlet insertPosition = mapper.toViewPosition( model.createPositionBefore( modelItem ) );\n\n\t// 1. Find the previous list item that has the same or smaller indent. Basically we are looking for the first model item\n\t// that is a \"parent\" or \"sibling\" of the injected model item.\n\t// If there is no such list item, it means that the injected list item is the first item in \"its list\".\n\tconst refItem = getSiblingListItem( modelItem.previousSibling, {\n\t\tsameIndent: true,\n\t\tsmallerIndent: true,\n\t\tlistIndent: modelItem.getAttribute( 'listIndent' )\n\t} );\n\tconst prevItem = modelItem.previousSibling;\n\n\tif ( refItem && refItem.getAttribute( 'listIndent' ) == modelItem.getAttribute( 'listIndent' ) ) {\n\t\t// There is a list item with the same indent - we found the same-level sibling.\n\t\t// Break the list after it. The inserted view item will be added in the broken space.\n\t\tconst viewItem = mapper.toViewElement( refItem );\n\t\tinsertPosition = viewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\t} else {\n\t\t// There is no list item with the same indent. Check the previous model item.\n\t\tif ( prevItem && prevItem.name == 'listItem' ) {\n\t\t\t// If it is a list item, it has to have a lower indent.\n\t\t\t// It means that the inserted item should be added to it as its nested item.\n\t\t\tinsertPosition = mapper.toViewPosition( model.createPositionAt( prevItem, 'end' ) );\n\n\t\t\t// There could be some not mapped elements (eg. span in to-do list) but we need to insert\n\t\t\t// a nested list directly inside the li element.\n\t\t\tconst mappedViewAncestor = mapper.findMappedViewAncestor( insertPosition );\n\t\t\tconst nestedList = findNestedList( mappedViewAncestor );\n\n\t\t\t// If there already is some nested list, then use it's position.\n\t\t\tif ( nestedList ) {\n\t\t\t\tinsertPosition = viewWriter.createPositionBefore( nestedList );\n\t\t\t} else {\n\t\t\t\t// Else just put new list on the end of list item content.\n\t\t\t\tinsertPosition = viewWriter.createPositionAt( mappedViewAncestor, 'end' );\n\t\t\t}\n\t\t} else {\n\t\t\t// The previous item is not a list item (or does not exist at all).\n\t\t\t// Just map the position and insert the view item at the mapped position.\n\t\t\tinsertPosition = mapper.toViewPosition( model.createPositionBefore( modelItem ) );\n\t\t}\n\t}\n\n\tinsertPosition = positionAfterUiElements( insertPosition );\n\n\t// Insert the view item.\n\tviewWriter.insert( insertPosition, injectedList );\n\n\t// 2. Handle possible children of the injected model item.\n\tif ( prevItem && prevItem.name == 'listItem' ) {\n\t\tconst prevView = mapper.toViewElement( prevItem );\n\n\t\tconst walkerBoundaries = viewWriter.createRange( viewWriter.createPositionAt( prevView, 0 ), insertPosition );\n\t\tconst walker = walkerBoundaries.getWalker( { ignoreElementEnd: true } );\n\n\t\tfor ( const value of walker ) {\n\t\t\tif ( value.item.is( 'element', 'li' ) ) {\n\t\t\t\tconst breakPosition = viewWriter.breakContainer( viewWriter.createPositionBefore( value.item ) );\n\t\t\t\tconst viewList = value.item.parent;\n\n\t\t\t\tconst targetPosition = viewWriter.createPositionAt( injectedItem, 'end' );\n\t\t\t\tmergeViewLists( viewWriter, targetPosition.nodeBefore, targetPosition.nodeAfter );\n\t\t\t\tviewWriter.move( viewWriter.createRangeOn( viewList ), targetPosition );\n\n\t\t\t\twalker.position = breakPosition;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst nextViewList = injectedList.nextSibling;\n\n\t\tif ( nextViewList && ( nextViewList.is( 'element', 'ul' ) || nextViewList.is( 'element', 'ol' ) ) ) {\n\t\t\tlet lastSubChild = null;\n\n\t\t\tfor ( const child of nextViewList.getChildren() ) {\n\t\t\t\tconst modelChild = mapper.toModelElement( child );\n\n\t\t\t\tif ( modelChild && modelChild.getAttribute( 'listIndent' ) > modelItem.getAttribute( 'listIndent' ) ) {\n\t\t\t\t\tlastSubChild = child;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( lastSubChild ) {\n\t\t\t\tviewWriter.breakContainer( viewWriter.createPositionAfter( lastSubChild ) );\n\t\t\t\tviewWriter.move( viewWriter.createRangeOn( lastSubChild.parent ), viewWriter.createPositionAt( injectedItem, 'end' ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Merge the inserted view list with its possible neighbor lists.\n\tmergeViewLists( viewWriter, injectedList, injectedList.nextSibling );\n\tmergeViewLists( viewWriter, injectedList.previousSibling, injectedList );\n}\n\n/**\n * Helper function that takes two parameters that are expected to be view list elements, and merges them.\n * The merge happens only if both parameters are list elements of the same type (the same element name and the same class attributes).\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter The writer instance.\n * @param {module:engine/view/item~Item} firstList The first element to compare.\n * @param {module:engine/view/item~Item} secondList The second element to compare.\n * @returns {module:engine/view/position~Position|null} The position after merge or `null` when there was no merge.\n */\nexport function mergeViewLists( viewWriter, firstList, secondList ) {\n\t// Check if two lists are going to be merged.\n\tif ( !firstList || !secondList || ( firstList.name != 'ul' && firstList.name != 'ol' ) ) {\n\t\treturn null;\n\t}\n\n\t// Both parameters are list elements, so compare types now.\n\tif ( firstList.name != secondList.name || firstList.getAttribute( 'class' ) !== secondList.getAttribute( 'class' ) ) {\n\t\treturn null;\n\t}\n\n\treturn viewWriter.mergeContainers( viewWriter.createPositionAfter( firstList ) );\n}\n\n/**\n * Helper function that for a given `view.Position`, returns a `view.Position` that is after all `view.UIElement`s that\n * are after the given position.\n *\n * For example:\n * `<container:p>foo^<ui:span></ui:span><ui:span></ui:span>bar</container:p>`\n * For position ^, the position before \"bar\" will be returned.\n *\n * @param {module:engine/view/position~Position} viewPosition\n * @returns {module:engine/view/position~Position}\n */\nexport function positionAfterUiElements( viewPosition ) {\n\treturn viewPosition.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );\n}\n\n/**\n * Helper function that searches for a previous list item sibling of a given model item that meets the given criteria\n * passed by the options object.\n *\n * @param {module:engine/model/item~Item} modelItem\n * @param {Object} options Search criteria.\n * @param {Boolean} [options.sameIndent=false] Whether the sought sibling should have the same indentation.\n * @param {Boolean} [options.smallerIndent=false] Whether the sought sibling should have a smaller indentation.\n * @param {Number} [options.listIndent] The reference indentation.\n * @param {'forward'|'backward'} [options.direction='backward'] Walking direction.\n * @returns {module:engine/model/item~Item|null}\n */\nexport function getSiblingListItem( modelItem, options ) {\n\tconst sameIndent = !!options.sameIndent;\n\tconst smallerIndent = !!options.smallerIndent;\n\tconst indent = options.listIndent;\n\n\tlet item = modelItem;\n\n\twhile ( item && item.name == 'listItem' ) {\n\t\tconst itemIndent = item.getAttribute( 'listIndent' );\n\n\t\tif ( ( sameIndent && indent == itemIndent ) || ( smallerIndent && indent > itemIndent ) ) {\n\t\t\treturn item;\n\t\t}\n\n\t\tif ( options.direction === 'forward' ) {\n\t\t\titem = item.nextSibling;\n\t\t} else {\n\t\t\titem = item.previousSibling;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Helper method for creating a UI button and linking it with an appropriate command.\n *\n * @private\n * @param {module:core/editor/editor~Editor} editor The editor instance to which the UI component will be added.\n * @param {String} commandName The name of the command.\n * @param {String} label The button label.\n * @param {String} icon The source of the icon.\n */\nexport function createUIComponent( editor, commandName, label, icon ) {\n\teditor.ui.componentFactory.add( commandName, locale => {\n\t\tconst command = editor.commands.get( commandName );\n\t\tconst buttonView = new ButtonView( locale );\n\n\t\tbuttonView.set( {\n\t\t\tlabel,\n\t\t\ticon,\n\t\t\ttooltip: true,\n\t\t\tisToggleable: true\n\t\t} );\n\n\t\t// Bind button model to command.\n\t\tbuttonView.bind( 'isOn', 'isEnabled' ).to( command, 'value', 'isEnabled' );\n\n\t\t// Execute command.\n\t\tbuttonView.on( 'execute', () => {\n\t\t\teditor.execute( commandName );\n\t\t\teditor.editing.view.focus();\n\t\t} );\n\n\t\treturn buttonView;\n\t} );\n}\n\n/**\n * Returns a first list view element that is direct child of the given view element.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @return {module:engine/view/element~Element|null}\n */\nexport function findNestedList( viewElement ) {\n\tfor ( const node of viewElement.getChildren() ) {\n\t\tif ( node.name == 'ul' || node.name == 'ol' ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Returns an array with all `listItem` elements that represents the same list.\n *\n * It means that values for `listIndent`, `listType`, and `listStyle` for all items are equal.\n *\n * @param {module:engine/model/position~Position} position Starting position.\n * @param {'forward'|'backward'} direction Walking direction.\n * @returns {Array.<module:engine/model/element~Element>}\n */\nexport function getSiblingNodes( position, direction ) {\n\tconst items = [];\n\tconst listItem = position.parent;\n\tconst walkerOptions = {\n\t\tignoreElementEnd: true,\n\t\tstartPosition: position,\n\t\tshallow: true,\n\t\tdirection\n\t};\n\tconst limitIndent = listItem.getAttribute( 'listIndent' );\n\tconst nodes = [ ...new TreeWalker( walkerOptions ) ]\n\t\t.filter( value => value.item.is( 'element' ) )\n\t\t.map( value => value.item );\n\n\tfor ( const element of nodes ) {\n\t\t// If found something else than `listItem`, we're out of the list scope.\n\t\tif ( !element.is( 'element', 'listItem' ) ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// If current parsed item has lower indent that element that the element that was a starting point,\n\t\t// it means we left a nested list. Abort searching items.\n\t\t//\n\t\t// ■ List item 1.       [listIndent=0]\n\t\t//     ○ List item 2.[] [listIndent=1], limitIndent = 1,\n\t\t//     ○ List item 3.   [listIndent=1]\n\t\t// ■ List item 4.       [listIndent=0]\n\t\t//\n\t\t// Abort searching when leave nested list.\n\t\tif ( element.getAttribute( 'listIndent' ) < limitIndent ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// ■ List item 1.[]     [listIndent=0] limitIndent = 0,\n\t\t//     ○ List item 2.   [listIndent=1]\n\t\t//     ○ List item 3.   [listIndent=1]\n\t\t// ■ List item 4.       [listIndent=0]\n\t\t//\n\t\t// Ignore nested lists.\n\t\tif ( element.getAttribute( 'listIndent' ) > limitIndent ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// ■ List item 1.[]  [listType=bulleted]\n\t\t// 1. List item 2.   [listType=numbered]\n\t\t// 2.List item 3.    [listType=numbered]\n\t\t//\n\t\t// Abort searching when found a different kind of a list.\n\t\tif ( element.getAttribute( 'listType' ) !== listItem.getAttribute( 'listType' ) ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// ■ List item 1.[]  [listType=bulleted]\n\t\t// ■ List item 2.    [listType=bulleted]\n\t\t// ○ List item 3.    [listType=bulleted]\n\t\t// ○ List item 4.    [listType=bulleted]\n\t\t//\n\t\t// Abort searching when found a different list style.\n\t\tif ( element.getAttribute( 'listStyle' ) !== listItem.getAttribute( 'listStyle' ) ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( direction === 'backward' ) {\n\t\t\titems.unshift( element );\n\t\t} else {\n\t\t\titems.push( element );\n\t\t}\n\t}\n\n\treturn items;\n}\n\n// Implementation of getFillerOffset for view list item element.\n//\n// @returns {Number|null} Block filler offset or `null` if block filler is not needed.\nfunction getListItemFillerOffset() {\n\tconst hasOnlyLists = !this.isEmpty && ( this.getChild( 0 ).name == 'ul' || this.getChild( 0 ).name == 'ol' );\n\n\tif ( this.isEmpty || hasOnlyLists ) {\n\t\treturn 0;\n\t}\n\n\treturn getFillerOffset.call( this );\n}\n"]},"metadata":{},"sourceType":"module"}