{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/imageinlineediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport { downcastImageAttribute, downcastSrcsetAttribute } from './converters';\nimport ImageEditing from './imageediting';\nimport ImageTypeCommand from './imagetypecommand';\nimport ImageUtils from '../imageutils';\nimport { getImgViewElementMatcher, createImageViewElement, determineImageTypeForInsertionAtSelection } from '../image/utils';\n/**\n * The image inline plugin.\n *\n * It registers:\n *\n * * `<imageInline>` as an inline element in the document schema, and allows `alt`, `src` and `srcset` attributes.\n * * converters for editing and data pipelines.\n * * {@link module:image/image/imagetypecommand~ImageTypeCommand `'imageTypeInline'`} command that converts block images into\n * inline images.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class ImageInlineEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [ImageEditing, ImageUtils, ClipboardPipeline];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get pluginName() {\n    return 'ImageInlineEditing';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const schema = editor.model.schema; // Converters 'alt' and 'srcset' are added in 'ImageEditing' plugin.\n\n    schema.register('imageInline', {\n      isObject: true,\n      isInline: true,\n      allowWhere: '$text',\n      allowAttributesOf: '$text',\n      allowAttributes: ['alt', 'src', 'srcset']\n    }); // Disallow inline images in captions (for now). This is the best spot to do that because\n    // independent packages can introduce captions (ImageCaption, TableCaption, etc.) so better this\n    // be future-proof.\n\n    schema.addChildCheck((context, childDefinition) => {\n      if (context.endsWith('caption') && childDefinition.name === 'imageInline') {\n        return false;\n      }\n    });\n\n    this._setupConversion();\n\n    if (editor.plugins.has('ImageBlockEditing')) {\n      editor.commands.add('imageTypeInline', new ImageTypeCommand(this.editor, 'imageInline'));\n\n      this._setupClipboardIntegration();\n    }\n  }\n  /**\n   * Configures conversion pipelines to support upcasting and downcasting\n   * inline images (inline image widgets) and their attributes.\n   *\n   * @private\n   */\n\n\n  _setupConversion() {\n    const editor = this.editor;\n    const t = editor.t;\n    const conversion = editor.conversion;\n    const imageUtils = editor.plugins.get('ImageUtils');\n    conversion.for('dataDowncast').elementToElement({\n      model: 'imageInline',\n      view: (modelElement, {\n        writer\n      }) => writer.createEmptyElement('img')\n    });\n    conversion.for('editingDowncast').elementToElement({\n      model: 'imageInline',\n      view: (modelElement, {\n        writer\n      }) => imageUtils.toImageWidget(createImageViewElement(writer, 'imageInline'), writer, t('image widget'))\n    });\n    conversion.for('downcast').add(downcastImageAttribute(imageUtils, 'imageInline', 'src')).add(downcastImageAttribute(imageUtils, 'imageInline', 'alt')).add(downcastSrcsetAttribute(imageUtils, 'imageInline')); // More image related upcasts are in 'ImageEditing' plugin.\n\n    conversion.for('upcast').elementToElement({\n      view: getImgViewElementMatcher(editor, 'imageInline'),\n      model: (viewImage, {\n        writer\n      }) => writer.createElement('imageInline', viewImage.hasAttribute('src') ? {\n        src: viewImage.getAttribute('src')\n      } : null)\n    });\n  }\n  /**\n   * Integrates the plugin with the clipboard pipeline.\n   *\n   * Idea is that the feature should recognize the user's intent when an **block** image is\n   * pasted or dropped. If such an image is pasted/dropped into a non-empty block\n   * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.\n   *\n   * We assume this is the user's intent if they decided to put their image there.\n   *\n   * **Note**: If a block image has a caption, it will not be converted to an inline image\n   * to avoid the confusion. Captions are added on purpose and they should never be lost\n   * in the clipboard pipeline.\n   *\n   * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.\n   *\n   * @private\n   */\n\n\n  _setupClipboardIntegration() {\n    const editor = this.editor;\n    const model = editor.model;\n    const editingView = editor.editing.view;\n    const imageUtils = editor.plugins.get('ImageUtils');\n    this.listenTo(editor.plugins.get('ClipboardPipeline'), 'inputTransformation', (evt, data) => {\n      const docFragmentChildren = Array.from(data.content.getChildren());\n      let modelRange; // Make sure only <figure class=\"image\"></figure> elements are dropped or pasted. Otherwise, if there some other HTML\n      // mixed up, this should be handled as a regular paste.\n\n      if (!docFragmentChildren.every(imageUtils.isBlockImageView)) {\n        return;\n      } // When drag and dropping, data.targetRanges specifies where to drop because\n      // this is usually a different place than the current model selection (the user\n      // uses a drop marker to specify the drop location).\n\n\n      if (data.targetRanges) {\n        modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);\n      } // Pasting, however, always occurs at the current model selection.\n      else {\n          modelRange = model.document.selection.getFirstRange();\n        }\n\n      const selection = model.createSelection(modelRange); // Convert block images into inline images only when pasting or dropping into non-empty blocks\n      // and when the block is not an object (e.g. pasting to replace another widget).\n\n      if (determineImageTypeForInsertionAtSelection(model.schema, selection) === 'imageInline') {\n        const writer = new UpcastWriter(editingView.document); // Unwrap <figure class=\"image\"><img .../></figure> -> <img ... />\n        // but <figure class=\"image\"><img .../><figcaption>...</figcaption></figure> -> stays the same\n\n        const inlineViewImages = docFragmentChildren.map(blockViewImage => {\n          // If there's just one child, it can be either <img /> or <a><img></a>.\n          // If there are other children than <img>, this means that the block image\n          // has a caption or some other features and this kind of image should be\n          // pasted/dropped without modifications.\n          if (blockViewImage.childCount === 1) {\n            // Pass the attributes which are present only in the <figure> to the <img>\n            // (e.g. the style=\"width:10%\" attribute applied by the ImageResize plugin).\n            Array.from(blockViewImage.getAttributes()).forEach(attribute => writer.setAttribute(...attribute, imageUtils.findViewImgElement(blockViewImage)));\n            return blockViewImage.getChild(0);\n          } else {\n            return blockViewImage;\n          }\n        });\n        data.content = writer.createDocumentFragment(inlineViewImages);\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-image/src/image/imageinlineediting.js"],"names":["Plugin","ClipboardPipeline","UpcastWriter","downcastImageAttribute","downcastSrcsetAttribute","ImageEditing","ImageTypeCommand","ImageUtils","getImgViewElementMatcher","createImageViewElement","determineImageTypeForInsertionAtSelection","ImageInlineEditing","requires","pluginName","init","editor","schema","model","register","isObject","isInline","allowWhere","allowAttributesOf","allowAttributes","addChildCheck","context","childDefinition","endsWith","name","_setupConversion","plugins","has","commands","add","_setupClipboardIntegration","t","conversion","imageUtils","get","for","elementToElement","view","modelElement","writer","createEmptyElement","toImageWidget","viewImage","createElement","hasAttribute","src","getAttribute","editingView","editing","listenTo","evt","data","docFragmentChildren","Array","from","content","getChildren","modelRange","every","isBlockImageView","targetRanges","mapper","toModelRange","document","selection","getFirstRange","createSelection","inlineViewImages","map","blockViewImage","childCount","getAttributes","forEach","attribute","setAttribute","findViewImgElement","getChild","createDocumentFragment"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/imageinlineediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\n\nimport {\n\tdowncastImageAttribute,\n\tdowncastSrcsetAttribute\n} from './converters';\n\nimport ImageEditing from './imageediting';\nimport ImageTypeCommand from './imagetypecommand';\nimport ImageUtils from '../imageutils';\nimport {\n\tgetImgViewElementMatcher,\n\tcreateImageViewElement,\n\tdetermineImageTypeForInsertionAtSelection\n} from '../image/utils';\n\n/**\n * The image inline plugin.\n *\n * It registers:\n *\n * * `<imageInline>` as an inline element in the document schema, and allows `alt`, `src` and `srcset` attributes.\n * * converters for editing and data pipelines.\n * * {@link module:image/image/imagetypecommand~ImageTypeCommand `'imageTypeInline'`} command that converts block images into\n * inline images.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageInlineEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ImageEditing, ImageUtils, ClipboardPipeline ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ImageInlineEditing';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst schema = editor.model.schema;\n\n\t\t// Converters 'alt' and 'srcset' are added in 'ImageEditing' plugin.\n\t\tschema.register( 'imageInline', {\n\t\t\tisObject: true,\n\t\t\tisInline: true,\n\t\t\tallowWhere: '$text',\n\t\t\tallowAttributesOf: '$text',\n\t\t\tallowAttributes: [ 'alt', 'src', 'srcset' ]\n\t\t} );\n\n\t\t// Disallow inline images in captions (for now). This is the best spot to do that because\n\t\t// independent packages can introduce captions (ImageCaption, TableCaption, etc.) so better this\n\t\t// be future-proof.\n\t\tschema.addChildCheck( ( context, childDefinition ) => {\n\t\t\tif ( context.endsWith( 'caption' ) && childDefinition.name === 'imageInline' ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} );\n\n\t\tthis._setupConversion();\n\n\t\tif ( editor.plugins.has( 'ImageBlockEditing' ) ) {\n\t\t\teditor.commands.add( 'imageTypeInline', new ImageTypeCommand( this.editor, 'imageInline' ) );\n\n\t\t\tthis._setupClipboardIntegration();\n\t\t}\n\t}\n\n\t/**\n\t * Configures conversion pipelines to support upcasting and downcasting\n\t * inline images (inline image widgets) and their attributes.\n\t *\n\t * @private\n\t */\n\t_setupConversion() {\n\t\tconst editor = this.editor;\n\t\tconst t = editor.t;\n\t\tconst conversion = editor.conversion;\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\t\tconversion.for( 'dataDowncast' )\n\t\t\t.elementToElement( {\n\t\t\t\tmodel: 'imageInline',\n\t\t\t\tview: ( modelElement, { writer } ) => writer.createEmptyElement( 'img' )\n\t\t\t} );\n\n\t\tconversion.for( 'editingDowncast' )\n\t\t\t.elementToElement( {\n\t\t\t\tmodel: 'imageInline',\n\t\t\t\tview: ( modelElement, { writer } ) => imageUtils.toImageWidget(\n\t\t\t\t\tcreateImageViewElement( writer, 'imageInline' ), writer, t( 'image widget' )\n\t\t\t\t)\n\t\t\t} );\n\n\t\tconversion.for( 'downcast' )\n\t\t\t.add( downcastImageAttribute( imageUtils, 'imageInline', 'src' ) )\n\t\t\t.add( downcastImageAttribute( imageUtils, 'imageInline', 'alt' ) )\n\t\t\t.add( downcastSrcsetAttribute( imageUtils, 'imageInline' ) );\n\n\t\t// More image related upcasts are in 'ImageEditing' plugin.\n\t\tconversion.for( 'upcast' )\n\t\t\t.elementToElement( {\n\t\t\t\tview: getImgViewElementMatcher( editor, 'imageInline' ),\n\t\t\t\tmodel: ( viewImage, { writer } ) => writer.createElement(\n\t\t\t\t\t'imageInline',\n\t\t\t\t\tviewImage.hasAttribute( 'src' ) ? { src: viewImage.getAttribute( 'src' ) } : null\n\t\t\t\t)\n\t\t\t} );\n\t}\n\n\t/**\n\t * Integrates the plugin with the clipboard pipeline.\n\t *\n\t * Idea is that the feature should recognize the user's intent when an **block** image is\n\t * pasted or dropped. If such an image is pasted/dropped into a non-empty block\n\t * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.\n\t *\n\t * We assume this is the user's intent if they decided to put their image there.\n\t *\n\t * **Note**: If a block image has a caption, it will not be converted to an inline image\n\t * to avoid the confusion. Captions are added on purpose and they should never be lost\n\t * in the clipboard pipeline.\n\t *\n\t * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.\n\t *\n\t * @private\n\t */\n\t_setupClipboardIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst editingView = editor.editing.view;\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\t\tthis.listenTo( editor.plugins.get( 'ClipboardPipeline' ), 'inputTransformation', ( evt, data ) => {\n\t\t\tconst docFragmentChildren = Array.from( data.content.getChildren() );\n\t\t\tlet modelRange;\n\n\t\t\t// Make sure only <figure class=\"image\"></figure> elements are dropped or pasted. Otherwise, if there some other HTML\n\t\t\t// mixed up, this should be handled as a regular paste.\n\t\t\tif ( !docFragmentChildren.every( imageUtils.isBlockImageView ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// When drag and dropping, data.targetRanges specifies where to drop because\n\t\t\t// this is usually a different place than the current model selection (the user\n\t\t\t// uses a drop marker to specify the drop location).\n\t\t\tif ( data.targetRanges ) {\n\t\t\t\tmodelRange = editor.editing.mapper.toModelRange( data.targetRanges[ 0 ] );\n\t\t\t}\n\t\t\t// Pasting, however, always occurs at the current model selection.\n\t\t\telse {\n\t\t\t\tmodelRange = model.document.selection.getFirstRange();\n\t\t\t}\n\n\t\t\tconst selection = model.createSelection( modelRange );\n\n\t\t\t// Convert block images into inline images only when pasting or dropping into non-empty blocks\n\t\t\t// and when the block is not an object (e.g. pasting to replace another widget).\n\t\t\tif ( determineImageTypeForInsertionAtSelection( model.schema, selection ) === 'imageInline' ) {\n\t\t\t\tconst writer = new UpcastWriter( editingView.document );\n\n\t\t\t\t// Unwrap <figure class=\"image\"><img .../></figure> -> <img ... />\n\t\t\t\t// but <figure class=\"image\"><img .../><figcaption>...</figcaption></figure> -> stays the same\n\t\t\t\tconst inlineViewImages = docFragmentChildren.map( blockViewImage => {\n\t\t\t\t\t// If there's just one child, it can be either <img /> or <a><img></a>.\n\t\t\t\t\t// If there are other children than <img>, this means that the block image\n\t\t\t\t\t// has a caption or some other features and this kind of image should be\n\t\t\t\t\t// pasted/dropped without modifications.\n\t\t\t\t\tif ( blockViewImage.childCount === 1 ) {\n\t\t\t\t\t\t// Pass the attributes which are present only in the <figure> to the <img>\n\t\t\t\t\t\t// (e.g. the style=\"width:10%\" attribute applied by the ImageResize plugin).\n\t\t\t\t\t\tArray.from( blockViewImage.getAttributes() )\n\t\t\t\t\t\t\t.forEach( attribute => writer.setAttribute(\n\t\t\t\t\t\t\t\t...attribute,\n\t\t\t\t\t\t\t\timageUtils.findViewImgElement( blockViewImage )\n\t\t\t\t\t\t\t) );\n\n\t\t\t\t\t\treturn blockViewImage.getChild( 0 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn blockViewImage;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tdata.content = writer.createDocumentFragment( inlineViewImages );\n\t\t\t}\n\t\t} );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}