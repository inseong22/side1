{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/imageblockediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport { downcastImageAttribute, downcastSrcsetAttribute, upcastImageFigure } from './converters';\nimport ImageEditing from './imageediting';\nimport ImageTypeCommand from './imagetypecommand';\nimport ImageUtils from '../imageutils';\nimport { getImgViewElementMatcher, createImageViewElement, determineImageTypeForInsertionAtSelection } from '../image/utils';\n/**\n * The image block plugin.\n *\n * It registers:\n *\n * * `<imageBlock>` as a block element in the document schema, and allows `alt`, `src` and `srcset` attributes.\n * * converters for editing and data pipelines.,\n * * {@link module:image/image/imagetypecommand~ImageTypeCommand `'imageTypeBlock'`} command that converts inline images into\n * block images.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class ImageBlockEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [ImageEditing, ImageUtils, ClipboardPipeline];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get pluginName() {\n    return 'ImageBlockEditing';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const schema = editor.model.schema; // Converters 'alt' and 'srcset' are added in 'ImageEditing' plugin.\n\n    schema.register('imageBlock', {\n      isObject: true,\n      isBlock: true,\n      allowWhere: '$block',\n      allowAttributes: ['alt', 'src', 'srcset']\n    });\n\n    this._setupConversion();\n\n    if (editor.plugins.has('ImageInlineEditing')) {\n      editor.commands.add('imageTypeBlock', new ImageTypeCommand(this.editor, 'imageBlock'));\n\n      this._setupClipboardIntegration();\n    }\n  }\n  /**\n   * Configures conversion pipelines to support upcasting and downcasting\n   * block images (block image widgets) and their attributes.\n   *\n   * @private\n   */\n\n\n  _setupConversion() {\n    const editor = this.editor;\n    const t = editor.t;\n    const conversion = editor.conversion;\n    const imageUtils = editor.plugins.get('ImageUtils');\n    conversion.for('dataDowncast').elementToElement({\n      model: 'imageBlock',\n      view: (modelElement, {\n        writer\n      }) => createImageViewElement(writer, 'imageBlock')\n    });\n    conversion.for('editingDowncast').elementToElement({\n      model: 'imageBlock',\n      view: (modelElement, {\n        writer\n      }) => imageUtils.toImageWidget(createImageViewElement(writer, 'imageBlock'), writer, t('image widget'))\n    });\n    conversion.for('downcast').add(downcastImageAttribute(imageUtils, 'imageBlock', 'src')).add(downcastImageAttribute(imageUtils, 'imageBlock', 'alt')).add(downcastSrcsetAttribute(imageUtils, 'imageBlock')); // More image related upcasts are in 'ImageEditing' plugin.\n\n    conversion.for('upcast').elementToElement({\n      view: getImgViewElementMatcher(editor, 'imageBlock'),\n      model: (viewImage, {\n        writer\n      }) => writer.createElement('imageBlock', viewImage.hasAttribute('src') ? {\n        src: viewImage.getAttribute('src')\n      } : null)\n    }).add(upcastImageFigure(imageUtils));\n  }\n  /**\n   * Integrates the plugin with the clipboard pipeline.\n   *\n   * Idea is that the feature should recognize the user's intent when an **inline** image is\n   * pasted or dropped. If such an image is pasted/dropped:\n   *\n   * * into an empty block (e.g. an empty paragraph),\n   * * on another object (e.g. some block widget).\n   *\n   * it gets converted into a block image on the fly. We assume this is the user's intent\n   * if they decided to put their image there.\n   *\n   * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.\n   *\n   * @private\n   */\n\n\n  _setupClipboardIntegration() {\n    const editor = this.editor;\n    const model = editor.model;\n    const editingView = editor.editing.view;\n    const imageUtils = editor.plugins.get('ImageUtils');\n    this.listenTo(editor.plugins.get('ClipboardPipeline'), 'inputTransformation', (evt, data) => {\n      const docFragmentChildren = Array.from(data.content.getChildren());\n      let modelRange; // Make sure only <img> elements are dropped or pasted. Otherwise, if there some other HTML\n      // mixed up, this should be handled as a regular paste.\n\n      if (!docFragmentChildren.every(imageUtils.isInlineImageView)) {\n        return;\n      } // When drag and dropping, data.targetRanges specifies where to drop because\n      // this is usually a different place than the current model selection (the user\n      // uses a drop marker to specify the drop location).\n\n\n      if (data.targetRanges) {\n        modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);\n      } // Pasting, however, always occurs at the current model selection.\n      else {\n          modelRange = model.document.selection.getFirstRange();\n        }\n\n      const selection = model.createSelection(modelRange); // Convert inline images into block images only when the currently selected block is empty\n      // (e.g. an empty paragraph) or some object is selected (to replace it).\n\n      if (determineImageTypeForInsertionAtSelection(model.schema, selection) === 'imageBlock') {\n        const writer = new UpcastWriter(editingView.document); // Wrap <img ... /> -> <figure class=\"image\"><img .../></figure>\n\n        const blockViewImages = docFragmentChildren.map(inlineViewImage => writer.createElement('figure', {\n          class: 'image'\n        }, inlineViewImage));\n        data.content = writer.createDocumentFragment(blockViewImages);\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-image/src/image/imageblockediting.js"],"names":["Plugin","ClipboardPipeline","UpcastWriter","downcastImageAttribute","downcastSrcsetAttribute","upcastImageFigure","ImageEditing","ImageTypeCommand","ImageUtils","getImgViewElementMatcher","createImageViewElement","determineImageTypeForInsertionAtSelection","ImageBlockEditing","requires","pluginName","init","editor","schema","model","register","isObject","isBlock","allowWhere","allowAttributes","_setupConversion","plugins","has","commands","add","_setupClipboardIntegration","t","conversion","imageUtils","get","for","elementToElement","view","modelElement","writer","toImageWidget","viewImage","createElement","hasAttribute","src","getAttribute","editingView","editing","listenTo","evt","data","docFragmentChildren","Array","from","content","getChildren","modelRange","every","isInlineImageView","targetRanges","mapper","toModelRange","document","selection","getFirstRange","createSelection","blockViewImages","map","inlineViewImage","class","createDocumentFragment"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/imageblockediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\n\nimport {\n\tdowncastImageAttribute,\n\tdowncastSrcsetAttribute,\n\tupcastImageFigure\n} from './converters';\n\nimport ImageEditing from './imageediting';\nimport ImageTypeCommand from './imagetypecommand';\nimport ImageUtils from '../imageutils';\nimport {\n\tgetImgViewElementMatcher,\n\tcreateImageViewElement,\n\tdetermineImageTypeForInsertionAtSelection\n} from '../image/utils';\n\n/**\n * The image block plugin.\n *\n * It registers:\n *\n * * `<imageBlock>` as a block element in the document schema, and allows `alt`, `src` and `srcset` attributes.\n * * converters for editing and data pipelines.,\n * * {@link module:image/image/imagetypecommand~ImageTypeCommand `'imageTypeBlock'`} command that converts inline images into\n * block images.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageBlockEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ImageEditing, ImageUtils, ClipboardPipeline ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ImageBlockEditing';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst schema = editor.model.schema;\n\n\t\t// Converters 'alt' and 'srcset' are added in 'ImageEditing' plugin.\n\t\tschema.register( 'imageBlock', {\n\t\t\tisObject: true,\n\t\t\tisBlock: true,\n\t\t\tallowWhere: '$block',\n\t\t\tallowAttributes: [ 'alt', 'src', 'srcset' ]\n\t\t} );\n\n\t\tthis._setupConversion();\n\n\t\tif ( editor.plugins.has( 'ImageInlineEditing' ) ) {\n\t\t\teditor.commands.add( 'imageTypeBlock', new ImageTypeCommand( this.editor, 'imageBlock' ) );\n\n\t\t\tthis._setupClipboardIntegration();\n\t\t}\n\t}\n\n\t/**\n\t * Configures conversion pipelines to support upcasting and downcasting\n\t * block images (block image widgets) and their attributes.\n\t *\n\t * @private\n\t */\n\t_setupConversion() {\n\t\tconst editor = this.editor;\n\t\tconst t = editor.t;\n\t\tconst conversion = editor.conversion;\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\t\tconversion.for( 'dataDowncast' )\n\t\t\t.elementToElement( {\n\t\t\t\tmodel: 'imageBlock',\n\t\t\t\tview: ( modelElement, { writer } ) => createImageViewElement( writer, 'imageBlock' )\n\t\t\t} );\n\n\t\tconversion.for( 'editingDowncast' )\n\t\t\t.elementToElement( {\n\t\t\t\tmodel: 'imageBlock',\n\t\t\t\tview: ( modelElement, { writer } ) => imageUtils.toImageWidget(\n\t\t\t\t\tcreateImageViewElement( writer, 'imageBlock' ), writer, t( 'image widget' )\n\t\t\t\t)\n\t\t\t} );\n\n\t\tconversion.for( 'downcast' )\n\t\t\t.add( downcastImageAttribute( imageUtils, 'imageBlock', 'src' ) )\n\t\t\t.add( downcastImageAttribute( imageUtils, 'imageBlock', 'alt' ) )\n\t\t\t.add( downcastSrcsetAttribute( imageUtils, 'imageBlock' ) );\n\n\t\t// More image related upcasts are in 'ImageEditing' plugin.\n\t\tconversion.for( 'upcast' )\n\t\t\t.elementToElement( {\n\t\t\t\tview: getImgViewElementMatcher( editor, 'imageBlock' ),\n\t\t\t\tmodel: ( viewImage, { writer } ) => writer.createElement(\n\t\t\t\t\t'imageBlock',\n\t\t\t\t\tviewImage.hasAttribute( 'src' ) ? { src: viewImage.getAttribute( 'src' ) } : null\n\t\t\t\t)\n\t\t\t} )\n\t\t\t.add( upcastImageFigure( imageUtils ) );\n\t}\n\n\t/**\n\t * Integrates the plugin with the clipboard pipeline.\n\t *\n\t * Idea is that the feature should recognize the user's intent when an **inline** image is\n\t * pasted or dropped. If such an image is pasted/dropped:\n\t *\n\t * * into an empty block (e.g. an empty paragraph),\n\t * * on another object (e.g. some block widget).\n\t *\n\t * it gets converted into a block image on the fly. We assume this is the user's intent\n\t * if they decided to put their image there.\n\t *\n\t * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.\n\t *\n\t * @private\n\t */\n\t_setupClipboardIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst editingView = editor.editing.view;\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\t\tthis.listenTo( editor.plugins.get( 'ClipboardPipeline' ), 'inputTransformation', ( evt, data ) => {\n\t\t\tconst docFragmentChildren = Array.from( data.content.getChildren() );\n\t\t\tlet modelRange;\n\n\t\t\t// Make sure only <img> elements are dropped or pasted. Otherwise, if there some other HTML\n\t\t\t// mixed up, this should be handled as a regular paste.\n\t\t\tif ( !docFragmentChildren.every( imageUtils.isInlineImageView ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// When drag and dropping, data.targetRanges specifies where to drop because\n\t\t\t// this is usually a different place than the current model selection (the user\n\t\t\t// uses a drop marker to specify the drop location).\n\t\t\tif ( data.targetRanges ) {\n\t\t\t\tmodelRange = editor.editing.mapper.toModelRange( data.targetRanges[ 0 ] );\n\t\t\t}\n\t\t\t// Pasting, however, always occurs at the current model selection.\n\t\t\telse {\n\t\t\t\tmodelRange = model.document.selection.getFirstRange();\n\t\t\t}\n\n\t\t\tconst selection = model.createSelection( modelRange );\n\n\t\t\t// Convert inline images into block images only when the currently selected block is empty\n\t\t\t// (e.g. an empty paragraph) or some object is selected (to replace it).\n\t\t\tif ( determineImageTypeForInsertionAtSelection( model.schema, selection ) === 'imageBlock' ) {\n\t\t\t\tconst writer = new UpcastWriter( editingView.document );\n\n\t\t\t\t// Wrap <img ... /> -> <figure class=\"image\"><img .../></figure>\n\t\t\t\tconst blockViewImages = docFragmentChildren.map(\n\t\t\t\t\tinlineViewImage => writer.createElement( 'figure', { class: 'image' }, inlineViewImage )\n\t\t\t\t);\n\n\t\t\t\tdata.content = writer.createDocumentFragment( blockViewImages );\n\t\t\t}\n\t\t} );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}