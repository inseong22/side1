{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { MouseObserver } from 'ckeditor5/src/engine';\nimport { Input, TwoStepCaretMovement, inlineHighlight, findAttributeRange } from 'ckeditor5/src/typing';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { keyCodes, env } from 'ckeditor5/src/utils';\nimport LinkCommand from './linkcommand';\nimport UnlinkCommand from './unlinkcommand';\nimport ManualDecorator from './utils/manualdecorator';\nimport { createLinkElement, ensureSafeUrl, getLocalizedDecorators, normalizeDecorators, openLink } from './utils';\nimport '../theme/link.css';\nconst HIGHLIGHT_CLASS = 'ck-link_selected';\nconst DECORATOR_AUTOMATIC = 'automatic';\nconst DECORATOR_MANUAL = 'manual';\nconst EXTERNAL_LINKS_REGEXP = /^(https?:)?\\/\\//;\n/**\n * The link engine feature.\n *\n * It introduces the `linkHref=\"url\"` attribute in the model which renders to the view as a `<a href=\"url\">` element\n * as well as `'link'` and `'unlink'` commands.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class LinkEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'LinkEditing';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    // Clipboard is required for handling cut and paste events while typing over the link.\n    return [TwoStepCaretMovement, Input, ClipboardPipeline];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  constructor(editor) {\n    super(editor);\n    editor.config.define('link', {\n      addTargetToExternalLinks: false\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor; // Allow link attribute on all inline nodes.\n\n    editor.model.schema.extend('$text', {\n      allowAttributes: 'linkHref'\n    });\n    editor.conversion.for('dataDowncast').attributeToElement({\n      model: 'linkHref',\n      view: createLinkElement\n    });\n    editor.conversion.for('editingDowncast').attributeToElement({\n      model: 'linkHref',\n      view: (href, conversionApi) => {\n        return createLinkElement(ensureSafeUrl(href), conversionApi);\n      }\n    });\n    editor.conversion.for('upcast').elementToAttribute({\n      view: {\n        name: 'a',\n        attributes: {\n          href: true\n        }\n      },\n      model: {\n        key: 'linkHref',\n        value: viewElement => viewElement.getAttribute('href')\n      }\n    }); // Create linking commands.\n\n    editor.commands.add('link', new LinkCommand(editor));\n    editor.commands.add('unlink', new UnlinkCommand(editor));\n    const linkDecorators = getLocalizedDecorators(editor.t, normalizeDecorators(editor.config.get('link.decorators')));\n\n    this._enableAutomaticDecorators(linkDecorators.filter(item => item.mode === DECORATOR_AUTOMATIC));\n\n    this._enableManualDecorators(linkDecorators.filter(item => item.mode === DECORATOR_MANUAL)); // Enable two-step caret movement for `linkHref` attribute.\n\n\n    const twoStepCaretMovementPlugin = editor.plugins.get(TwoStepCaretMovement);\n    twoStepCaretMovementPlugin.registerAttribute('linkHref'); // Setup highlight over selected link.\n\n    inlineHighlight(editor, 'linkHref', 'a', HIGHLIGHT_CLASS); // Handle link following by CTRL+click or ALT+ENTER\n\n    this._enableLinkOpen(); // Change the attributes of the selection in certain situations after the link was inserted into the document.\n\n\n    this._enableInsertContentSelectionAttributesFixer(); // Handle a click at the beginning/end of a link element.\n\n\n    this._enableClickingAfterLink(); // Handle typing over the link.\n\n\n    this._enableTypingOverLink(); // Handle removing the content after the link element.\n\n\n    this._handleDeleteContentAfterLink();\n  }\n  /**\n   * Processes an array of configured {@link module:link/link~LinkDecoratorAutomaticDefinition automatic decorators}\n   * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}\n   * for each one of them. Downcast dispatchers are obtained using the\n   * {@link module:link/utils~AutomaticDecorators#getDispatcher} method.\n   *\n   * **Note**: This method also activates the automatic external link decorator if enabled with\n   * {@link module:link/link~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.\n   *\n   * @private\n   * @param {Array.<module:link/link~LinkDecoratorAutomaticDefinition>} automaticDecoratorDefinitions\n   */\n\n\n  _enableAutomaticDecorators(automaticDecoratorDefinitions) {\n    const editor = this.editor; // Store automatic decorators in the command instance as we do the same with manual decorators.\n    // Thanks to that, `LinkImageEditing` plugin can re-use the same definitions.\n\n    const command = editor.commands.get('link');\n    const automaticDecorators = command.automaticDecorators; // Adds a default decorator for external links.\n\n    if (editor.config.get('link.addTargetToExternalLinks')) {\n      automaticDecorators.add({\n        id: 'linkIsExternal',\n        mode: DECORATOR_AUTOMATIC,\n        callback: url => EXTERNAL_LINKS_REGEXP.test(url),\n        attributes: {\n          target: '_blank',\n          rel: 'noopener noreferrer'\n        }\n      });\n    }\n\n    automaticDecorators.add(automaticDecoratorDefinitions);\n\n    if (automaticDecorators.length) {\n      editor.conversion.for('downcast').add(automaticDecorators.getDispatcher());\n    }\n  }\n  /**\n   * Processes an array of configured {@link module:link/link~LinkDecoratorManualDefinition manual decorators},\n   * transforms them into {@link module:link/utils~ManualDecorator} instances and stores them in the\n   * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).\n   *\n   * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}\n   * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}\n   * with adequate model attributes.\n   *\n   * @private\n   * @param {Array.<module:link/link~LinkDecoratorManualDefinition>} manualDecoratorDefinitions\n   */\n\n\n  _enableManualDecorators(manualDecoratorDefinitions) {\n    if (!manualDecoratorDefinitions.length) {\n      return;\n    }\n\n    const editor = this.editor;\n    const command = editor.commands.get('link');\n    const manualDecorators = command.manualDecorators;\n    manualDecoratorDefinitions.forEach(decorator => {\n      editor.model.schema.extend('$text', {\n        allowAttributes: decorator.id\n      }); // Keeps reference to manual decorator to decode its name to attributes during downcast.\n\n      decorator = new ManualDecorator(decorator);\n      manualDecorators.add(decorator);\n      editor.conversion.for('downcast').attributeToElement({\n        model: decorator.id,\n        view: (manualDecoratorName, {\n          writer\n        }) => {\n          if (manualDecoratorName) {\n            const element = writer.createAttributeElement('a', decorator.attributes, {\n              priority: 5\n            });\n\n            if (decorator.classes) {\n              writer.addClass(decorator.classes, element);\n            }\n\n            for (const key in decorator.styles) {\n              writer.setStyle(key, decorator.styles[key], element);\n            }\n\n            writer.setCustomProperty('link', true, element);\n            return element;\n          }\n        }\n      });\n      editor.conversion.for('upcast').elementToAttribute({\n        view: {\n          name: 'a',\n          ...decorator._createPattern()\n        },\n        model: {\n          key: decorator.id\n        }\n      });\n    });\n  }\n  /**\n   * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and\n   * {@link module:engine/view/document~Document#event:click} to enable link following.\n   *\n   * @private\n   */\n\n\n  _enableLinkOpen() {\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const viewDocument = view.document;\n    const modelDocument = editor.model.document;\n    this.listenTo(viewDocument, 'click', (evt, data) => {\n      const shouldOpen = env.isMac ? data.domEvent.metaKey : data.domEvent.ctrlKey;\n\n      if (!shouldOpen) {\n        return;\n      }\n\n      let clickedElement = data.domTarget;\n\n      if (clickedElement.tagName.toLowerCase() != 'a') {\n        clickedElement = clickedElement.closest('a');\n      }\n\n      if (!clickedElement) {\n        return;\n      }\n\n      const url = clickedElement.getAttribute('href');\n\n      if (!url) {\n        return;\n      }\n\n      evt.stop();\n      data.preventDefault();\n      openLink(url);\n    }, {\n      context: '$capture'\n    });\n    this.listenTo(viewDocument, 'enter', (evt, data) => {\n      const selection = modelDocument.selection;\n      const selectedElement = selection.getSelectedElement();\n      const url = selectedElement ? selectedElement.getAttribute('linkHref') : selection.getAttribute('linkHref');\n      const shouldOpen = url && data.domEvent.altKey;\n\n      if (!shouldOpen) {\n        return;\n      }\n\n      evt.stop();\n      openLink(url);\n    }, {\n      context: 'a'\n    });\n  }\n  /**\n   * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model\n   * selection attributes if the selection is at the end of a link after inserting the content.\n   *\n   * The purpose of this action is to improve the overall UX because the user is no longer \"trapped\" by the\n   * `linkHref` attribute of the selection and they can type a \"clean\" (`linkHref`–less) text right away.\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/6053.\n   *\n   * @private\n   */\n\n\n  _enableInsertContentSelectionAttributesFixer() {\n    const editor = this.editor;\n    const model = editor.model;\n    const selection = model.document.selection;\n    this.listenTo(model, 'insertContent', () => {\n      const nodeBefore = selection.anchor.nodeBefore;\n      const nodeAfter = selection.anchor.nodeAfter; // NOTE: ↰ and ↱ represent the gravity of the selection.\n      // The only truly valid case is:\n      //\n      //\t\t                                 ↰\n      //\t\t...<$text linkHref=\"foo\">INSERTED[]</$text>\n      //\n      // If the selection is not \"trapped\" by the `linkHref` attribute after inserting, there's nothing\n      // to fix there.\n\n      if (!selection.hasAttribute('linkHref')) {\n        return;\n      } // Filter out the following case where a link with the same href (e.g. <a href=\"foo\">INSERTED</a>) is inserted\n      // in the middle of an existing link:\n      //\n      // Before insertion:\n      //\t\t                       ↰\n      //\t\t<$text linkHref=\"foo\">l[]ink</$text>\n      //\n      // Expected after insertion:\n      //\t\t                               ↰\n      //\t\t<$text linkHref=\"foo\">lINSERTED[]ink</$text>\n      //\n\n\n      if (!nodeBefore) {\n        return;\n      } // Filter out the following case where the selection has the \"linkHref\" attribute because the\n      // gravity is overridden and some text with another attribute (e.g. <b>INSERTED</b>) is inserted:\n      //\n      // Before insertion:\n      //\n      //\t\t                       ↱\n      //\t\t<$text linkHref=\"foo\">[]link</$text>\n      //\n      // Expected after insertion:\n      //\n      //\t\t                                                          ↱\n      //\t\t<$text bold=\"true\">INSERTED</$text><$text linkHref=\"foo\">[]link</$text>\n      //\n\n\n      if (!nodeBefore.hasAttribute('linkHref')) {\n        return;\n      } // Filter out the following case where a link is a inserted in the middle (or before) another link\n      // (different URLs, so they will not merge). In this (let's say weird) case, we can leave the selection\n      // attributes as they are because the user will end up writing in one link or another anyway.\n      //\n      // Before insertion:\n      //\n      //\t\t                       ↰\n      //\t\t<$text linkHref=\"foo\">l[]ink</$text>\n      //\n      // Expected after insertion:\n      //\n      //\t\t                                                             ↰\n      //\t\t<$text linkHref=\"foo\">l</$text><$text linkHref=\"bar\">INSERTED[]</$text><$text linkHref=\"foo\">ink</$text>\n      //\n\n\n      if (nodeAfter && nodeAfter.hasAttribute('linkHref')) {\n        return;\n      }\n\n      model.change(writer => {\n        removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));\n      });\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and\n   * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a link node\n   * if clicked at the beginning/ending of the link.\n   *\n   * The purpose of this action is to allow typing around the link node directly after a click.\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/1016.\n   *\n   * @private\n   */\n\n\n  _enableClickingAfterLink() {\n    const editor = this.editor;\n    const model = editor.model;\n    editor.editing.view.addObserver(MouseObserver);\n    let clicked = false; // Detect the click.\n\n    this.listenTo(editor.editing.view.document, 'mousedown', () => {\n      clicked = true;\n    }); // When the selection has changed...\n\n    this.listenTo(editor.editing.view.document, 'selectionChange', () => {\n      if (!clicked) {\n        return;\n      } // ...and it was caused by the click...\n\n\n      clicked = false;\n      const selection = model.document.selection; // ...and no text is selected...\n\n      if (!selection.isCollapsed) {\n        return;\n      } // ...and clicked text is the link...\n\n\n      if (!selection.hasAttribute('linkHref')) {\n        return;\n      }\n\n      const position = selection.getFirstPosition();\n      const linkRange = findAttributeRange(position, 'linkHref', selection.getAttribute('linkHref'), model); // ...check whether clicked start/end boundary of the link.\n      // If so, remove the `linkHref` attribute.\n\n      if (position.isTouching(linkRange.start) || position.isTouching(linkRange.end)) {\n        model.change(writer => {\n          removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));\n        });\n      }\n    });\n  }\n  /**\n   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and {@link module:engine/model/model~Model#insertContent}\n   * and checks whether typing over the link. If so, attributes of removed text are preserved and applied to the inserted text.\n   *\n   * The purpose of this action is to allow modifying a text without loosing the `linkHref` attribute (and other).\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/4762.\n   *\n   * @private\n   */\n\n\n  _enableTypingOverLink() {\n    const editor = this.editor;\n    const view = editor.editing.view; // Selection attributes when started typing over the link.\n\n    let selectionAttributes; // Whether pressed `Backspace` or `Delete`. If so, attributes should not be preserved.\n\n    let deletedContent; // Detect pressing `Backspace` / `Delete`.\n\n    this.listenTo(view.document, 'delete', () => {\n      deletedContent = true;\n    }, {\n      priority: 'high'\n    }); // Listening to `model#deleteContent` allows detecting whether selected content was a link.\n    // If so, before removing the element, we will copy its attributes.\n\n    this.listenTo(editor.model, 'deleteContent', () => {\n      const selection = editor.model.document.selection; // Copy attributes only if anything is selected.\n\n      if (selection.isCollapsed) {\n        return;\n      } // When the content was deleted, do not preserve attributes.\n\n\n      if (deletedContent) {\n        deletedContent = false;\n        return;\n      } // Enabled only when typing.\n\n\n      if (!isTyping(editor)) {\n        return;\n      }\n\n      if (shouldCopyAttributes(editor.model)) {\n        selectionAttributes = selection.getAttributes();\n      }\n    }, {\n      priority: 'high'\n    }); // Listening to `model#insertContent` allows detecting the content insertion.\n    // We want to apply attributes that were removed while typing over the link.\n\n    this.listenTo(editor.model, 'insertContent', (evt, [element]) => {\n      deletedContent = false; // Enabled only when typing.\n\n      if (!isTyping(editor)) {\n        return;\n      }\n\n      if (!selectionAttributes) {\n        return;\n      }\n\n      editor.model.change(writer => {\n        for (const [attribute, value] of selectionAttributes) {\n          writer.setAttribute(attribute, value, element);\n        }\n      });\n      selectionAttributes = null;\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether\n   * removing a content right after the \"linkHref\" attribute.\n   *\n   * If so, the selection should not preserve the `linkHref` attribute. However, if\n   * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and\n   * the selection has the \"linkHref\" attribute due to overriden gravity (at the end), the `linkHref` attribute should stay untouched.\n   *\n   * The purpose of this action is to allow removing the link text and keep the selection outside the link.\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/7521.\n   *\n   * @private\n   */\n\n\n  _handleDeleteContentAfterLink() {\n    const editor = this.editor;\n    const model = editor.model;\n    const selection = model.document.selection;\n    const view = editor.editing.view; // A flag whether attributes `linkHref` attribute should be preserved.\n\n    let shouldPreserveAttributes = false; // A flag whether the `Backspace` key was pressed.\n\n    let hasBackspacePressed = false; // Detect pressing `Backspace`.\n\n    this.listenTo(view.document, 'delete', (evt, data) => {\n      hasBackspacePressed = data.domEvent.keyCode === keyCodes.backspace;\n    }, {\n      priority: 'high'\n    }); // Before removing the content, check whether the selection is inside a link or at the end of link but with 2-SCM enabled.\n    // If so, we want to preserve link attributes.\n\n    this.listenTo(model, 'deleteContent', () => {\n      // Reset the state.\n      shouldPreserveAttributes = false;\n      const position = selection.getFirstPosition();\n      const linkHref = selection.getAttribute('linkHref');\n\n      if (!linkHref) {\n        return;\n      }\n\n      const linkRange = findAttributeRange(position, 'linkHref', linkHref, model); // Preserve `linkHref` attribute if the selection is in the middle of the link or\n      // the selection is at the end of the link and 2-SCM is activated.\n\n      shouldPreserveAttributes = linkRange.containsPosition(position) || linkRange.end.isEqual(position);\n    }, {\n      priority: 'high'\n    }); // After removing the content, check whether the current selection should preserve the `linkHref` attribute.\n\n    this.listenTo(model, 'deleteContent', () => {\n      // If didn't press `Backspace`.\n      if (!hasBackspacePressed) {\n        return;\n      }\n\n      hasBackspacePressed = false; // Disable the mechanism if inside a link (`<$text url=\"foo\">F[]oo</$text>` or <$text url=\"foo\">Foo[]</$text>`).\n\n      if (shouldPreserveAttributes) {\n        return;\n      } // Use `model.enqueueChange()` in order to execute the callback at the end of the changes process.\n\n\n      editor.model.enqueueChange(writer => {\n        removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));\n      });\n    }, {\n      priority: 'low'\n    });\n  }\n\n} // Make the selection free of link-related model attributes.\n// All link-related model attributes start with \"link\". That includes not only \"linkHref\"\n// but also all decorator attributes (they have dynamic names), or even custom plugins.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {Array.<String>} linkAttributes\n\nfunction removeLinkAttributesFromSelection(writer, linkAttributes) {\n  writer.removeSelectionAttribute('linkHref');\n\n  for (const attribute of linkAttributes) {\n    writer.removeSelectionAttribute(attribute);\n  }\n} // Checks whether selection's attributes should be copied to the new inserted text.\n//\n// @param {module:engine/model/model~Model} model\n// @returns {Boolean}\n\n\nfunction shouldCopyAttributes(model) {\n  const selection = model.document.selection;\n  const firstPosition = selection.getFirstPosition();\n  const lastPosition = selection.getLastPosition();\n  const nodeAtFirstPosition = firstPosition.nodeAfter; // The text link node does not exist...\n\n  if (!nodeAtFirstPosition) {\n    return false;\n  } // ...or it isn't the text node...\n\n\n  if (!nodeAtFirstPosition.is('$text')) {\n    return false;\n  } // ...or isn't the link.\n\n\n  if (!nodeAtFirstPosition.hasAttribute('linkHref')) {\n    return false;\n  } // `textNode` = the position is inside the link element.\n  // `nodeBefore` = the position is at the end of the link element.\n\n\n  const nodeAtLastPosition = lastPosition.textNode || lastPosition.nodeBefore; // If both references the same node selection contains a single text node.\n\n  if (nodeAtFirstPosition === nodeAtLastPosition) {\n    return true;\n  } // If nodes are not equal, maybe the link nodes has defined additional attributes inside.\n  // First, we need to find the entire link range.\n\n\n  const linkRange = findAttributeRange(firstPosition, 'linkHref', nodeAtFirstPosition.getAttribute('linkHref'), model); // Then we can check whether selected range is inside the found link range. If so, attributes should be preserved.\n\n  return linkRange.containsRange(model.createRange(firstPosition, lastPosition), true);\n} // Checks whether provided changes were caused by typing.\n//\n// @params {module:core/editor/editor~Editor} editor\n// @returns {Boolean}\n\n\nfunction isTyping(editor) {\n  const input = editor.plugins.get('Input');\n  return input.isInput(editor.model.change(writer => writer.batch));\n} // Returns an array containing names of the attributes allowed on `$text` that describes the link item.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Array.<String>}\n\n\nfunction getLinkAttributesAllowedOnText(schema) {\n  const textAttributes = schema.getDefinition('$text').allowAttributes;\n  return textAttributes.filter(attribute => attribute.startsWith('link'));\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-link/src/linkediting.js"],"names":["Plugin","MouseObserver","Input","TwoStepCaretMovement","inlineHighlight","findAttributeRange","ClipboardPipeline","keyCodes","env","LinkCommand","UnlinkCommand","ManualDecorator","createLinkElement","ensureSafeUrl","getLocalizedDecorators","normalizeDecorators","openLink","HIGHLIGHT_CLASS","DECORATOR_AUTOMATIC","DECORATOR_MANUAL","EXTERNAL_LINKS_REGEXP","LinkEditing","pluginName","requires","constructor","editor","config","define","addTargetToExternalLinks","init","model","schema","extend","allowAttributes","conversion","for","attributeToElement","view","href","conversionApi","elementToAttribute","name","attributes","key","value","viewElement","getAttribute","commands","add","linkDecorators","t","get","_enableAutomaticDecorators","filter","item","mode","_enableManualDecorators","twoStepCaretMovementPlugin","plugins","registerAttribute","_enableLinkOpen","_enableInsertContentSelectionAttributesFixer","_enableClickingAfterLink","_enableTypingOverLink","_handleDeleteContentAfterLink","automaticDecoratorDefinitions","command","automaticDecorators","id","callback","url","test","target","rel","length","getDispatcher","manualDecoratorDefinitions","manualDecorators","forEach","decorator","manualDecoratorName","writer","element","createAttributeElement","priority","classes","addClass","styles","setStyle","setCustomProperty","_createPattern","editing","viewDocument","document","modelDocument","listenTo","evt","data","shouldOpen","isMac","domEvent","metaKey","ctrlKey","clickedElement","domTarget","tagName","toLowerCase","closest","stop","preventDefault","context","selection","selectedElement","getSelectedElement","altKey","nodeBefore","anchor","nodeAfter","hasAttribute","change","removeLinkAttributesFromSelection","getLinkAttributesAllowedOnText","addObserver","clicked","isCollapsed","position","getFirstPosition","linkRange","isTouching","start","end","selectionAttributes","deletedContent","isTyping","shouldCopyAttributes","getAttributes","attribute","setAttribute","shouldPreserveAttributes","hasBackspacePressed","keyCode","backspace","linkHref","containsPosition","isEqual","enqueueChange","linkAttributes","removeSelectionAttribute","firstPosition","lastPosition","getLastPosition","nodeAtFirstPosition","is","nodeAtLastPosition","textNode","containsRange","createRange","input","isInput","batch","textAttributes","getDefinition","startsWith"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,MAAT,QAAuB,oBAAvB;AACA,SAASC,aAAT,QAA8B,sBAA9B;AACA,SAASC,KAAT,EAAgBC,oBAAhB,EAAsCC,eAAtC,EAAuDC,kBAAvD,QAAiF,sBAAjF;AACA,SAASC,iBAAT,QAAkC,yBAAlC;AACA,SAASC,QAAT,EAAmBC,GAAnB,QAA8B,qBAA9B;AAEA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,eAAP,MAA4B,yBAA5B;AACA,SAASC,iBAAT,EAA4BC,aAA5B,EAA2CC,sBAA3C,EAAmEC,mBAAnE,EAAwFC,QAAxF,QAAwG,SAAxG;AAEA,OAAO,mBAAP;AAEA,MAAMC,eAAe,GAAG,kBAAxB;AACA,MAAMC,mBAAmB,GAAG,WAA5B;AACA,MAAMC,gBAAgB,GAAG,QAAzB;AACA,MAAMC,qBAAqB,GAAG,iBAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,WAAN,SAA0BrB,MAA1B,CAAiC;AAC/C;AACD;AACA;AACsB,aAAVsB,UAAU,GAAG;AACvB,WAAO,aAAP;AACA;AAED;AACD;AACA;;;AACoB,aAARC,QAAQ,GAAG;AACrB;AACA,WAAO,CAAEpB,oBAAF,EAAwBD,KAAxB,EAA+BI,iBAA/B,CAAP;AACA;AAED;AACD;AACA;;;AACCkB,EAAAA,WAAW,CAAEC,MAAF,EAAW;AACrB,UAAOA,MAAP;AAEAA,IAAAA,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAsB,MAAtB,EAA8B;AAC7BC,MAAAA,wBAAwB,EAAE;AADG,KAA9B;AAGA;AAED;AACD;AACA;;;AACCC,EAAAA,IAAI,GAAG;AACN,UAAMJ,MAAM,GAAG,KAAKA,MAApB,CADM,CAGN;;AACAA,IAAAA,MAAM,CAACK,KAAP,CAAaC,MAAb,CAAoBC,MAApB,CAA4B,OAA5B,EAAqC;AAAEC,MAAAA,eAAe,EAAE;AAAnB,KAArC;AAEAR,IAAAA,MAAM,CAACS,UAAP,CAAkBC,GAAlB,CAAuB,cAAvB,EACEC,kBADF,CACsB;AAAEN,MAAAA,KAAK,EAAE,UAAT;AAAqBO,MAAAA,IAAI,EAAEzB;AAA3B,KADtB;AAGAa,IAAAA,MAAM,CAACS,UAAP,CAAkBC,GAAlB,CAAuB,iBAAvB,EACEC,kBADF,CACsB;AAAEN,MAAAA,KAAK,EAAE,UAAT;AAAqBO,MAAAA,IAAI,EAAE,CAAEC,IAAF,EAAQC,aAAR,KAA2B;AAC1E,eAAO3B,iBAAiB,CAAEC,aAAa,CAAEyB,IAAF,CAAf,EAAyBC,aAAzB,CAAxB;AACA;AAFoB,KADtB;AAKAd,IAAAA,MAAM,CAACS,UAAP,CAAkBC,GAAlB,CAAuB,QAAvB,EACEK,kBADF,CACsB;AACpBH,MAAAA,IAAI,EAAE;AACLI,QAAAA,IAAI,EAAE,GADD;AAELC,QAAAA,UAAU,EAAE;AACXJ,UAAAA,IAAI,EAAE;AADK;AAFP,OADc;AAOpBR,MAAAA,KAAK,EAAE;AACNa,QAAAA,GAAG,EAAE,UADC;AAENC,QAAAA,KAAK,EAAEC,WAAW,IAAIA,WAAW,CAACC,YAAZ,CAA0B,MAA1B;AAFhB;AAPa,KADtB,EAdM,CA4BN;;AACArB,IAAAA,MAAM,CAACsB,QAAP,CAAgBC,GAAhB,CAAqB,MAArB,EAA6B,IAAIvC,WAAJ,CAAiBgB,MAAjB,CAA7B;AACAA,IAAAA,MAAM,CAACsB,QAAP,CAAgBC,GAAhB,CAAqB,QAArB,EAA+B,IAAItC,aAAJ,CAAmBe,MAAnB,CAA/B;AAEA,UAAMwB,cAAc,GAAGnC,sBAAsB,CAAEW,MAAM,CAACyB,CAAT,EAAYnC,mBAAmB,CAAEU,MAAM,CAACC,MAAP,CAAcyB,GAAd,CAAmB,iBAAnB,CAAF,CAA/B,CAA7C;;AAEA,SAAKC,0BAAL,CAAiCH,cAAc,CAACI,MAAf,CAAuBC,IAAI,IAAIA,IAAI,CAACC,IAAL,KAAcrC,mBAA7C,CAAjC;;AACA,SAAKsC,uBAAL,CAA8BP,cAAc,CAACI,MAAf,CAAuBC,IAAI,IAAIA,IAAI,CAACC,IAAL,KAAcpC,gBAA7C,CAA9B,EAnCM,CAqCN;;;AACA,UAAMsC,0BAA0B,GAAGhC,MAAM,CAACiC,OAAP,CAAeP,GAAf,CAAoBhD,oBAApB,CAAnC;AACAsD,IAAAA,0BAA0B,CAACE,iBAA3B,CAA8C,UAA9C,EAvCM,CAyCN;;AACAvD,IAAAA,eAAe,CAAEqB,MAAF,EAAU,UAAV,EAAsB,GAAtB,EAA2BR,eAA3B,CAAf,CA1CM,CA4CN;;AACA,SAAK2C,eAAL,GA7CM,CA+CN;;;AACA,SAAKC,4CAAL,GAhDM,CAkDN;;;AACA,SAAKC,wBAAL,GAnDM,CAqDN;;;AACA,SAAKC,qBAAL,GAtDM,CAwDN;;;AACA,SAAKC,6BAAL;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCZ,EAAAA,0BAA0B,CAAEa,6BAAF,EAAkC;AAC3D,UAAMxC,MAAM,GAAG,KAAKA,MAApB,CAD2D,CAE3D;AACA;;AACA,UAAMyC,OAAO,GAAGzC,MAAM,CAACsB,QAAP,CAAgBI,GAAhB,CAAqB,MAArB,CAAhB;AACA,UAAMgB,mBAAmB,GAAGD,OAAO,CAACC,mBAApC,CAL2D,CAO3D;;AACA,QAAK1C,MAAM,CAACC,MAAP,CAAcyB,GAAd,CAAmB,+BAAnB,CAAL,EAA4D;AAC3DgB,MAAAA,mBAAmB,CAACnB,GAApB,CAAyB;AACxBoB,QAAAA,EAAE,EAAE,gBADoB;AAExBb,QAAAA,IAAI,EAAErC,mBAFkB;AAGxBmD,QAAAA,QAAQ,EAAEC,GAAG,IAAIlD,qBAAqB,CAACmD,IAAtB,CAA4BD,GAA5B,CAHO;AAIxB5B,QAAAA,UAAU,EAAE;AACX8B,UAAAA,MAAM,EAAE,QADG;AAEXC,UAAAA,GAAG,EAAE;AAFM;AAJY,OAAzB;AASA;;AAEDN,IAAAA,mBAAmB,CAACnB,GAApB,CAAyBiB,6BAAzB;;AAEA,QAAKE,mBAAmB,CAACO,MAAzB,EAAkC;AACjCjD,MAAAA,MAAM,CAACS,UAAP,CAAkBC,GAAlB,CAAuB,UAAvB,EAAoCa,GAApC,CAAyCmB,mBAAmB,CAACQ,aAApB,EAAzC;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCnB,EAAAA,uBAAuB,CAAEoB,0BAAF,EAA+B;AACrD,QAAK,CAACA,0BAA0B,CAACF,MAAjC,EAA0C;AACzC;AACA;;AAED,UAAMjD,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMyC,OAAO,GAAGzC,MAAM,CAACsB,QAAP,CAAgBI,GAAhB,CAAqB,MAArB,CAAhB;AACA,UAAM0B,gBAAgB,GAAGX,OAAO,CAACW,gBAAjC;AAEAD,IAAAA,0BAA0B,CAACE,OAA3B,CAAoCC,SAAS,IAAI;AAChDtD,MAAAA,MAAM,CAACK,KAAP,CAAaC,MAAb,CAAoBC,MAApB,CAA4B,OAA5B,EAAqC;AAAEC,QAAAA,eAAe,EAAE8C,SAAS,CAACX;AAA7B,OAArC,EADgD,CAGhD;;AACAW,MAAAA,SAAS,GAAG,IAAIpE,eAAJ,CAAqBoE,SAArB,CAAZ;AAEAF,MAAAA,gBAAgB,CAAC7B,GAAjB,CAAsB+B,SAAtB;AAEAtD,MAAAA,MAAM,CAACS,UAAP,CAAkBC,GAAlB,CAAuB,UAAvB,EAAoCC,kBAApC,CAAwD;AACvDN,QAAAA,KAAK,EAAEiD,SAAS,CAACX,EADsC;AAEvD/B,QAAAA,IAAI,EAAE,CAAE2C,mBAAF,EAAuB;AAAEC,UAAAA;AAAF,SAAvB,KAAuC;AAC5C,cAAKD,mBAAL,EAA2B;AAC1B,kBAAME,OAAO,GAAGD,MAAM,CAACE,sBAAP,CAA+B,GAA/B,EAAoCJ,SAAS,CAACrC,UAA9C,EAA0D;AAAE0C,cAAAA,QAAQ,EAAE;AAAZ,aAA1D,CAAhB;;AAEA,gBAAKL,SAAS,CAACM,OAAf,EAAyB;AACxBJ,cAAAA,MAAM,CAACK,QAAP,CAAiBP,SAAS,CAACM,OAA3B,EAAoCH,OAApC;AACA;;AAED,iBAAM,MAAMvC,GAAZ,IAAmBoC,SAAS,CAACQ,MAA7B,EAAsC;AACrCN,cAAAA,MAAM,CAACO,QAAP,CAAiB7C,GAAjB,EAAsBoC,SAAS,CAACQ,MAAV,CAAkB5C,GAAlB,CAAtB,EAA+CuC,OAA/C;AACA;;AAEDD,YAAAA,MAAM,CAACQ,iBAAP,CAA0B,MAA1B,EAAkC,IAAlC,EAAwCP,OAAxC;AAEA,mBAAOA,OAAP;AACA;AACD;AAlBsD,OAAxD;AAoBAzD,MAAAA,MAAM,CAACS,UAAP,CAAkBC,GAAlB,CAAuB,QAAvB,EAAkCK,kBAAlC,CAAsD;AACrDH,QAAAA,IAAI,EAAE;AACLI,UAAAA,IAAI,EAAE,GADD;AAEL,aAAGsC,SAAS,CAACW,cAAV;AAFE,SAD+C;AAKrD5D,QAAAA,KAAK,EAAE;AACNa,UAAAA,GAAG,EAAEoC,SAAS,CAACX;AADT;AAL8C,OAAtD;AASA,KArCD;AAsCA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCR,EAAAA,eAAe,GAAG;AACjB,UAAMnC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMY,IAAI,GAAGZ,MAAM,CAACkE,OAAP,CAAetD,IAA5B;AACA,UAAMuD,YAAY,GAAGvD,IAAI,CAACwD,QAA1B;AACA,UAAMC,aAAa,GAAGrE,MAAM,CAACK,KAAP,CAAa+D,QAAnC;AAEA,SAAKE,QAAL,CAAeH,YAAf,EAA6B,OAA7B,EAAsC,CAAEI,GAAF,EAAOC,IAAP,KAAiB;AACtD,YAAMC,UAAU,GAAG1F,GAAG,CAAC2F,KAAJ,GAAYF,IAAI,CAACG,QAAL,CAAcC,OAA1B,GAAoCJ,IAAI,CAACG,QAAL,CAAcE,OAArE;;AAEA,UAAK,CAACJ,UAAN,EAAmB;AAClB;AACA;;AAED,UAAIK,cAAc,GAAGN,IAAI,CAACO,SAA1B;;AAEA,UAAKD,cAAc,CAACE,OAAf,CAAuBC,WAAvB,MAAwC,GAA7C,EAAmD;AAClDH,QAAAA,cAAc,GAAGA,cAAc,CAACI,OAAf,CAAwB,GAAxB,CAAjB;AACA;;AAED,UAAK,CAACJ,cAAN,EAAuB;AACtB;AACA;;AAED,YAAMjC,GAAG,GAAGiC,cAAc,CAACzD,YAAf,CAA6B,MAA7B,CAAZ;;AAEA,UAAK,CAACwB,GAAN,EAAY;AACX;AACA;;AAED0B,MAAAA,GAAG,CAACY,IAAJ;AACAX,MAAAA,IAAI,CAACY,cAAL;AAEA7F,MAAAA,QAAQ,CAAEsD,GAAF,CAAR;AACA,KA3BD,EA2BG;AAAEwC,MAAAA,OAAO,EAAE;AAAX,KA3BH;AA6BA,SAAKf,QAAL,CAAeH,YAAf,EAA6B,OAA7B,EAAsC,CAAEI,GAAF,EAAOC,IAAP,KAAiB;AACtD,YAAMc,SAAS,GAAGjB,aAAa,CAACiB,SAAhC;AAEA,YAAMC,eAAe,GAAGD,SAAS,CAACE,kBAAV,EAAxB;AAEA,YAAM3C,GAAG,GAAG0C,eAAe,GAC1BA,eAAe,CAAClE,YAAhB,CAA8B,UAA9B,CAD0B,GAE1BiE,SAAS,CAACjE,YAAV,CAAwB,UAAxB,CAFD;AAIA,YAAMoD,UAAU,GAAG5B,GAAG,IAAI2B,IAAI,CAACG,QAAL,CAAcc,MAAxC;;AAEA,UAAK,CAAChB,UAAN,EAAmB;AAClB;AACA;;AAEDF,MAAAA,GAAG,CAACY,IAAJ;AAEA5F,MAAAA,QAAQ,CAAEsD,GAAF,CAAR;AACA,KAlBD,EAkBG;AAAEwC,MAAAA,OAAO,EAAE;AAAX,KAlBH;AAmBA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCjD,EAAAA,4CAA4C,GAAG;AAC9C,UAAMpC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMK,KAAK,GAAGL,MAAM,CAACK,KAArB;AACA,UAAMiF,SAAS,GAAGjF,KAAK,CAAC+D,QAAN,CAAekB,SAAjC;AAEA,SAAKhB,QAAL,CAAejE,KAAf,EAAsB,eAAtB,EAAuC,MAAM;AAC5C,YAAMqF,UAAU,GAAGJ,SAAS,CAACK,MAAV,CAAiBD,UAApC;AACA,YAAME,SAAS,GAAGN,SAAS,CAACK,MAAV,CAAiBC,SAAnC,CAF4C,CAI5C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAK,CAACN,SAAS,CAACO,YAAV,CAAwB,UAAxB,CAAN,EAA6C;AAC5C;AACA,OAf2C,CAiB5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAK,CAACH,UAAN,EAAmB;AAClB;AACA,OA9B2C,CAgC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAK,CAACA,UAAU,CAACG,YAAX,CAAyB,UAAzB,CAAN,EAA8C;AAC7C;AACA,OA/C2C,CAiD5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAKD,SAAS,IAAIA,SAAS,CAACC,YAAV,CAAwB,UAAxB,CAAlB,EAAyD;AACxD;AACA;;AAEDxF,MAAAA,KAAK,CAACyF,MAAN,CAActC,MAAM,IAAI;AACvBuC,QAAAA,iCAAiC,CAAEvC,MAAF,EAAUwC,8BAA8B,CAAE3F,KAAK,CAACC,MAAR,CAAxC,CAAjC;AACA,OAFD;AAGA,KAtED,EAsEG;AAAEqD,MAAAA,QAAQ,EAAE;AAAZ,KAtEH;AAuEA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCtB,EAAAA,wBAAwB,GAAG;AAC1B,UAAMrC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMK,KAAK,GAAGL,MAAM,CAACK,KAArB;AAEAL,IAAAA,MAAM,CAACkE,OAAP,CAAetD,IAAf,CAAoBqF,WAApB,CAAiCzH,aAAjC;AAEA,QAAI0H,OAAO,GAAG,KAAd,CAN0B,CAQ1B;;AACA,SAAK5B,QAAL,CAAetE,MAAM,CAACkE,OAAP,CAAetD,IAAf,CAAoBwD,QAAnC,EAA6C,WAA7C,EAA0D,MAAM;AAC/D8B,MAAAA,OAAO,GAAG,IAAV;AACA,KAFD,EAT0B,CAa1B;;AACA,SAAK5B,QAAL,CAAetE,MAAM,CAACkE,OAAP,CAAetD,IAAf,CAAoBwD,QAAnC,EAA6C,iBAA7C,EAAgE,MAAM;AACrE,UAAK,CAAC8B,OAAN,EAAgB;AACf;AACA,OAHoE,CAKrE;;;AACAA,MAAAA,OAAO,GAAG,KAAV;AAEA,YAAMZ,SAAS,GAAGjF,KAAK,CAAC+D,QAAN,CAAekB,SAAjC,CARqE,CAUrE;;AACA,UAAK,CAACA,SAAS,CAACa,WAAhB,EAA8B;AAC7B;AACA,OAboE,CAerE;;;AACA,UAAK,CAACb,SAAS,CAACO,YAAV,CAAwB,UAAxB,CAAN,EAA6C;AAC5C;AACA;;AAED,YAAMO,QAAQ,GAAGd,SAAS,CAACe,gBAAV,EAAjB;AACA,YAAMC,SAAS,GAAG1H,kBAAkB,CAAEwH,QAAF,EAAY,UAAZ,EAAwBd,SAAS,CAACjE,YAAV,CAAwB,UAAxB,CAAxB,EAA8DhB,KAA9D,CAApC,CArBqE,CAuBrE;AACA;;AACA,UAAK+F,QAAQ,CAACG,UAAT,CAAqBD,SAAS,CAACE,KAA/B,KAA0CJ,QAAQ,CAACG,UAAT,CAAqBD,SAAS,CAACG,GAA/B,CAA/C,EAAsF;AACrFpG,QAAAA,KAAK,CAACyF,MAAN,CAActC,MAAM,IAAI;AACvBuC,UAAAA,iCAAiC,CAAEvC,MAAF,EAAUwC,8BAA8B,CAAE3F,KAAK,CAACC,MAAR,CAAxC,CAAjC;AACA,SAFD;AAGA;AACD,KA9BD;AA+BA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCgC,EAAAA,qBAAqB,GAAG;AACvB,UAAMtC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMY,IAAI,GAAGZ,MAAM,CAACkE,OAAP,CAAetD,IAA5B,CAFuB,CAIvB;;AACA,QAAI8F,mBAAJ,CALuB,CAOvB;;AACA,QAAIC,cAAJ,CARuB,CAUvB;;AACA,SAAKrC,QAAL,CAAe1D,IAAI,CAACwD,QAApB,EAA8B,QAA9B,EAAwC,MAAM;AAC7CuC,MAAAA,cAAc,GAAG,IAAjB;AACA,KAFD,EAEG;AAAEhD,MAAAA,QAAQ,EAAE;AAAZ,KAFH,EAXuB,CAevB;AACA;;AACA,SAAKW,QAAL,CAAetE,MAAM,CAACK,KAAtB,EAA6B,eAA7B,EAA8C,MAAM;AACnD,YAAMiF,SAAS,GAAGtF,MAAM,CAACK,KAAP,CAAa+D,QAAb,CAAsBkB,SAAxC,CADmD,CAGnD;;AACA,UAAKA,SAAS,CAACa,WAAf,EAA6B;AAC5B;AACA,OANkD,CAQnD;;;AACA,UAAKQ,cAAL,EAAsB;AACrBA,QAAAA,cAAc,GAAG,KAAjB;AAEA;AACA,OAbkD,CAenD;;;AACA,UAAK,CAACC,QAAQ,CAAE5G,MAAF,CAAd,EAA2B;AAC1B;AACA;;AAED,UAAK6G,oBAAoB,CAAE7G,MAAM,CAACK,KAAT,CAAzB,EAA4C;AAC3CqG,QAAAA,mBAAmB,GAAGpB,SAAS,CAACwB,aAAV,EAAtB;AACA;AACD,KAvBD,EAuBG;AAAEnD,MAAAA,QAAQ,EAAE;AAAZ,KAvBH,EAjBuB,CA0CvB;AACA;;AACA,SAAKW,QAAL,CAAetE,MAAM,CAACK,KAAtB,EAA6B,eAA7B,EAA8C,CAAEkE,GAAF,EAAO,CAAEd,OAAF,CAAP,KAAwB;AACrEkD,MAAAA,cAAc,GAAG,KAAjB,CADqE,CAGrE;;AACA,UAAK,CAACC,QAAQ,CAAE5G,MAAF,CAAd,EAA2B;AAC1B;AACA;;AAED,UAAK,CAAC0G,mBAAN,EAA4B;AAC3B;AACA;;AAED1G,MAAAA,MAAM,CAACK,KAAP,CAAayF,MAAb,CAAqBtC,MAAM,IAAI;AAC9B,aAAM,MAAM,CAAEuD,SAAF,EAAa5F,KAAb,CAAZ,IAAoCuF,mBAApC,EAA0D;AACzDlD,UAAAA,MAAM,CAACwD,YAAP,CAAqBD,SAArB,EAAgC5F,KAAhC,EAAuCsC,OAAvC;AACA;AACD,OAJD;AAMAiD,MAAAA,mBAAmB,GAAG,IAAtB;AACA,KAnBD,EAmBG;AAAE/C,MAAAA,QAAQ,EAAE;AAAZ,KAnBH;AAoBA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCpB,EAAAA,6BAA6B,GAAG;AAC/B,UAAMvC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMK,KAAK,GAAGL,MAAM,CAACK,KAArB;AACA,UAAMiF,SAAS,GAAGjF,KAAK,CAAC+D,QAAN,CAAekB,SAAjC;AACA,UAAM1E,IAAI,GAAGZ,MAAM,CAACkE,OAAP,CAAetD,IAA5B,CAJ+B,CAM/B;;AACA,QAAIqG,wBAAwB,GAAG,KAA/B,CAP+B,CAS/B;;AACA,QAAIC,mBAAmB,GAAG,KAA1B,CAV+B,CAY/B;;AACA,SAAK5C,QAAL,CAAe1D,IAAI,CAACwD,QAApB,EAA8B,QAA9B,EAAwC,CAAEG,GAAF,EAAOC,IAAP,KAAiB;AACxD0C,MAAAA,mBAAmB,GAAG1C,IAAI,CAACG,QAAL,CAAcwC,OAAd,KAA0BrI,QAAQ,CAACsI,SAAzD;AACA,KAFD,EAEG;AAAEzD,MAAAA,QAAQ,EAAE;AAAZ,KAFH,EAb+B,CAiB/B;AACA;;AACA,SAAKW,QAAL,CAAejE,KAAf,EAAsB,eAAtB,EAAuC,MAAM;AAC5C;AACA4G,MAAAA,wBAAwB,GAAG,KAA3B;AAEA,YAAMb,QAAQ,GAAGd,SAAS,CAACe,gBAAV,EAAjB;AACA,YAAMgB,QAAQ,GAAG/B,SAAS,CAACjE,YAAV,CAAwB,UAAxB,CAAjB;;AAEA,UAAK,CAACgG,QAAN,EAAiB;AAChB;AACA;;AAED,YAAMf,SAAS,GAAG1H,kBAAkB,CAAEwH,QAAF,EAAY,UAAZ,EAAwBiB,QAAxB,EAAkChH,KAAlC,CAApC,CAX4C,CAa5C;AACA;;AACA4G,MAAAA,wBAAwB,GAAGX,SAAS,CAACgB,gBAAV,CAA4BlB,QAA5B,KAA0CE,SAAS,CAACG,GAAV,CAAcc,OAAd,CAAuBnB,QAAvB,CAArE;AACA,KAhBD,EAgBG;AAAEzC,MAAAA,QAAQ,EAAE;AAAZ,KAhBH,EAnB+B,CAqC/B;;AACA,SAAKW,QAAL,CAAejE,KAAf,EAAsB,eAAtB,EAAuC,MAAM;AAC5C;AACA,UAAK,CAAC6G,mBAAN,EAA4B;AAC3B;AACA;;AAEDA,MAAAA,mBAAmB,GAAG,KAAtB,CAN4C,CAQ5C;;AACA,UAAKD,wBAAL,EAAgC;AAC/B;AACA,OAX2C,CAa5C;;;AACAjH,MAAAA,MAAM,CAACK,KAAP,CAAamH,aAAb,CAA4BhE,MAAM,IAAI;AACrCuC,QAAAA,iCAAiC,CAAEvC,MAAF,EAAUwC,8BAA8B,CAAE3F,KAAK,CAACC,MAAR,CAAxC,CAAjC;AACA,OAFD;AAGA,KAjBD,EAiBG;AAAEqD,MAAAA,QAAQ,EAAE;AAAZ,KAjBH;AAkBA;;AAjiB8C,C,CAoiBhD;AACA;AACA;AACA;AACA;AACA;;AACA,SAASoC,iCAAT,CAA4CvC,MAA5C,EAAoDiE,cAApD,EAAqE;AACpEjE,EAAAA,MAAM,CAACkE,wBAAP,CAAiC,UAAjC;;AAEA,OAAM,MAAMX,SAAZ,IAAyBU,cAAzB,EAA0C;AACzCjE,IAAAA,MAAM,CAACkE,wBAAP,CAAiCX,SAAjC;AACA;AACD,C,CAED;AACA;AACA;AACA;;;AACA,SAASF,oBAAT,CAA+BxG,KAA/B,EAAuC;AACtC,QAAMiF,SAAS,GAAGjF,KAAK,CAAC+D,QAAN,CAAekB,SAAjC;AACA,QAAMqC,aAAa,GAAGrC,SAAS,CAACe,gBAAV,EAAtB;AACA,QAAMuB,YAAY,GAAGtC,SAAS,CAACuC,eAAV,EAArB;AACA,QAAMC,mBAAmB,GAAGH,aAAa,CAAC/B,SAA1C,CAJsC,CAMtC;;AACA,MAAK,CAACkC,mBAAN,EAA4B;AAC3B,WAAO,KAAP;AACA,GATqC,CAWtC;;;AACA,MAAK,CAACA,mBAAmB,CAACC,EAApB,CAAwB,OAAxB,CAAN,EAA0C;AACzC,WAAO,KAAP;AACA,GAdqC,CAgBtC;;;AACA,MAAK,CAACD,mBAAmB,CAACjC,YAApB,CAAkC,UAAlC,CAAN,EAAuD;AACtD,WAAO,KAAP;AACA,GAnBqC,CAqBtC;AACA;;;AACA,QAAMmC,kBAAkB,GAAGJ,YAAY,CAACK,QAAb,IAAyBL,YAAY,CAAClC,UAAjE,CAvBsC,CAyBtC;;AACA,MAAKoC,mBAAmB,KAAKE,kBAA7B,EAAkD;AACjD,WAAO,IAAP;AACA,GA5BqC,CA8BtC;AACA;;;AACA,QAAM1B,SAAS,GAAG1H,kBAAkB,CAAE+I,aAAF,EAAiB,UAAjB,EAA6BG,mBAAmB,CAACzG,YAApB,CAAkC,UAAlC,CAA7B,EAA6EhB,KAA7E,CAApC,CAhCsC,CAkCtC;;AACA,SAAOiG,SAAS,CAAC4B,aAAV,CAAyB7H,KAAK,CAAC8H,WAAN,CAAmBR,aAAnB,EAAkCC,YAAlC,CAAzB,EAA2E,IAA3E,CAAP;AACA,C,CAED;AACA;AACA;AACA;;;AACA,SAAShB,QAAT,CAAmB5G,MAAnB,EAA4B;AAC3B,QAAMoI,KAAK,GAAGpI,MAAM,CAACiC,OAAP,CAAeP,GAAf,CAAoB,OAApB,CAAd;AAEA,SAAO0G,KAAK,CAACC,OAAN,CAAerI,MAAM,CAACK,KAAP,CAAayF,MAAb,CAAqBtC,MAAM,IAAIA,MAAM,CAAC8E,KAAtC,CAAf,CAAP;AACA,C,CAED;AACA;AACA;AACA;;;AACA,SAAStC,8BAAT,CAAyC1F,MAAzC,EAAkD;AACjD,QAAMiI,cAAc,GAAGjI,MAAM,CAACkI,aAAP,CAAsB,OAAtB,EAAgChI,eAAvD;AAEA,SAAO+H,cAAc,CAAC3G,MAAf,CAAuBmF,SAAS,IAAIA,SAAS,CAAC0B,UAAV,CAAsB,MAAtB,CAApC,CAAP;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { MouseObserver } from 'ckeditor5/src/engine';\nimport { Input, TwoStepCaretMovement, inlineHighlight, findAttributeRange } from 'ckeditor5/src/typing';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { keyCodes, env } from 'ckeditor5/src/utils';\n\nimport LinkCommand from './linkcommand';\nimport UnlinkCommand from './unlinkcommand';\nimport ManualDecorator from './utils/manualdecorator';\nimport { createLinkElement, ensureSafeUrl, getLocalizedDecorators, normalizeDecorators, openLink } from './utils';\n\nimport '../theme/link.css';\n\nconst HIGHLIGHT_CLASS = 'ck-link_selected';\nconst DECORATOR_AUTOMATIC = 'automatic';\nconst DECORATOR_MANUAL = 'manual';\nconst EXTERNAL_LINKS_REGEXP = /^(https?:)?\\/\\//;\n\n/**\n * The link engine feature.\n *\n * It introduces the `linkHref=\"url\"` attribute in the model which renders to the view as a `<a href=\"url\">` element\n * as well as `'link'` and `'unlink'` commands.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class LinkEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'LinkEditing';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\t// Clipboard is required for handling cut and paste events while typing over the link.\n\t\treturn [ TwoStepCaretMovement, Input, ClipboardPipeline ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\teditor.config.define( 'link', {\n\t\t\taddTargetToExternalLinks: false\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// Allow link attribute on all inline nodes.\n\t\teditor.model.schema.extend( '$text', { allowAttributes: 'linkHref' } );\n\n\t\teditor.conversion.for( 'dataDowncast' )\n\t\t\t.attributeToElement( { model: 'linkHref', view: createLinkElement } );\n\n\t\teditor.conversion.for( 'editingDowncast' )\n\t\t\t.attributeToElement( { model: 'linkHref', view: ( href, conversionApi ) => {\n\t\t\t\treturn createLinkElement( ensureSafeUrl( href ), conversionApi );\n\t\t\t} } );\n\n\t\teditor.conversion.for( 'upcast' )\n\t\t\t.elementToAttribute( {\n\t\t\t\tview: {\n\t\t\t\t\tname: 'a',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\thref: true\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tmodel: {\n\t\t\t\t\tkey: 'linkHref',\n\t\t\t\t\tvalue: viewElement => viewElement.getAttribute( 'href' )\n\t\t\t\t}\n\t\t\t} );\n\n\t\t// Create linking commands.\n\t\teditor.commands.add( 'link', new LinkCommand( editor ) );\n\t\teditor.commands.add( 'unlink', new UnlinkCommand( editor ) );\n\n\t\tconst linkDecorators = getLocalizedDecorators( editor.t, normalizeDecorators( editor.config.get( 'link.decorators' ) ) );\n\n\t\tthis._enableAutomaticDecorators( linkDecorators.filter( item => item.mode === DECORATOR_AUTOMATIC ) );\n\t\tthis._enableManualDecorators( linkDecorators.filter( item => item.mode === DECORATOR_MANUAL ) );\n\n\t\t// Enable two-step caret movement for `linkHref` attribute.\n\t\tconst twoStepCaretMovementPlugin = editor.plugins.get( TwoStepCaretMovement );\n\t\ttwoStepCaretMovementPlugin.registerAttribute( 'linkHref' );\n\n\t\t// Setup highlight over selected link.\n\t\tinlineHighlight( editor, 'linkHref', 'a', HIGHLIGHT_CLASS );\n\n\t\t// Handle link following by CTRL+click or ALT+ENTER\n\t\tthis._enableLinkOpen();\n\n\t\t// Change the attributes of the selection in certain situations after the link was inserted into the document.\n\t\tthis._enableInsertContentSelectionAttributesFixer();\n\n\t\t// Handle a click at the beginning/end of a link element.\n\t\tthis._enableClickingAfterLink();\n\n\t\t// Handle typing over the link.\n\t\tthis._enableTypingOverLink();\n\n\t\t// Handle removing the content after the link element.\n\t\tthis._handleDeleteContentAfterLink();\n\t}\n\n\t/**\n\t * Processes an array of configured {@link module:link/link~LinkDecoratorAutomaticDefinition automatic decorators}\n\t * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}\n\t * for each one of them. Downcast dispatchers are obtained using the\n\t * {@link module:link/utils~AutomaticDecorators#getDispatcher} method.\n\t *\n\t * **Note**: This method also activates the automatic external link decorator if enabled with\n\t * {@link module:link/link~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.\n\t *\n\t * @private\n\t * @param {Array.<module:link/link~LinkDecoratorAutomaticDefinition>} automaticDecoratorDefinitions\n\t */\n\t_enableAutomaticDecorators( automaticDecoratorDefinitions ) {\n\t\tconst editor = this.editor;\n\t\t// Store automatic decorators in the command instance as we do the same with manual decorators.\n\t\t// Thanks to that, `LinkImageEditing` plugin can re-use the same definitions.\n\t\tconst command = editor.commands.get( 'link' );\n\t\tconst automaticDecorators = command.automaticDecorators;\n\n\t\t// Adds a default decorator for external links.\n\t\tif ( editor.config.get( 'link.addTargetToExternalLinks' ) ) {\n\t\t\tautomaticDecorators.add( {\n\t\t\t\tid: 'linkIsExternal',\n\t\t\t\tmode: DECORATOR_AUTOMATIC,\n\t\t\t\tcallback: url => EXTERNAL_LINKS_REGEXP.test( url ),\n\t\t\t\tattributes: {\n\t\t\t\t\ttarget: '_blank',\n\t\t\t\t\trel: 'noopener noreferrer'\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tautomaticDecorators.add( automaticDecoratorDefinitions );\n\n\t\tif ( automaticDecorators.length ) {\n\t\t\teditor.conversion.for( 'downcast' ).add( automaticDecorators.getDispatcher() );\n\t\t}\n\t}\n\n\t/**\n\t * Processes an array of configured {@link module:link/link~LinkDecoratorManualDefinition manual decorators},\n\t * transforms them into {@link module:link/utils~ManualDecorator} instances and stores them in the\n\t * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).\n\t *\n\t * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}\n\t * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}\n\t * with adequate model attributes.\n\t *\n\t * @private\n\t * @param {Array.<module:link/link~LinkDecoratorManualDefinition>} manualDecoratorDefinitions\n\t */\n\t_enableManualDecorators( manualDecoratorDefinitions ) {\n\t\tif ( !manualDecoratorDefinitions.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst editor = this.editor;\n\t\tconst command = editor.commands.get( 'link' );\n\t\tconst manualDecorators = command.manualDecorators;\n\n\t\tmanualDecoratorDefinitions.forEach( decorator => {\n\t\t\teditor.model.schema.extend( '$text', { allowAttributes: decorator.id } );\n\n\t\t\t// Keeps reference to manual decorator to decode its name to attributes during downcast.\n\t\t\tdecorator = new ManualDecorator( decorator );\n\n\t\t\tmanualDecorators.add( decorator );\n\n\t\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t\t\t\tmodel: decorator.id,\n\t\t\t\tview: ( manualDecoratorName, { writer } ) => {\n\t\t\t\t\tif ( manualDecoratorName ) {\n\t\t\t\t\t\tconst element = writer.createAttributeElement( 'a', decorator.attributes, { priority: 5 } );\n\n\t\t\t\t\t\tif ( decorator.classes ) {\n\t\t\t\t\t\t\twriter.addClass( decorator.classes, element );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( const key in decorator.styles ) {\n\t\t\t\t\t\t\twriter.setStyle( key, decorator.styles[ key ], element );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twriter.setCustomProperty( 'link', true, element );\n\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\t\t\t\t} } );\n\n\t\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t\t\t\tview: {\n\t\t\t\t\tname: 'a',\n\t\t\t\t\t...decorator._createPattern()\n\t\t\t\t},\n\t\t\t\tmodel: {\n\t\t\t\t\tkey: decorator.id\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and\n\t * {@link module:engine/view/document~Document#event:click} to enable link following.\n\t *\n\t * @private\n\t */\n\t_enableLinkOpen() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\t\tconst modelDocument = editor.model.document;\n\n\t\tthis.listenTo( viewDocument, 'click', ( evt, data ) => {\n\t\t\tconst shouldOpen = env.isMac ? data.domEvent.metaKey : data.domEvent.ctrlKey;\n\n\t\t\tif ( !shouldOpen ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet clickedElement = data.domTarget;\n\n\t\t\tif ( clickedElement.tagName.toLowerCase() != 'a' ) {\n\t\t\t\tclickedElement = clickedElement.closest( 'a' );\n\t\t\t}\n\n\t\t\tif ( !clickedElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst url = clickedElement.getAttribute( 'href' );\n\n\t\t\tif ( !url ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevt.stop();\n\t\t\tdata.preventDefault();\n\n\t\t\topenLink( url );\n\t\t}, { context: '$capture' } );\n\n\t\tthis.listenTo( viewDocument, 'enter', ( evt, data ) => {\n\t\t\tconst selection = modelDocument.selection;\n\n\t\t\tconst selectedElement = selection.getSelectedElement();\n\n\t\t\tconst url = selectedElement ?\n\t\t\t\tselectedElement.getAttribute( 'linkHref' ) :\n\t\t\t\tselection.getAttribute( 'linkHref' );\n\n\t\t\tconst shouldOpen = url && data.domEvent.altKey;\n\n\t\t\tif ( !shouldOpen ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevt.stop();\n\n\t\t\topenLink( url );\n\t\t}, { context: 'a' } );\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model\n\t * selection attributes if the selection is at the end of a link after inserting the content.\n\t *\n\t * The purpose of this action is to improve the overall UX because the user is no longer \"trapped\" by the\n\t * `linkHref` attribute of the selection and they can type a \"clean\" (`linkHref`–less) text right away.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/6053.\n\t *\n\t * @private\n\t */\n\t_enableInsertContentSelectionAttributesFixer() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst selection = model.document.selection;\n\n\t\tthis.listenTo( model, 'insertContent', () => {\n\t\t\tconst nodeBefore = selection.anchor.nodeBefore;\n\t\t\tconst nodeAfter = selection.anchor.nodeAfter;\n\n\t\t\t// NOTE: ↰ and ↱ represent the gravity of the selection.\n\n\t\t\t// The only truly valid case is:\n\t\t\t//\n\t\t\t//\t\t                                 ↰\n\t\t\t//\t\t...<$text linkHref=\"foo\">INSERTED[]</$text>\n\t\t\t//\n\t\t\t// If the selection is not \"trapped\" by the `linkHref` attribute after inserting, there's nothing\n\t\t\t// to fix there.\n\t\t\tif ( !selection.hasAttribute( 'linkHref' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Filter out the following case where a link with the same href (e.g. <a href=\"foo\">INSERTED</a>) is inserted\n\t\t\t// in the middle of an existing link:\n\t\t\t//\n\t\t\t// Before insertion:\n\t\t\t//\t\t                       ↰\n\t\t\t//\t\t<$text linkHref=\"foo\">l[]ink</$text>\n\t\t\t//\n\t\t\t// Expected after insertion:\n\t\t\t//\t\t                               ↰\n\t\t\t//\t\t<$text linkHref=\"foo\">lINSERTED[]ink</$text>\n\t\t\t//\n\t\t\tif ( !nodeBefore ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Filter out the following case where the selection has the \"linkHref\" attribute because the\n\t\t\t// gravity is overridden and some text with another attribute (e.g. <b>INSERTED</b>) is inserted:\n\t\t\t//\n\t\t\t// Before insertion:\n\t\t\t//\n\t\t\t//\t\t                       ↱\n\t\t\t//\t\t<$text linkHref=\"foo\">[]link</$text>\n\t\t\t//\n\t\t\t// Expected after insertion:\n\t\t\t//\n\t\t\t//\t\t                                                          ↱\n\t\t\t//\t\t<$text bold=\"true\">INSERTED</$text><$text linkHref=\"foo\">[]link</$text>\n\t\t\t//\n\t\t\tif ( !nodeBefore.hasAttribute( 'linkHref' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Filter out the following case where a link is a inserted in the middle (or before) another link\n\t\t\t// (different URLs, so they will not merge). In this (let's say weird) case, we can leave the selection\n\t\t\t// attributes as they are because the user will end up writing in one link or another anyway.\n\t\t\t//\n\t\t\t// Before insertion:\n\t\t\t//\n\t\t\t//\t\t                       ↰\n\t\t\t//\t\t<$text linkHref=\"foo\">l[]ink</$text>\n\t\t\t//\n\t\t\t// Expected after insertion:\n\t\t\t//\n\t\t\t//\t\t                                                             ↰\n\t\t\t//\t\t<$text linkHref=\"foo\">l</$text><$text linkHref=\"bar\">INSERTED[]</$text><$text linkHref=\"foo\">ink</$text>\n\t\t\t//\n\t\t\tif ( nodeAfter && nodeAfter.hasAttribute( 'linkHref' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmodel.change( writer => {\n\t\t\t\tremoveLinkAttributesFromSelection( writer, getLinkAttributesAllowedOnText( model.schema ) );\n\t\t\t} );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and\n\t * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a link node\n\t * if clicked at the beginning/ending of the link.\n\t *\n\t * The purpose of this action is to allow typing around the link node directly after a click.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/1016.\n\t *\n\t * @private\n\t */\n\t_enableClickingAfterLink() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\n\t\teditor.editing.view.addObserver( MouseObserver );\n\n\t\tlet clicked = false;\n\n\t\t// Detect the click.\n\t\tthis.listenTo( editor.editing.view.document, 'mousedown', () => {\n\t\t\tclicked = true;\n\t\t} );\n\n\t\t// When the selection has changed...\n\t\tthis.listenTo( editor.editing.view.document, 'selectionChange', () => {\n\t\t\tif ( !clicked ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ...and it was caused by the click...\n\t\t\tclicked = false;\n\n\t\t\tconst selection = model.document.selection;\n\n\t\t\t// ...and no text is selected...\n\t\t\tif ( !selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ...and clicked text is the link...\n\t\t\tif ( !selection.hasAttribute( 'linkHref' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst position = selection.getFirstPosition();\n\t\t\tconst linkRange = findAttributeRange( position, 'linkHref', selection.getAttribute( 'linkHref' ), model );\n\n\t\t\t// ...check whether clicked start/end boundary of the link.\n\t\t\t// If so, remove the `linkHref` attribute.\n\t\t\tif ( position.isTouching( linkRange.start ) || position.isTouching( linkRange.end ) ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\tremoveLinkAttributesFromSelection( writer, getLinkAttributesAllowedOnText( model.schema ) );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/model/model~Model#deleteContent} and {@link module:engine/model/model~Model#insertContent}\n\t * and checks whether typing over the link. If so, attributes of removed text are preserved and applied to the inserted text.\n\t *\n\t * The purpose of this action is to allow modifying a text without loosing the `linkHref` attribute (and other).\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/4762.\n\t *\n\t * @private\n\t */\n\t_enableTypingOverLink() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\n\t\t// Selection attributes when started typing over the link.\n\t\tlet selectionAttributes;\n\n\t\t// Whether pressed `Backspace` or `Delete`. If so, attributes should not be preserved.\n\t\tlet deletedContent;\n\n\t\t// Detect pressing `Backspace` / `Delete`.\n\t\tthis.listenTo( view.document, 'delete', () => {\n\t\t\tdeletedContent = true;\n\t\t}, { priority: 'high' } );\n\n\t\t// Listening to `model#deleteContent` allows detecting whether selected content was a link.\n\t\t// If so, before removing the element, we will copy its attributes.\n\t\tthis.listenTo( editor.model, 'deleteContent', () => {\n\t\t\tconst selection = editor.model.document.selection;\n\n\t\t\t// Copy attributes only if anything is selected.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// When the content was deleted, do not preserve attributes.\n\t\t\tif ( deletedContent ) {\n\t\t\t\tdeletedContent = false;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Enabled only when typing.\n\t\t\tif ( !isTyping( editor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( shouldCopyAttributes( editor.model ) ) {\n\t\t\t\tselectionAttributes = selection.getAttributes();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// Listening to `model#insertContent` allows detecting the content insertion.\n\t\t// We want to apply attributes that were removed while typing over the link.\n\t\tthis.listenTo( editor.model, 'insertContent', ( evt, [ element ] ) => {\n\t\t\tdeletedContent = false;\n\n\t\t\t// Enabled only when typing.\n\t\t\tif ( !isTyping( editor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !selectionAttributes ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\tfor ( const [ attribute, value ] of selectionAttributes ) {\n\t\t\t\t\twriter.setAttribute( attribute, value, element );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tselectionAttributes = null;\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether\n\t * removing a content right after the \"linkHref\" attribute.\n\t *\n\t * If so, the selection should not preserve the `linkHref` attribute. However, if\n\t * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and\n\t * the selection has the \"linkHref\" attribute due to overriden gravity (at the end), the `linkHref` attribute should stay untouched.\n\t *\n\t * The purpose of this action is to allow removing the link text and keep the selection outside the link.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/7521.\n\t *\n\t * @private\n\t */\n\t_handleDeleteContentAfterLink() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst selection = model.document.selection;\n\t\tconst view = editor.editing.view;\n\n\t\t// A flag whether attributes `linkHref` attribute should be preserved.\n\t\tlet shouldPreserveAttributes = false;\n\n\t\t// A flag whether the `Backspace` key was pressed.\n\t\tlet hasBackspacePressed = false;\n\n\t\t// Detect pressing `Backspace`.\n\t\tthis.listenTo( view.document, 'delete', ( evt, data ) => {\n\t\t\thasBackspacePressed = data.domEvent.keyCode === keyCodes.backspace;\n\t\t}, { priority: 'high' } );\n\n\t\t// Before removing the content, check whether the selection is inside a link or at the end of link but with 2-SCM enabled.\n\t\t// If so, we want to preserve link attributes.\n\t\tthis.listenTo( model, 'deleteContent', () => {\n\t\t\t// Reset the state.\n\t\t\tshouldPreserveAttributes = false;\n\n\t\t\tconst position = selection.getFirstPosition();\n\t\t\tconst linkHref = selection.getAttribute( 'linkHref' );\n\n\t\t\tif ( !linkHref ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst linkRange = findAttributeRange( position, 'linkHref', linkHref, model );\n\n\t\t\t// Preserve `linkHref` attribute if the selection is in the middle of the link or\n\t\t\t// the selection is at the end of the link and 2-SCM is activated.\n\t\t\tshouldPreserveAttributes = linkRange.containsPosition( position ) || linkRange.end.isEqual( position );\n\t\t}, { priority: 'high' } );\n\n\t\t// After removing the content, check whether the current selection should preserve the `linkHref` attribute.\n\t\tthis.listenTo( model, 'deleteContent', () => {\n\t\t\t// If didn't press `Backspace`.\n\t\t\tif ( !hasBackspacePressed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thasBackspacePressed = false;\n\n\t\t\t// Disable the mechanism if inside a link (`<$text url=\"foo\">F[]oo</$text>` or <$text url=\"foo\">Foo[]</$text>`).\n\t\t\tif ( shouldPreserveAttributes ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use `model.enqueueChange()` in order to execute the callback at the end of the changes process.\n\t\t\teditor.model.enqueueChange( writer => {\n\t\t\t\tremoveLinkAttributesFromSelection( writer, getLinkAttributesAllowedOnText( model.schema ) );\n\t\t\t} );\n\t\t}, { priority: 'low' } );\n\t}\n}\n\n// Make the selection free of link-related model attributes.\n// All link-related model attributes start with \"link\". That includes not only \"linkHref\"\n// but also all decorator attributes (they have dynamic names), or even custom plugins.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {Array.<String>} linkAttributes\nfunction removeLinkAttributesFromSelection( writer, linkAttributes ) {\n\twriter.removeSelectionAttribute( 'linkHref' );\n\n\tfor ( const attribute of linkAttributes ) {\n\t\twriter.removeSelectionAttribute( attribute );\n\t}\n}\n\n// Checks whether selection's attributes should be copied to the new inserted text.\n//\n// @param {module:engine/model/model~Model} model\n// @returns {Boolean}\nfunction shouldCopyAttributes( model ) {\n\tconst selection = model.document.selection;\n\tconst firstPosition = selection.getFirstPosition();\n\tconst lastPosition = selection.getLastPosition();\n\tconst nodeAtFirstPosition = firstPosition.nodeAfter;\n\n\t// The text link node does not exist...\n\tif ( !nodeAtFirstPosition ) {\n\t\treturn false;\n\t}\n\n\t// ...or it isn't the text node...\n\tif ( !nodeAtFirstPosition.is( '$text' ) ) {\n\t\treturn false;\n\t}\n\n\t// ...or isn't the link.\n\tif ( !nodeAtFirstPosition.hasAttribute( 'linkHref' ) ) {\n\t\treturn false;\n\t}\n\n\t// `textNode` = the position is inside the link element.\n\t// `nodeBefore` = the position is at the end of the link element.\n\tconst nodeAtLastPosition = lastPosition.textNode || lastPosition.nodeBefore;\n\n\t// If both references the same node selection contains a single text node.\n\tif ( nodeAtFirstPosition === nodeAtLastPosition ) {\n\t\treturn true;\n\t}\n\n\t// If nodes are not equal, maybe the link nodes has defined additional attributes inside.\n\t// First, we need to find the entire link range.\n\tconst linkRange = findAttributeRange( firstPosition, 'linkHref', nodeAtFirstPosition.getAttribute( 'linkHref' ), model );\n\n\t// Then we can check whether selected range is inside the found link range. If so, attributes should be preserved.\n\treturn linkRange.containsRange( model.createRange( firstPosition, lastPosition ), true );\n}\n\n// Checks whether provided changes were caused by typing.\n//\n// @params {module:core/editor/editor~Editor} editor\n// @returns {Boolean}\nfunction isTyping( editor ) {\n\tconst input = editor.plugins.get( 'Input' );\n\n\treturn input.isInput( editor.model.change( writer => writer.batch ) );\n}\n\n// Returns an array containing names of the attributes allowed on `$text` that describes the link item.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Array.<String>}\nfunction getLinkAttributesAllowedOnText( schema ) {\n\tconst textAttributes = schema.getDefinition( '$text' ).allowAttributes;\n\n\treturn textAttributes.filter( attribute => attribute.startsWith( 'link' ) );\n}\n"]},"metadata":{},"sourceType":"module"}