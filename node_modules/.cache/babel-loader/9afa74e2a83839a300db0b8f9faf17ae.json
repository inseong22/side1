{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { findAttributeRange } from 'ckeditor5/src/typing';\nimport { Collection, first, toMap } from 'ckeditor5/src/utils';\nimport AutomaticDecorators from './utils/automaticdecorators';\nimport { isLinkableElement } from './utils';\n/**\n * The link command. It is used by the {@link module:link/link~Link link feature}.\n *\n * @extends module:core/command~Command\n */\n\nexport default class LinkCommand extends Command {\n  /**\n   * The value of the `'linkHref'` attribute if the start of the selection is located in a node with this attribute.\n   *\n   * @observable\n   * @readonly\n   * @member {Object|undefined} #value\n   */\n  constructor(editor) {\n    super(editor);\n    /**\n     * A collection of {@link module:link/utils~ManualDecorator manual decorators}\n     * corresponding to the {@link module:link/link~LinkConfig#decorators decorator configuration}.\n     *\n     * You can consider it a model with states of manual decorators added to the currently selected link.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n\n    this.manualDecorators = new Collection();\n    /**\n     * An instance of the helper that ties together all {@link module:link/link~LinkDecoratorAutomaticDefinition}\n     * that are used by the {@glink features/link link} and the {@glink features/images/images-linking linking images} features.\n     *\n     * @readonly\n     * @type {module:link/utils~AutomaticDecorators}\n     */\n\n    this.automaticDecorators = new AutomaticDecorators();\n  }\n  /**\n   * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.\n   */\n\n\n  restoreManualDecoratorStates() {\n    for (const manualDecorator of this.manualDecorators) {\n      manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  refresh() {\n    const model = this.editor.model;\n    const selection = model.document.selection;\n    const selectedElement = selection.getSelectedElement() || first(selection.getSelectedBlocks()); // A check for any integration that allows linking elements (e.g. `LinkImage`).\n    // Currently the selection reads attributes from text nodes only. See #7429 and #7465.\n\n    if (isLinkableElement(selectedElement, model.schema)) {\n      this.value = selectedElement.getAttribute('linkHref');\n      this.isEnabled = model.schema.checkAttribute(selectedElement, 'linkHref');\n    } else {\n      this.value = selection.getAttribute('linkHref');\n      this.isEnabled = model.schema.checkAttributeInSelection(selection, 'linkHref');\n    }\n\n    for (const manualDecorator of this.manualDecorators) {\n      manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);\n    }\n  }\n  /**\n   * Executes the command.\n   *\n   * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to\n   * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).\n   *\n   * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a\n   * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but\n   * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.\n   * The selection will be updated to wrap the just inserted text node.\n   *\n   * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.\n   *\n   * # Decorators and model attribute management\n   *\n   * There is an optional argument to this command that applies or removes model\n   * {@glink framework/guides/architecture/editing-engine#text-attributes text attributes} brought by\n   * {@link module:link/utils~ManualDecorator manual link decorators}.\n   *\n   * Text attribute names in the model correspond to the entries in the {@link module:link/link~LinkConfig#decorators configuration}.\n   * For every decorator configured, a model text attribute exists with the \"link\" prefix. For example, a `'linkMyDecorator'` attribute\n   * corresponds to `'myDecorator'` in the configuration.\n   *\n   * To learn more about link decorators, check out the {@link module:link/link~LinkConfig#decorators `config.link.decorators`}\n   * documentation.\n   *\n   * Here is how to manage decorator attributes with the link command:\n   *\n   *\t\tconst linkCommand = editor.commands.get( 'link' );\n   *\n   *\t\t// Adding a new decorator attribute.\n   *\t\tlinkCommand.execute( 'http://example.com', {\n   *\t\t\tlinkIsExternal: true\n   *\t\t} );\n   *\n   *\t\t// Removing a decorator attribute from the selection.\n   *\t\tlinkCommand.execute( 'http://example.com', {\n   *\t\t\tlinkIsExternal: false\n   *\t\t} );\n   *\n   *\t\t// Adding multiple decorator attributes at the same time.\n   *\t\tlinkCommand.execute( 'http://example.com', {\n   *\t\t\tlinkIsExternal: true,\n   *\t\t\tlinkIsDownloadable: true,\n   *\t\t} );\n   *\n   *\t\t// Removing and adding decorator attributes at the same time.\n   *\t\tlinkCommand.execute( 'http://example.com', {\n   *\t\t\tlinkIsExternal: false,\n   *\t\t\tlinkFoo: true,\n   *\t\t\tlinkIsDownloadable: false,\n   *\t\t} );\n   *\n   * **Note**: If the decorator attribute name is not specified, its state remains untouched.\n   *\n   * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all\n   * decorator attributes.\n   *\n   * @fires execute\n   * @param {String} href Link destination.\n   * @param {Object} [manualDecoratorIds={}] The information about manual decorator attributes to be applied or removed upon execution.\n   */\n\n\n  execute(href, manualDecoratorIds = {}) {\n    const model = this.editor.model;\n    const selection = model.document.selection; // Stores information about manual decorators to turn them on/off when command is applied.\n\n    const truthyManualDecorators = [];\n    const falsyManualDecorators = [];\n\n    for (const name in manualDecoratorIds) {\n      if (manualDecoratorIds[name]) {\n        truthyManualDecorators.push(name);\n      } else {\n        falsyManualDecorators.push(name);\n      }\n    }\n\n    model.change(writer => {\n      // If selection is collapsed then update selected link or insert new one at the place of caret.\n      if (selection.isCollapsed) {\n        const position = selection.getFirstPosition(); // When selection is inside text with `linkHref` attribute.\n\n        if (selection.hasAttribute('linkHref')) {\n          // Then update `linkHref` value.\n          const linkRange = findAttributeRange(position, 'linkHref', selection.getAttribute('linkHref'), model);\n          writer.setAttribute('linkHref', href, linkRange);\n          truthyManualDecorators.forEach(item => {\n            writer.setAttribute(item, true, linkRange);\n          });\n          falsyManualDecorators.forEach(item => {\n            writer.removeAttribute(item, linkRange);\n          }); // Put the selection at the end of the updated link.\n\n          writer.setSelection(writer.createPositionAfter(linkRange.end.nodeBefore));\n        } // If not then insert text node with `linkHref` attribute in place of caret.\n        // However, since selection is collapsed, attribute value will be used as data for text node.\n        // So, if `href` is empty, do not create text node.\n        else if (href !== '') {\n            const attributes = toMap(selection.getAttributes());\n            attributes.set('linkHref', href);\n            truthyManualDecorators.forEach(item => {\n              attributes.set(item, true);\n            });\n            const {\n              end: positionAfter\n            } = model.insertContent(writer.createText(href, attributes), position); // Put the selection at the end of the inserted link.\n            // Using end of range returned from insertContent in case nodes with the same attributes got merged.\n\n            writer.setSelection(positionAfter);\n          } // Remove the `linkHref` attribute and all link decorators from the selection.\n        // It stops adding a new content into the link element.\n\n\n        ['linkHref', ...truthyManualDecorators, ...falsyManualDecorators].forEach(item => {\n          writer.removeSelectionAttribute(item);\n        });\n      } else {\n        // If selection has non-collapsed ranges, we change attribute on nodes inside those ranges\n        // omitting nodes where the `linkHref` attribute is disallowed.\n        const ranges = model.schema.getValidRanges(selection.getRanges(), 'linkHref'); // But for the first, check whether the `linkHref` attribute is allowed on selected blocks (e.g. the \"image\" element).\n\n        const allowedRanges = [];\n\n        for (const element of selection.getSelectedBlocks()) {\n          if (model.schema.checkAttribute(element, 'linkHref')) {\n            allowedRanges.push(writer.createRangeOn(element));\n          }\n        } // Ranges that accept the `linkHref` attribute. Since we will iterate over `allowedRanges`, let's clone it.\n\n\n        const rangesToUpdate = allowedRanges.slice(); // For all selection ranges we want to check whether given range is inside an element that accepts the `linkHref` attribute.\n        // If so, we don't want to propagate applying the attribute to its children.\n\n        for (const range of ranges) {\n          if (this._isRangeToUpdate(range, allowedRanges)) {\n            rangesToUpdate.push(range);\n          }\n        }\n\n        for (const range of rangesToUpdate) {\n          writer.setAttribute('linkHref', href, range);\n          truthyManualDecorators.forEach(item => {\n            writer.setAttribute(item, true, range);\n          });\n          falsyManualDecorators.forEach(item => {\n            writer.removeAttribute(item, range);\n          });\n        }\n      }\n    });\n  }\n  /**\n   * Provides information whether a decorator with a given name is present in the currently processed selection.\n   *\n   * @private\n   * @param {String} decoratorName The name of the manual decorator used in the model\n   * @returns {Boolean} The information whether a given decorator is currently present in the selection.\n   */\n\n\n  _getDecoratorStateFromModel(decoratorName) {\n    const model = this.editor.model;\n    const selection = model.document.selection;\n    const selectedElement = selection.getSelectedElement(); // A check for the `LinkImage` plugin. If the selection contains an element, get values from the element.\n    // Currently the selection reads attributes from text nodes only. See #7429 and #7465.\n\n    if (isLinkableElement(selectedElement, model.schema)) {\n      return selectedElement.getAttribute(decoratorName);\n    }\n\n    return selection.getAttribute(decoratorName);\n  }\n  /**\n   * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range A range to check.\n   * @param {Array.<module:engine/view/range~Range>} allowedRanges An array of ranges created on elements where the attribute is accepted.\n   * @returns {Boolean}\n   */\n\n\n  _isRangeToUpdate(range, allowedRanges) {\n    for (const allowedRange of allowedRanges) {\n      // A range is inside an element that will have the `linkHref` attribute. Do not modify its nodes.\n      if (allowedRange.containsRange(range)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-link/src/linkcommand.js"],"names":["Command","findAttributeRange","Collection","first","toMap","AutomaticDecorators","isLinkableElement","LinkCommand","constructor","editor","manualDecorators","automaticDecorators","restoreManualDecoratorStates","manualDecorator","value","_getDecoratorStateFromModel","id","refresh","model","selection","document","selectedElement","getSelectedElement","getSelectedBlocks","schema","getAttribute","isEnabled","checkAttribute","checkAttributeInSelection","execute","href","manualDecoratorIds","truthyManualDecorators","falsyManualDecorators","name","push","change","writer","isCollapsed","position","getFirstPosition","hasAttribute","linkRange","setAttribute","forEach","item","removeAttribute","setSelection","createPositionAfter","end","nodeBefore","attributes","getAttributes","set","positionAfter","insertContent","createText","removeSelectionAttribute","ranges","getValidRanges","getRanges","allowedRanges","element","createRangeOn","rangesToUpdate","slice","range","_isRangeToUpdate","decoratorName","allowedRange","containsRange"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkcommand\n */\n\nimport { Command } from 'ckeditor5/src/core';\nimport { findAttributeRange } from 'ckeditor5/src/typing';\nimport { Collection, first, toMap } from 'ckeditor5/src/utils';\n\nimport AutomaticDecorators from './utils/automaticdecorators';\nimport { isLinkableElement } from './utils';\n\n/**\n * The link command. It is used by the {@link module:link/link~Link link feature}.\n *\n * @extends module:core/command~Command\n */\nexport default class LinkCommand extends Command {\n\t/**\n\t * The value of the `'linkHref'` attribute if the start of the selection is located in a node with this attribute.\n\t *\n\t * @observable\n\t * @readonly\n\t * @member {Object|undefined} #value\n\t */\n\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * A collection of {@link module:link/utils~ManualDecorator manual decorators}\n\t\t * corresponding to the {@link module:link/link~LinkConfig#decorators decorator configuration}.\n\t\t *\n\t\t * You can consider it a model with states of manual decorators added to the currently selected link.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:utils/collection~Collection}\n\t\t */\n\t\tthis.manualDecorators = new Collection();\n\n\t\t/**\n\t\t * An instance of the helper that ties together all {@link module:link/link~LinkDecoratorAutomaticDefinition}\n\t\t * that are used by the {@glink features/link link} and the {@glink features/images/images-linking linking images} features.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:link/utils~AutomaticDecorators}\n\t\t */\n\t\tthis.automaticDecorators = new AutomaticDecorators();\n\t}\n\n\t/**\n\t * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.\n\t */\n\trestoreManualDecoratorStates() {\n\t\tfor ( const manualDecorator of this.manualDecorators ) {\n\t\t\tmanualDecorator.value = this._getDecoratorStateFromModel( manualDecorator.id );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst model = this.editor.model;\n\t\tconst selection = model.document.selection;\n\t\tconst selectedElement = selection.getSelectedElement() || first( selection.getSelectedBlocks() );\n\n\t\t// A check for any integration that allows linking elements (e.g. `LinkImage`).\n\t\t// Currently the selection reads attributes from text nodes only. See #7429 and #7465.\n\t\tif ( isLinkableElement( selectedElement, model.schema ) ) {\n\t\t\tthis.value = selectedElement.getAttribute( 'linkHref' );\n\t\t\tthis.isEnabled = model.schema.checkAttribute( selectedElement, 'linkHref' );\n\t\t} else {\n\t\t\tthis.value = selection.getAttribute( 'linkHref' );\n\t\t\tthis.isEnabled = model.schema.checkAttributeInSelection( selection, 'linkHref' );\n\t\t}\n\n\t\tfor ( const manualDecorator of this.manualDecorators ) {\n\t\t\tmanualDecorator.value = this._getDecoratorStateFromModel( manualDecorator.id );\n\t\t}\n\t}\n\n\t/**\n\t * Executes the command.\n\t *\n\t * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to\n\t * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).\n\t *\n\t * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a\n\t * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but\n\t * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.\n\t * The selection will be updated to wrap the just inserted text node.\n\t *\n\t * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.\n\t *\n\t * # Decorators and model attribute management\n\t *\n\t * There is an optional argument to this command that applies or removes model\n\t * {@glink framework/guides/architecture/editing-engine#text-attributes text attributes} brought by\n\t * {@link module:link/utils~ManualDecorator manual link decorators}.\n\t *\n\t * Text attribute names in the model correspond to the entries in the {@link module:link/link~LinkConfig#decorators configuration}.\n\t * For every decorator configured, a model text attribute exists with the \"link\" prefix. For example, a `'linkMyDecorator'` attribute\n\t * corresponds to `'myDecorator'` in the configuration.\n\t *\n\t * To learn more about link decorators, check out the {@link module:link/link~LinkConfig#decorators `config.link.decorators`}\n\t * documentation.\n\t *\n\t * Here is how to manage decorator attributes with the link command:\n\t *\n\t *\t\tconst linkCommand = editor.commands.get( 'link' );\n\t *\n\t *\t\t// Adding a new decorator attribute.\n\t *\t\tlinkCommand.execute( 'http://example.com', {\n\t *\t\t\tlinkIsExternal: true\n\t *\t\t} );\n\t *\n\t *\t\t// Removing a decorator attribute from the selection.\n\t *\t\tlinkCommand.execute( 'http://example.com', {\n\t *\t\t\tlinkIsExternal: false\n\t *\t\t} );\n\t *\n\t *\t\t// Adding multiple decorator attributes at the same time.\n\t *\t\tlinkCommand.execute( 'http://example.com', {\n\t *\t\t\tlinkIsExternal: true,\n\t *\t\t\tlinkIsDownloadable: true,\n\t *\t\t} );\n\t *\n\t *\t\t// Removing and adding decorator attributes at the same time.\n\t *\t\tlinkCommand.execute( 'http://example.com', {\n\t *\t\t\tlinkIsExternal: false,\n\t *\t\t\tlinkFoo: true,\n\t *\t\t\tlinkIsDownloadable: false,\n\t *\t\t} );\n\t *\n\t * **Note**: If the decorator attribute name is not specified, its state remains untouched.\n\t *\n\t * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all\n\t * decorator attributes.\n\t *\n\t * @fires execute\n\t * @param {String} href Link destination.\n\t * @param {Object} [manualDecoratorIds={}] The information about manual decorator attributes to be applied or removed upon execution.\n\t */\n\texecute( href, manualDecoratorIds = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst selection = model.document.selection;\n\t\t// Stores information about manual decorators to turn them on/off when command is applied.\n\t\tconst truthyManualDecorators = [];\n\t\tconst falsyManualDecorators = [];\n\n\t\tfor ( const name in manualDecoratorIds ) {\n\t\t\tif ( manualDecoratorIds[ name ] ) {\n\t\t\t\ttruthyManualDecorators.push( name );\n\t\t\t} else {\n\t\t\t\tfalsyManualDecorators.push( name );\n\t\t\t}\n\t\t}\n\n\t\tmodel.change( writer => {\n\t\t\t// If selection is collapsed then update selected link or insert new one at the place of caret.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\tconst position = selection.getFirstPosition();\n\n\t\t\t\t// When selection is inside text with `linkHref` attribute.\n\t\t\t\tif ( selection.hasAttribute( 'linkHref' ) ) {\n\t\t\t\t\t// Then update `linkHref` value.\n\t\t\t\t\tconst linkRange = findAttributeRange( position, 'linkHref', selection.getAttribute( 'linkHref' ), model );\n\n\t\t\t\t\twriter.setAttribute( 'linkHref', href, linkRange );\n\n\t\t\t\t\ttruthyManualDecorators.forEach( item => {\n\t\t\t\t\t\twriter.setAttribute( item, true, linkRange );\n\t\t\t\t\t} );\n\n\t\t\t\t\tfalsyManualDecorators.forEach( item => {\n\t\t\t\t\t\twriter.removeAttribute( item, linkRange );\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Put the selection at the end of the updated link.\n\t\t\t\t\twriter.setSelection( writer.createPositionAfter( linkRange.end.nodeBefore ) );\n\t\t\t\t}\n\t\t\t\t// If not then insert text node with `linkHref` attribute in place of caret.\n\t\t\t\t// However, since selection is collapsed, attribute value will be used as data for text node.\n\t\t\t\t// So, if `href` is empty, do not create text node.\n\t\t\t\telse if ( href !== '' ) {\n\t\t\t\t\tconst attributes = toMap( selection.getAttributes() );\n\n\t\t\t\t\tattributes.set( 'linkHref', href );\n\n\t\t\t\t\ttruthyManualDecorators.forEach( item => {\n\t\t\t\t\t\tattributes.set( item, true );\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst { end: positionAfter } = model.insertContent( writer.createText( href, attributes ), position );\n\n\t\t\t\t\t// Put the selection at the end of the inserted link.\n\t\t\t\t\t// Using end of range returned from insertContent in case nodes with the same attributes got merged.\n\t\t\t\t\twriter.setSelection( positionAfter );\n\t\t\t\t}\n\n\t\t\t\t// Remove the `linkHref` attribute and all link decorators from the selection.\n\t\t\t\t// It stops adding a new content into the link element.\n\t\t\t\t[ 'linkHref', ...truthyManualDecorators, ...falsyManualDecorators ].forEach( item => {\n\t\t\t\t\twriter.removeSelectionAttribute( item );\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t// If selection has non-collapsed ranges, we change attribute on nodes inside those ranges\n\t\t\t\t// omitting nodes where the `linkHref` attribute is disallowed.\n\t\t\t\tconst ranges = model.schema.getValidRanges( selection.getRanges(), 'linkHref' );\n\n\t\t\t\t// But for the first, check whether the `linkHref` attribute is allowed on selected blocks (e.g. the \"image\" element).\n\t\t\t\tconst allowedRanges = [];\n\n\t\t\t\tfor ( const element of selection.getSelectedBlocks() ) {\n\t\t\t\t\tif ( model.schema.checkAttribute( element, 'linkHref' ) ) {\n\t\t\t\t\t\tallowedRanges.push( writer.createRangeOn( element ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Ranges that accept the `linkHref` attribute. Since we will iterate over `allowedRanges`, let's clone it.\n\t\t\t\tconst rangesToUpdate = allowedRanges.slice();\n\n\t\t\t\t// For all selection ranges we want to check whether given range is inside an element that accepts the `linkHref` attribute.\n\t\t\t\t// If so, we don't want to propagate applying the attribute to its children.\n\t\t\t\tfor ( const range of ranges ) {\n\t\t\t\t\tif ( this._isRangeToUpdate( range, allowedRanges ) ) {\n\t\t\t\t\t\trangesToUpdate.push( range );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor ( const range of rangesToUpdate ) {\n\t\t\t\t\twriter.setAttribute( 'linkHref', href, range );\n\n\t\t\t\t\ttruthyManualDecorators.forEach( item => {\n\t\t\t\t\t\twriter.setAttribute( item, true, range );\n\t\t\t\t\t} );\n\n\t\t\t\t\tfalsyManualDecorators.forEach( item => {\n\t\t\t\t\t\twriter.removeAttribute( item, range );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Provides information whether a decorator with a given name is present in the currently processed selection.\n\t *\n\t * @private\n\t * @param {String} decoratorName The name of the manual decorator used in the model\n\t * @returns {Boolean} The information whether a given decorator is currently present in the selection.\n\t */\n\t_getDecoratorStateFromModel( decoratorName ) {\n\t\tconst model = this.editor.model;\n\t\tconst selection = model.document.selection;\n\t\tconst selectedElement = selection.getSelectedElement();\n\n\t\t// A check for the `LinkImage` plugin. If the selection contains an element, get values from the element.\n\t\t// Currently the selection reads attributes from text nodes only. See #7429 and #7465.\n\t\tif ( isLinkableElement( selectedElement, model.schema ) ) {\n\t\t\treturn selectedElement.getAttribute( decoratorName );\n\t\t}\n\n\t\treturn selection.getAttribute( decoratorName );\n\t}\n\n\t/**\n\t * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range A range to check.\n\t * @param {Array.<module:engine/view/range~Range>} allowedRanges An array of ranges created on elements where the attribute is accepted.\n\t * @returns {Boolean}\n\t */\n\t_isRangeToUpdate( range, allowedRanges ) {\n\t\tfor ( const allowedRange of allowedRanges ) {\n\t\t\t// A range is inside an element that will have the `linkHref` attribute. Do not modify its nodes.\n\t\t\tif ( allowedRange.containsRange( range ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}