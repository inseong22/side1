{"ast":null,"code":"import { useRef, useEffect, useCallback } from 'react'; // Saves incoming handler to the ref in order to avoid \"useCallback hell\"\n\nexport function useEventCallback(handler) {\n  var callbackRef = useRef(handler);\n  useEffect(() => {\n    callbackRef.current = handler;\n  });\n  return useCallback((value, event) => callbackRef.current && callbackRef.current(value, event), []);\n} // Check if an event was triggered by touch\n\nexport var isTouch = event => 'touches' in event; // Browsers introduced an intervention, making touch events passive by default.\n// This workaround removes `preventDefault` call from the touch handlers.\n// https://github.com/facebook/react/issues/19651\n\nexport var preventDefaultMove = event => {\n  !isTouch(event) && event.preventDefault && event.preventDefault();\n}; // Clamps a value between an upper and lower bound.\n// We use ternary operators because it makes the minified code\n// 2 times shorter then `Math.min(Math.max(a,b),c)`\n\nexport var clamp = function clamp(number, min, max) {\n  if (min === void 0) {\n    min = 0;\n  }\n\n  if (max === void 0) {\n    max = 1;\n  }\n\n  return number > max ? max : number < min ? min : number;\n}; // Returns a relative position of the pointer inside the node's bounding box\n\nexport var getRelativePosition = (node, event) => {\n  var rect = node.getBoundingClientRect(); // Get user's pointer position from `touches` array if it's a `TouchEvent`\n\n  var pointer = isTouch(event) ? event.touches[0] : event;\n  return {\n    left: clamp((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),\n    top: clamp((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height),\n    width: rect.width,\n    height: rect.height,\n    x: pointer.pageX - (rect.left + window.pageXOffset),\n    y: pointer.pageY - (rect.top + window.pageYOffset)\n  };\n};","map":{"version":3,"sources":["../src/utils.ts"],"names":["callbackRef","useRef","useEffect","useCallback","isTouch","event","preventDefaultMove","clamp","min","max","number","getRelativePosition","rect","node","pointer","left","window","top","width","height","x","y"],"mappings":"AAAA,SAAA,MAAA,EAAA,SAAA,EAAA,WAAA,QAAA,OAAA,C,CAEA;;AACA,OAAO,SAAA,gBAAA,CAAA,OAAA,EAAsG;AAC3G,MAAMA,WAAW,GAAGC,MAAM,CAA1B,OAA0B,CAA1B;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACdF,IAAAA,WAAW,CAAXA,OAAAA,GAAAA,OAAAA;AADFE,GAAS,CAATA;AAIA,SAAOC,WAAW,CAAC,CAAA,KAAA,EAAA,KAAA,KAAwBH,WAAW,CAAXA,OAAAA,IAAuBA,WAAW,CAAXA,OAAAA,CAAAA,KAAAA,EAAhD,KAAgDA,CAAhD,EAAlB,EAAkB,CAAlB;EAGF;;AACA,OAAO,IAAMI,OAAO,GAAIC,KAAD,IAAyD,aAAzE,KAAA,C,CAEP;AACA;AACA;;AACA,OAAO,IAAMC,kBAAkB,GAAID,KAAD,IAA0C;AAC1E,GAACD,OAAO,CAAR,KAAQ,CAAR,IAAmBC,KAAK,CAAxB,cAAA,IAA2CA,KAAK,CAAhD,cAA2CA,EAA3C;AADK,CAAA,C,CAGP;AACA;AACA;;AACA,OAAO,IAAME,KAAK,GAAG,SAARA,KAAQ,CAAA,MAAA,EAAA,GAAA,EAAA,GAAA,EAA8C;AAAA,MAA7BC,GAA6B,KAAA,KAAA,CAAA,EAAA;AAA7BA,IAAAA,GAA6B,GAAvB,CAANA;AAA6B;;AAAA,MAApBC,GAAoB,KAAA,KAAA,CAAA,EAAA;AAApBA,IAAAA,GAAoB,GAAd,CAANA;AAAoB;;AACjE,SAAOC,MAAM,GAANA,GAAAA,GAAAA,GAAAA,GAAqBA,MAAM,GAANA,GAAAA,GAAAA,GAAAA,GAA5B,MAAA;AADK,CAAA,C,CAaP;;AACA,OAAO,IAAMC,mBAAmB,GAAG,CAAA,IAAA,EAAA,KAAA,KAAuE;AACxG,MAAMC,IAAI,GAAGC,IAAI,CADuF,qBAC3FA,EAAb,CADwG,CAGxG;;AACA,MAAMC,OAAO,GAAGV,OAAO,CAAPA,KAAO,CAAPA,GAAiBC,KAAK,CAALA,OAAAA,CAAjBD,CAAiBC,CAAjBD,GAAhB,KAAA;AAEA,SAAO;AACLW,IAAAA,IAAI,EAAER,KAAK,CAAC,CAACO,OAAO,CAAPA,KAAAA,IAAiBF,IAAI,CAAJA,IAAAA,GAAYI,MAAM,CAApC,WAACF,CAAD,IAAqDF,IAAI,CADhE,KACM,CADN;AAELK,IAAAA,GAAG,EAAEV,KAAK,CAAC,CAACO,OAAO,CAAPA,KAAAA,IAAiBF,IAAI,CAAJA,GAAAA,GAAWI,MAAM,CAAnC,WAACF,CAAD,IAAoDF,IAAI,CAF9D,MAEK,CAFL;AAGLM,IAAAA,KAAK,EAAEN,IAAI,CAHN,KAAA;AAILO,IAAAA,MAAM,EAAEP,IAAI,CAJP,MAAA;AAKLQ,IAAAA,CAAC,EAAEN,OAAO,CAAPA,KAAAA,IAAiBF,IAAI,CAAJA,IAAAA,GAAYI,MAAM,CALjC,WAKFF,CALE;AAMLO,IAAAA,CAAC,EAAEP,OAAO,CAAPA,KAAAA,IAAiBF,IAAI,CAAJA,GAAAA,GAAWI,MAAM,CAAlCF,WAAAA;AANE,GAAP;AANK,CAAA","sourcesContent":["import { useRef, useEffect, useCallback, useLayoutEffect } from 'react';\n\n// Saves incoming handler to the ref in order to avoid \"useCallback hell\"\nexport function useEventCallback<T, K>(handler?: (value: T, event: K) => void): (value: T, event: K) => void {\n  const callbackRef = useRef(handler);\n\n  useEffect(() => {\n    callbackRef.current = handler;\n  });\n\n  return useCallback((value: T, event: K) => callbackRef.current && callbackRef.current(value, event), []);\n}\n\n// Check if an event was triggered by touch\nexport const isTouch = (event: MouseEvent | TouchEvent): event is TouchEvent => 'touches' in event;\n\n// Browsers introduced an intervention, making touch events passive by default.\n// This workaround removes `preventDefault` call from the touch handlers.\n// https://github.com/facebook/react/issues/19651\nexport const preventDefaultMove = (event: MouseEvent | TouchEvent): void => {\n  !isTouch(event) && event.preventDefault && event.preventDefault();\n};\n// Clamps a value between an upper and lower bound.\n// We use ternary operators because it makes the minified code\n// 2 times shorter then `Math.min(Math.max(a,b),c)`\nexport const clamp = (number: number, min = 0, max = 1): number => {\n  return number > max ? max : number < min ? min : number;\n};\n\nexport interface Interaction {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n  x: number;\n  y: number;\n}\n\n// Returns a relative position of the pointer inside the node's bounding box\nexport const getRelativePosition = (node: HTMLDivElement, event: MouseEvent | TouchEvent): Interaction => {\n  const rect = node.getBoundingClientRect();\n\n  // Get user's pointer position from `touches` array if it's a `TouchEvent`\n  const pointer = isTouch(event) ? event.touches[0] : (event as MouseEvent);\n\n  return {\n    left: clamp((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),\n    top: clamp((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height),\n    width: rect.width,\n    height: rect.height,\n    x: pointer.pageX - (rect.left + window.pageXOffset),\n    y: pointer.pageY - (rect.top + window.pageYOffset),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}