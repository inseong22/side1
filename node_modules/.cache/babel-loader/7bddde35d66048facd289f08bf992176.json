{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module undo/basecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { transformSets } from '@ckeditor/ckeditor5-engine/src/model/operation/transform';\n/**\n * Base class for undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.\n *\n * @protected\n * @extends module:core/command~Command\n */\n\nexport default class BaseCommand extends Command {\n  constructor(editor) {\n    super(editor);\n    /**\n     * Stack of items stored by the command. These are pairs of:\n     *\n     * * {@link module:engine/model/batch~Batch batch} saved by the command,\n     * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.\n     *\n     * @protected\n     * @member {Array} #_stack\n     */\n\n    this._stack = [];\n    /**\n     * Stores all batches that were created by this command.\n     *\n     * @protected\n     * @member {WeakSet.<module:engine/model/batch~Batch>} #_createdBatches\n     */\n\n    this._createdBatches = new WeakSet(); // Refresh state, so the command is inactive right after initialization.\n\n    this.refresh(); // Set the transparent batch for the `editor.data.set()` call if the\n    // batch type is not set already.\n\n    this.listenTo(editor.data, 'set', (evt, data) => {\n      // Create a shallow copy of the options to not change the original args.\n      // And make sure that an object is assigned to data[ 1 ].\n      data[1] = { ...data[1]\n      };\n      const options = data[1];\n\n      if (options.batchType) {\n        return;\n      }\n\n      options.batchType = 'transparent';\n    }, {\n      priority: 'high'\n    }); // Clear the stack for the `transparent` batches.\n\n    this.listenTo(editor.data, 'set', (evt, data) => {\n      // We can assume that the object exists - it was ensured\n      // with the high priority listener before.\n      const options = data[1];\n\n      if (options.batchType === 'transparent') {\n        this.clearStack();\n      }\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  refresh() {\n    this.isEnabled = this._stack.length > 0;\n  }\n  /**\n   * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}\n   * created by the editor which this command is registered to.\n   *\n   * @param {module:engine/model/batch~Batch} batch The batch to add.\n   */\n\n\n  addBatch(batch) {\n    const docSelection = this.editor.model.document.selection;\n    const selection = {\n      ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],\n      isBackward: docSelection.isBackward\n    };\n\n    this._stack.push({\n      batch,\n      selection\n    });\n\n    this.refresh();\n  }\n  /**\n   * Removes all items from the stack.\n   */\n\n\n  clearStack() {\n    this._stack = [];\n    this.refresh();\n  }\n  /**\n   * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.\n   *\n   * @protected\n   * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be restored.\n   * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.\n   * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations which has been applied\n   * since selection has been stored.\n   */\n\n\n  _restoreSelection(ranges, isBackward, operations) {\n    const model = this.editor.model;\n    const document = model.document; // This will keep the transformed selection ranges.\n\n    const selectionRanges = []; // Transform all ranges from the restored selection.\n\n    const transformedRangeGroups = ranges.map(range => range.getTransformedByOperations(operations));\n    const allRanges = transformedRangeGroups.flat();\n\n    for (const rangeGroup of transformedRangeGroups) {\n      // While transforming there could appear ranges that are contained by other ranges, we shall ignore them.\n      const transformed = rangeGroup.filter(range => range.root != document.graveyard).filter(range => !isRangeContainedByAnyOtherRange(range, allRanges)); // All the transformed ranges ended up in graveyard.\n\n      if (!transformed.length) {\n        continue;\n      } // After the range got transformed, we have an array of ranges. Some of those\n      // ranges may be \"touching\" -- they can be next to each other and could be merged.\n\n\n      normalizeRanges(transformed); // For each `range` from `ranges`, we take only one transformed range.\n      // This is because we want to prevent situation where single-range selection\n      // got transformed to multi-range selection.\n\n      selectionRanges.push(transformed[0]);\n    } // @if CK_DEBUG_ENGINE // console.log( `Restored selection by undo: ${ selectionRanges.join( ', ' ) }` );\n    // `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.\n\n\n    if (selectionRanges.length) {\n      model.change(writer => {\n        writer.setSelection(selectionRanges, {\n          backward: isBackward\n        });\n      });\n    }\n  }\n  /**\n   * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.\n   * This is a helper method for {@link #execute}.\n   *\n   * @protected\n   * @param {module:engine/model/batch~Batch} batchToUndo The batch to be undone.\n   * @param {module:engine/model/batch~Batch} undoingBatch The batch that will contain undoing changes.\n   */\n\n\n  _undo(batchToUndo, undoingBatch) {\n    const model = this.editor.model;\n    const document = model.document; // All changes done by the command execution will be saved as one batch.\n\n    this._createdBatches.add(undoingBatch);\n\n    const operationsToUndo = batchToUndo.operations.slice().filter(operation => operation.isDocumentOperation);\n    operationsToUndo.reverse(); // We will process each operation from `batchToUndo`, in reverse order. If there were operations A, B and C in undone batch,\n    // we need to revert them in reverse order, so first C' (reversed C), then B', then A'.\n\n    for (const operationToUndo of operationsToUndo) {\n      const nextBaseVersion = operationToUndo.baseVersion + 1;\n      const historyOperations = Array.from(document.history.getOperations(nextBaseVersion));\n      const transformedSets = transformSets([operationToUndo.getReversed()], historyOperations, {\n        useRelations: true,\n        document: this.editor.model.document,\n        padWithNoOps: false,\n        forceWeakRemove: true\n      });\n      const reversedOperations = transformedSets.operationsA; // After reversed operation has been transformed by all history operations, apply it.\n\n      for (const operation of reversedOperations) {\n        // Before applying, add the operation to the `undoingBatch`.\n        undoingBatch.addOperation(operation);\n        model.applyOperation(operation);\n        document.history.setOperationAsUndone(operationToUndo, operation);\n      }\n    }\n  }\n\n} // Normalizes list of ranges by joining intersecting or \"touching\" ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges\n//\n\nfunction normalizeRanges(ranges) {\n  ranges.sort((a, b) => a.start.isBefore(b.start) ? -1 : 1);\n\n  for (let i = 1; i < ranges.length; i++) {\n    const previousRange = ranges[i - 1];\n    const joinedRange = previousRange.getJoined(ranges[i], true);\n\n    if (joinedRange) {\n      // Replace the ranges on the list with the new joined range.\n      i--;\n      ranges.splice(i, 2, joinedRange);\n    }\n  }\n}\n\nfunction isRangeContainedByAnyOtherRange(range, ranges) {\n  return ranges.some(otherRange => otherRange !== range && otherRange.containsRange(range, true));\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-undo/src/basecommand.js"],"names":["Command","transformSets","BaseCommand","constructor","editor","_stack","_createdBatches","WeakSet","refresh","listenTo","data","evt","options","batchType","priority","clearStack","isEnabled","length","addBatch","batch","docSelection","model","document","selection","ranges","hasOwnRange","Array","from","getRanges","isBackward","push","_restoreSelection","operations","selectionRanges","transformedRangeGroups","map","range","getTransformedByOperations","allRanges","flat","rangeGroup","transformed","filter","root","graveyard","isRangeContainedByAnyOtherRange","normalizeRanges","change","writer","setSelection","backward","_undo","batchToUndo","undoingBatch","add","operationsToUndo","slice","operation","isDocumentOperation","reverse","operationToUndo","nextBaseVersion","baseVersion","historyOperations","history","getOperations","transformedSets","getReversed","useRelations","padWithNoOps","forceWeakRemove","reversedOperations","operationsA","addOperation","applyOperation","setOperationAsUndone","sort","a","b","start","isBefore","i","previousRange","joinedRange","getJoined","splice","some","otherRange","containsRange"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module undo/basecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { transformSets } from '@ckeditor/ckeditor5-engine/src/model/operation/transform';\n\n/**\n * Base class for undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.\n *\n * @protected\n * @extends module:core/command~Command\n */\nexport default class BaseCommand extends Command {\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * Stack of items stored by the command. These are pairs of:\n\t\t *\n\t\t * * {@link module:engine/model/batch~Batch batch} saved by the command,\n\t\t * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array} #_stack\n\t\t */\n\t\tthis._stack = [];\n\n\t\t/**\n\t\t * Stores all batches that were created by this command.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakSet.<module:engine/model/batch~Batch>} #_createdBatches\n\t\t */\n\t\tthis._createdBatches = new WeakSet();\n\n\t\t// Refresh state, so the command is inactive right after initialization.\n\t\tthis.refresh();\n\n\t\t// Set the transparent batch for the `editor.data.set()` call if the\n\t\t// batch type is not set already.\n\t\tthis.listenTo( editor.data, 'set', ( evt, data ) => {\n\t\t\t// Create a shallow copy of the options to not change the original args.\n\t\t\t// And make sure that an object is assigned to data[ 1 ].\n\t\t\tdata[ 1 ] = { ...data[ 1 ] };\n\n\t\t\tconst options = data[ 1 ];\n\n\t\t\tif ( options.batchType ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\toptions.batchType = 'transparent';\n\t\t}, { priority: 'high' } );\n\n\t\t// Clear the stack for the `transparent` batches.\n\t\tthis.listenTo( editor.data, 'set', ( evt, data ) => {\n\t\t\t// We can assume that the object exists - it was ensured\n\t\t\t// with the high priority listener before.\n\t\t\tconst options = data[ 1 ];\n\n\t\t\tif ( options.batchType === 'transparent' ) {\n\t\t\t\tthis.clearStack();\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tthis.isEnabled = this._stack.length > 0;\n\t}\n\n\t/**\n\t * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}\n\t * created by the editor which this command is registered to.\n\t *\n\t * @param {module:engine/model/batch~Batch} batch The batch to add.\n\t */\n\taddBatch( batch ) {\n\t\tconst docSelection = this.editor.model.document.selection;\n\n\t\tconst selection = {\n\t\t\tranges: docSelection.hasOwnRange ? Array.from( docSelection.getRanges() ) : [],\n\t\t\tisBackward: docSelection.isBackward\n\t\t};\n\n\t\tthis._stack.push( { batch, selection } );\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * Removes all items from the stack.\n\t */\n\tclearStack() {\n\t\tthis._stack = [];\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.\n\t *\n\t * @protected\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be restored.\n\t * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.\n\t * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations which has been applied\n\t * since selection has been stored.\n\t */\n\t_restoreSelection( ranges, isBackward, operations ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\n\t\t// This will keep the transformed selection ranges.\n\t\tconst selectionRanges = [];\n\n\t\t// Transform all ranges from the restored selection.\n\t\tconst transformedRangeGroups = ranges.map( range => range.getTransformedByOperations( operations ) );\n\t\tconst allRanges = transformedRangeGroups.flat();\n\n\t\tfor ( const rangeGroup of transformedRangeGroups ) {\n\t\t\t// While transforming there could appear ranges that are contained by other ranges, we shall ignore them.\n\t\t\tconst transformed = rangeGroup\n\t\t\t\t.filter( range => range.root != document.graveyard )\n\t\t\t\t.filter( range => !isRangeContainedByAnyOtherRange( range, allRanges ) );\n\n\t\t\t// All the transformed ranges ended up in graveyard.\n\t\t\tif ( !transformed.length ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// After the range got transformed, we have an array of ranges. Some of those\n\t\t\t// ranges may be \"touching\" -- they can be next to each other and could be merged.\n\t\t\tnormalizeRanges( transformed );\n\n\t\t\t// For each `range` from `ranges`, we take only one transformed range.\n\t\t\t// This is because we want to prevent situation where single-range selection\n\t\t\t// got transformed to multi-range selection.\n\t\t\tselectionRanges.push( transformed[ 0 ] );\n\t\t}\n\n\t\t// @if CK_DEBUG_ENGINE // console.log( `Restored selection by undo: ${ selectionRanges.join( ', ' ) }` );\n\n\t\t// `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.\n\t\tif ( selectionRanges.length ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( selectionRanges, { backward: isBackward } );\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.\n\t * This is a helper method for {@link #execute}.\n\t *\n\t * @protected\n\t * @param {module:engine/model/batch~Batch} batchToUndo The batch to be undone.\n\t * @param {module:engine/model/batch~Batch} undoingBatch The batch that will contain undoing changes.\n\t */\n\t_undo( batchToUndo, undoingBatch ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\n\t\t// All changes done by the command execution will be saved as one batch.\n\t\tthis._createdBatches.add( undoingBatch );\n\n\t\tconst operationsToUndo = batchToUndo.operations.slice().filter( operation => operation.isDocumentOperation );\n\t\toperationsToUndo.reverse();\n\n\t\t// We will process each operation from `batchToUndo`, in reverse order. If there were operations A, B and C in undone batch,\n\t\t// we need to revert them in reverse order, so first C' (reversed C), then B', then A'.\n\t\tfor ( const operationToUndo of operationsToUndo ) {\n\t\t\tconst nextBaseVersion = operationToUndo.baseVersion + 1;\n\t\t\tconst historyOperations = Array.from( document.history.getOperations( nextBaseVersion ) );\n\n\t\t\tconst transformedSets = transformSets(\n\t\t\t\t[ operationToUndo.getReversed() ],\n\t\t\t\thistoryOperations,\n\t\t\t\t{\n\t\t\t\t\tuseRelations: true,\n\t\t\t\t\tdocument: this.editor.model.document,\n\t\t\t\t\tpadWithNoOps: false,\n\t\t\t\t\tforceWeakRemove: true\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tconst reversedOperations = transformedSets.operationsA;\n\n\t\t\t// After reversed operation has been transformed by all history operations, apply it.\n\t\t\tfor ( const operation of reversedOperations ) {\n\t\t\t\t// Before applying, add the operation to the `undoingBatch`.\n\t\t\t\tundoingBatch.addOperation( operation );\n\t\t\t\tmodel.applyOperation( operation );\n\n\t\t\t\tdocument.history.setOperationAsUndone( operationToUndo, operation );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Normalizes list of ranges by joining intersecting or \"touching\" ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges\n//\nfunction normalizeRanges( ranges ) {\n\tranges.sort( ( a, b ) => a.start.isBefore( b.start ) ? -1 : 1 );\n\n\tfor ( let i = 1; i < ranges.length; i++ ) {\n\t\tconst previousRange = ranges[ i - 1 ];\n\t\tconst joinedRange = previousRange.getJoined( ranges[ i ], true );\n\n\t\tif ( joinedRange ) {\n\t\t\t// Replace the ranges on the list with the new joined range.\n\t\t\ti--;\n\t\t\tranges.splice( i, 2, joinedRange );\n\t\t}\n\t}\n}\n\nfunction isRangeContainedByAnyOtherRange( range, ranges ) {\n\treturn ranges.some( otherRange => otherRange !== range && otherRange.containsRange( range, true ) );\n}\n"]},"metadata":{},"sourceType":"module"}