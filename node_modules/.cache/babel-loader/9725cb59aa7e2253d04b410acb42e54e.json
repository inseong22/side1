{"ast":null,"code":"var TAU = Math.PI * 2;\n/**\n * javascript's modulo operator doesn't produce positive numbers with negative input\n * https://www.geeksforgeeks.org/how-to-get-negative-result-using-modulo-operator-in-javascript/\n */\n\nexport var mod = (a, n) => (a % n + n) % n;\n/** distance between points (x, y) and (0, 0) */\n\nvar dist = (x, y) => Math.sqrt(x * x + y * y);\n/**\n * Get the point as the center of the wheel\n */\n\n\nexport function getWheelDimensions(_ref) {\n  var {\n    width = 0\n  } = _ref;\n  var r = width / 2;\n  return {\n    width,\n    radius: r,\n    cx: r,\n    cy: r\n  };\n}\n/**\n * Returns true if point (x, y) lands inside the wheel\n */\n\nexport function isInputInsideWheel(props, x, y) {\n  var {\n    cx,\n    cy,\n    width\n  } = getWheelDimensions(props);\n  var r = width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n/**\n * Get the current handle position for a given color\n */\n\nexport function getWheelHandlePosition(props, hsv) {\n  var {\n    cx,\n    cy\n  } = getWheelDimensions(props);\n  var handleRange = getHandleRange(props);\n  var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  var handleDist = hsv.s / 100 * handleRange;\n  var direction = props.direction === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction\n  };\n}\n/**\n * Get Range\n */\n\nexport function getHandleRange(_ref2) {\n  var {\n    width = 0\n  } = _ref2;\n  return width / 2;\n}\n/**\n * Translate an angle according to wheelAngle and wheelDirection\n */\n\nexport function translateWheelAngle(props, angle, invert) {\n  var wheelAngle = props.angle || 0;\n  var direction = props.direction; // inverted and clockwisee\n\n  if (invert && direction === 'clockwise') angle = wheelAngle + angle; // clockwise (input handling)\n  else if (direction === 'clockwise') angle = 360 - wheelAngle + angle; // inverted and anticlockwise\n    else if (invert && direction === 'anticlockwise') angle = wheelAngle + 180 - angle; // anticlockwise (input handling)\n      else if (direction === 'anticlockwise') angle = wheelAngle - angle;\n  return mod(angle, 360);\n}\n/**\n * Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\n\nexport function getWheelValueFromInput(props, x, y) {\n  var {\n    cx,\n    cy\n  } = getWheelDimensions(props);\n  var handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y; // Calculate the hue by converting the angle to radians\n\n  var hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU)); // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n\n  var handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round(100 / handleRange * handleDist)\n  };\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":["TAU","Math","mod","a","dist","x","y","width","r","radius","cx","cy","getWheelDimensions","handleRange","getHandleRange","handleAngle","translateWheelAngle","hsv","handleDist","direction","props","wheelAngle","invert","angle","hue","h","s"],"mappings":"AAGA,IAAMA,GAAG,GAAGC,IAAI,CAAJA,EAAAA,GAAZ,CAAA;AAEA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,GAAG,GAAG,CAAA,CAAA,EAAA,CAAA,KAA0B,CAAEC,CAAC,GAAF,CAACA,GAAF,CAAA,IAAtC,CAAA;AAEP;;AACA,IAAMC,IAAI,GAAG,CAAA,CAAA,EAAA,CAAA,KAA0BH,IAAI,CAAJA,IAAAA,CAAUI,CAAC,GAADA,CAAAA,GAAQC,CAAC,GAA1D,CAAuCL,CAAvC;AAEA;AACA;AACA;;;AACA,OAAO,SAAA,kBAAA,CAAA,IAAA,EAAgE;AAAA,MAApC;AAAEM,IAAAA,KAAK,GAAG;AAAV,MAAoC,IAAA;AACrE,MAAMC,CAAC,GAAGD,KAAK,GAAf,CAAA;AACA,SAAO;AAAA,IAAA,KAAA;AAELE,IAAAA,MAAM,EAFD,CAAA;AAGLC,IAAAA,EAAE,EAHG,CAAA;AAILC,IAAAA,EAAE,EAAEH;AAJC,GAAP;AAMD;AAED;AACA;AACA;;AACA,OAAO,SAAA,kBAAA,CAAA,KAAA,EAAA,CAAA,EAAA,CAAA,EAA8E;AACnF,MAAM;AAAA,IAAA,EAAA;AAAA,IAAA,EAAA;AAAUD,IAAAA;AAAV,MAAoBK,kBAAkB,CAA5C,KAA4C,CAA5C;AACA,MAAMJ,CAAC,GAAGD,KAAK,GAAf,CAAA;AACA,SAAOH,IAAI,CAACM,EAAE,GAAH,CAAA,EAASC,EAAE,GAAfP,CAAI,CAAJA,GAAP,CAAA;AACD;AAED;AACA;AACA;;AACA,OAAO,SAAA,sBAAA,CAAA,KAAA,EAAA,GAAA,EAA2E;AAChF,MAAM;AAAA,IAAA,EAAA;AAAMO,IAAAA;AAAN,MAAaC,kBAAkB,CAArC,KAAqC,CAArC;AACA,MAAMC,WAAW,GAAGC,cAAc,CAAlC,KAAkC,CAAlC;AACA,MAAMC,WAAW,GAAG,CAAC,MAAMC,mBAAmB,CAAA,KAAA,EAAQC,GAAG,CAAX,CAAA,EAA1B,IAA0B,CAA1B,KAAmDjB,GAAG,GAA1E,GAAoB,CAApB;AACA,MAAMkB,UAAU,GAAID,GAAG,CAAHA,CAAAA,GAAD,GAACA,GAApB,WAAA;AACA,MAAME,SAAS,GAAGC,KAAK,CAALA,SAAAA,KAAAA,WAAAA,GAAkC,CAAlCA,CAAAA,GAAlB,CAAA;AACA,SAAO;AACLf,IAAAA,CAAC,EAAEK,EAAE,GAAGQ,UAAU,GAAGjB,IAAI,CAAJA,GAAAA,CAAbiB,WAAajB,CAAbiB,GADH,SAAA;AAELZ,IAAAA,CAAC,EAAEK,EAAE,GAAGO,UAAU,GAAGjB,IAAI,CAAJA,GAAAA,CAAbiB,WAAajB,CAAbiB,GAAqCC;AAFxC,GAAP;AAID;AAED;AACA;AACA;;AACA,OAAO,SAAA,cAAA,CAAA,KAAA,EAA4D;AAAA,MAApC;AAAEZ,IAAAA,KAAK,GAAG;AAAV,MAAoC,KAAA;AACjE,SAAOA,KAAK,GAAZ,CAAA;AACD;AAED;AACA;AACA;;AACA,OAAO,SAAA,mBAAA,CAAA,KAAA,EAAA,KAAA,EAAA,MAAA,EAA0F;AAC/F,MAAMc,UAAU,GAAGD,KAAK,CAALA,KAAAA,IAAnB,CAAA;AACA,MAAMD,SAAS,GAAGC,KAAK,CAFwE,SAE/F,CAF+F,CAG/F;;AACA,MAAIE,MAAM,IAAIH,SAAS,KAAvB,WAAA,EAAyCI,KAAK,GAAGF,UAAU,GAA3D,KAAyCE,CAAzC,CACA;AADA,OAEK,IAAIJ,SAAS,KAAb,WAAA,EAA+BI,KAAK,GAAG,MAAA,UAAA,GAAvC,KAA+BA,CAA/B,CACL;AADK,SAEA,IAAID,MAAM,IAAIH,SAAS,KAAvB,eAAA,EAA6CI,KAAK,GAAGF,UAAU,GAAVA,GAAAA,GAArD,KAA6CE,CAA7C,CACL;AADK,WAEA,IAAIJ,SAAS,KAAb,eAAA,EAAmCI,KAAK,GAAGF,UAAU,GAAlBE,KAAAA;AACxC,SAAOrB,GAAG,CAAA,KAAA,EAAV,GAAU,CAAV;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,sBAAA,CAAA,KAAA,EAAA,CAAA,EAAA,CAAA,EAAkF;AACvF,MAAM;AAAA,IAAA,EAAA;AAAMS,IAAAA;AAAN,MAAaC,kBAAkB,CAArC,KAAqC,CAArC;AACA,MAAMC,WAAW,GAAGC,cAAc,CAAlC,KAAkC,CAAlC;AACAT,EAAAA,CAAC,GAAGK,EAAE,GAANL,CAAAA;AACAC,EAAAA,CAAC,GAAGK,EAAE,GAJiF,CAIvFL,CAJuF,CAKvF;;AACA,MAAMkB,GAAG,GAAGR,mBAAmB,CAAA,KAAA,EAAQf,IAAI,CAAJA,KAAAA,CAAW,CAAXA,CAAAA,EAAe,CAAfA,CAAAA,KAAsB,MAN0B,GAMhDA,CAAR,CAA/B,CANuF,CAOvF;AACA;;AACA,MAAMiB,UAAU,GAAGjB,IAAI,CAAJA,GAAAA,CAASG,IAAI,CAAA,CAAA,EAAbH,CAAa,CAAbA,EAAnB,WAAmBA,CAAnB;AACA,SAAO;AACLwB,IAAAA,CAAC,EAAExB,IAAI,CAAJA,KAAAA,CADE,GACFA,CADE;AAELyB,IAAAA,CAAC,EAAEzB,IAAI,CAAJA,KAAAA,CAAY,MAAD,WAAC,GAAZA,UAAAA;AAFE,GAAP;AAID","sourcesContent":["import { HsvColor } from '@uiw/color-convert';\nimport { WheelProps } from './';\n\nconst TAU = Math.PI * 2;\n\n/**\n * javascript's modulo operator doesn't produce positive numbers with negative input\n * https://www.geeksforgeeks.org/how-to-get-negative-result-using-modulo-operator-in-javascript/\n */\nexport const mod = (a: number, n: number) => ((a % n) + n) % n;\n\n/** distance between points (x, y) and (0, 0) */\nconst dist = (x: number, y: number) => Math.sqrt(x * x + y * y);\n\n/**\n * Get the point as the center of the wheel\n */\nexport function getWheelDimensions({ width = 0 }: Partial<WheelProps>) {\n  const r = width / 2;\n  return {\n    width,\n    radius: r,\n    cx: r,\n    cy: r,\n  };\n}\n\n/**\n * Returns true if point (x, y) lands inside the wheel\n */\nexport function isInputInsideWheel(props: Partial<WheelProps>, x: number, y: number) {\n  const { cx, cy, width } = getWheelDimensions(props);\n  const r = width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n\n/**\n * Get the current handle position for a given color\n */\nexport function getWheelHandlePosition(props: Partial<WheelProps>, hsv: HsvColor) {\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = getHandleRange(props);\n  const handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  const handleDist = (hsv.s / 100) * handleRange;\n  const direction = props.direction === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction,\n  };\n}\n\n/**\n * Get Range\n */\nexport function getHandleRange({ width = 0 }: Partial<WheelProps>) {\n  return width / 2;\n}\n\n/**\n * Translate an angle according to wheelAngle and wheelDirection\n */\nexport function translateWheelAngle(props: Partial<WheelProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.angle || 0;\n  const direction = props.direction;\n  // inverted and clockwisee\n  if (invert && direction === 'clockwise') angle = wheelAngle + angle;\n  // clockwise (input handling)\n  else if (direction === 'clockwise') angle = 360 - wheelAngle + angle;\n  // inverted and anticlockwise\n  else if (invert && direction === 'anticlockwise') angle = wheelAngle + 180 - angle;\n  // anticlockwise (input handling)\n  else if (direction === 'anticlockwise') angle = wheelAngle - angle;\n  return mod(angle, 360);\n}\n\n/**\n * Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getWheelValueFromInput(props: Partial<WheelProps>, x: number, y: number) {\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  const hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU));\n  // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n  const handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round((100 / handleRange) * handleDist),\n  };\n}\n"]},"metadata":{},"sourceType":"module"}