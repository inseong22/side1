{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/listcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\n/**\n * The list command. It is used by the {@link module:list/list~List list feature}.\n *\n * @extends module:core/command~Command\n */\n\nexport default class ListCommand extends Command {\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   * @param {'numbered'|'bulleted'} type List type that will be handled by this command.\n   */\n  constructor(editor, type) {\n    super(editor);\n    /**\n     * The type of the list created by the command.\n     *\n     * @readonly\n     * @member {'numbered'|'bulleted'|'todo'}\n     */\n\n    this.type = type;\n    /**\n     * A flag indicating whether the command is active, which means that the selection starts in a list of the same type.\n     *\n     * @observable\n     * @readonly\n     * @member {Boolean} #value\n     */\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  refresh() {\n    this.value = this._getValue();\n    this.isEnabled = this._checkEnabled();\n  }\n  /**\n   * Executes the list command.\n   *\n   * @fires execute\n   * @param {Object} [options] Command options.\n   * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will try to convert the\n   * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements\n   * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.\n   */\n\n\n  execute(options = {}) {\n    const model = this.editor.model;\n    const document = model.document;\n    const blocks = Array.from(document.selection.getSelectedBlocks()).filter(block => checkCanBecomeListItem(block, model.schema)); // Whether we are turning off some items.\n\n    const turnOff = options.forceValue !== undefined ? !options.forceValue : this.value; // If we are turning off items, we are going to rename them to paragraphs.\n\n    model.change(writer => {\n      // If part of a list got turned off, we need to handle (outdent) all of sub-items of the last turned-off item.\n      // To be sure that model is all the time in a good state, we first fix items below turned-off item.\n      if (turnOff) {\n        // Start from the model item that is just after the last turned-off item.\n        let next = blocks[blocks.length - 1].nextSibling;\n        let currentIndent = Number.POSITIVE_INFINITY;\n        let changes = []; // Correct indent of all items after the last turned off item.\n        // Rules that should be followed:\n        // 1. All direct sub-items of turned-off item should become indent 0, because the first item after it\n        //    will be the first item of a new list. Other items are at the same level, so should have same 0 index.\n        // 2. All items with indent lower than indent of turned-off item should become indent 0, because they\n        //    should not end up as a child of any of list items that they were not children of before.\n        // 3. All other items should have their indent changed relatively to it's parent.\n        //\n        // For example:\n        // 1  * --------\n        // 2     * --------\n        // 3        * --------\t\t\t<-- this is turned off.\n        // 4           * --------\t\t<-- this has to become indent = 0, because it will be first item on a new list.\n        // 5              * --------\t<-- this should be still be a child of item above, so indent = 1.\n        // 6        * --------\t\t\t<-- this has to become indent = 0, because it should not be a child of any of items above.\n        // 7           * --------\t\t<-- this should be still be a child of item above, so indent = 1.\n        // 8     * --------\t\t\t\t<-- this has to become indent = 0.\n        // 9        * --------\t\t\t<-- this should still be a child of item above, so indent = 1.\n        // 10          * --------\t\t<-- this should still be a child of item above, so indent = 2.\n        // 11          * --------\t\t<-- this should still be at the same level as item above, so indent = 2.\n        // 12 * --------\t\t\t\t<-- this and all below are left unchanged.\n        // 13    * --------\n        // 14       * --------\n        //\n        // After turning off 3 the list becomes:\n        //\n        // 1  * --------\n        // 2     * --------\n        //\n        // 3  --------\n        //\n        // 4  * --------\n        // 5     * --------\n        // 6  * --------\n        // 7     * --------\n        // 8  * --------\n        // 9     * --------\n        // 10       * --------\n        // 11       * --------\n        // 12 * --------\n        // 13    * --------\n        // 14       * --------\n        //\n        // Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while\n        // those parent-child connection which are possible to maintain are still maintained. It's worth noting\n        // that this is the same effect that we would be get by multiple use of outdent command. However doing\n        // it like this is much more efficient because it's less operation (less memory usage, easier OT) and\n        // less conversion (faster).\n\n        while (next && next.name == 'listItem' && next.getAttribute('listIndent') !== 0) {\n          // Check each next list item, as long as its indent is bigger than 0.\n          // If the indent is 0 we are not going to change anything anyway.\n          const indent = next.getAttribute('listIndent'); // We check if that's item indent is lower as current relative indent.\n\n          if (indent < currentIndent) {\n            // If it is, current relative indent becomes that indent.\n            currentIndent = indent;\n          } // Fix indent relatively to current relative indent.\n          // Note, that if we just changed the current relative indent, the newIndent will be equal to 0.\n\n\n          const newIndent = indent - currentIndent; // Save the entry in changes array. We do not apply it at the moment, because we will need to\n          // reverse the changes so the last item is changed first.\n          // This is to keep model in correct state all the time.\n\n          changes.push({\n            element: next,\n            listIndent: newIndent\n          }); // Find next item.\n\n          next = next.nextSibling;\n        }\n\n        changes = changes.reverse();\n\n        for (const item of changes) {\n          writer.setAttribute('listIndent', item.listIndent, item.element);\n        }\n      } // If we are turning on, we might change some items that are already `listItem`s but with different type.\n      // Changing one nested list item to other type should also trigger changing all its siblings so the\n      // whole nested list is of the same type.\n      // Example (assume changing to numbered list):\n      // * ------\t\t\t\t<-- do not fix, top level item\n      //   * ------\t\t\t<-- fix, because latter list item of this item's list is changed\n      //      * ------\t\t<-- do not fix, item is not affected (different list)\n      //   * ------\t\t\t<-- fix, because latter list item of this item's list is changed\n      //      * ------\t\t<-- fix, because latter list item of this item's list is changed\n      //      * ---[--\t\t<-- already in selection\n      //   * ------\t\t\t<-- already in selection\n      //   * ------\t\t\t<-- already in selection\n      // * ------\t\t\t\t<-- already in selection, but does not cause other list items to change because is top-level\n      //   * ---]--\t\t\t<-- already in selection\n      //   * ------\t\t\t<-- fix, because preceding list item of this item's list is changed\n      //      * ------\t\t<-- do not fix, item is not affected (different list)\n      // * ------\t\t\t\t<-- do not fix, top level item\n\n\n      if (!turnOff) {\n        // Find lowest indent among selected items. This will be indicator what is the indent of\n        // top-most list affected by the command.\n        let lowestIndent = Number.POSITIVE_INFINITY;\n\n        for (const item of blocks) {\n          if (item.is('element', 'listItem') && item.getAttribute('listIndent') < lowestIndent) {\n            lowestIndent = item.getAttribute('listIndent');\n          }\n        } // Do not execute the fix for top-level lists.\n\n\n        lowestIndent = lowestIndent === 0 ? 1 : lowestIndent; // Fix types of list items that are \"before\" the selected blocks.\n\n        _fixType(blocks, true, lowestIndent); // Fix types of list items that are \"after\" the selected blocks.\n\n\n        _fixType(blocks, false, lowestIndent);\n      } // Phew! Now it will be easier :).\n      // For each block element that was in the selection, we will either: turn it to list item,\n      // turn it to paragraph, or change it's type. Or leave it as it is.\n      // Do it in reverse as there might be multiple blocks (same as with changing indents).\n\n\n      for (const element of blocks.reverse()) {\n        if (turnOff && element.name == 'listItem') {\n          // We are turning off and the element is a `listItem` - it should be converted to `paragraph`.\n          // List item specific attributes are removed by post fixer.\n          writer.rename(element, 'paragraph');\n        } else if (!turnOff && element.name != 'listItem') {\n          // We are turning on and the element is not a `listItem` - it should be converted to `listItem`.\n          // The order of operations is important to keep model in correct state.\n          writer.setAttributes({\n            listType: this.type,\n            listIndent: 0\n          }, element);\n          writer.rename(element, 'listItem');\n        } else if (!turnOff && element.name == 'listItem' && element.getAttribute('listType') != this.type) {\n          // We are turning on and the element is a `listItem` but has different type - change it's type and\n          // type of it's all siblings that have same indent.\n          writer.setAttribute('listType', this.type, element);\n        }\n      }\n      /**\n       * Event fired by the {@link #execute} method.\n       *\n       * It allows to execute an action after executing the {@link ~ListCommand#execute} method, for example adjusting\n       * attributes of changed blocks.\n       *\n       * @protected\n       * @event _executeCleanup\n       */\n\n\n      this.fire('_executeCleanup', blocks);\n    });\n  }\n  /**\n   * Checks the command's {@link #value}.\n   *\n   * @private\n   * @returns {Boolean} The current value.\n   */\n\n\n  _getValue() {\n    // Check whether closest `listItem` ancestor of the position has a correct type.\n    const listItem = first(this.editor.model.document.selection.getSelectedBlocks());\n    return !!listItem && listItem.is('element', 'listItem') && listItem.getAttribute('listType') == this.type;\n  }\n  /**\n   * Checks whether the command can be enabled in the current context.\n   *\n   * @private\n   * @returns {Boolean} Whether the command should be enabled.\n   */\n\n\n  _checkEnabled() {\n    // If command value is true it means that we are in list item, so the command should be enabled.\n    if (this.value) {\n      return true;\n    }\n\n    const selection = this.editor.model.document.selection;\n    const schema = this.editor.model.schema;\n    const firstBlock = first(selection.getSelectedBlocks());\n\n    if (!firstBlock) {\n      return false;\n    } // Otherwise, check if list item can be inserted at the position start.\n\n\n    return checkCanBecomeListItem(firstBlock, schema);\n  }\n\n} // Helper function used when one or more list item have their type changed. Fixes type of other list items\n// that are affected by the change (are in same lists) but are not directly in selection. The function got extracted\n// not to duplicated code, as same fix has to be performed before and after selection.\n//\n// @param {Array.<module:engine/model/node~Node>} blocks Blocks that are in selection.\n// @param {Boolean} isBackward Specified whether fix will be applied for blocks before first selected block (`true`)\n// or blocks after last selected block (`false`).\n// @param {Number} lowestIndent Lowest indent among selected blocks.\n\nfunction _fixType(blocks, isBackward, lowestIndent) {\n  // We need to check previous sibling of first changed item and next siblings of last changed item.\n  const startingItem = isBackward ? blocks[0] : blocks[blocks.length - 1];\n\n  if (startingItem.is('element', 'listItem')) {\n    let item = startingItem[isBackward ? 'previousSibling' : 'nextSibling']; // During processing items, keeps the lowest indent of already processed items.\n    // This saves us from changing too many items.\n    // Following example is for going forward as it is easier to read, however same applies to going backward.\n    // * ------\n    //   * ------\n    //     * --[---\n    //   * ------\t\t<-- `lowestIndent` should be 1\n    //     * --]---\t\t<-- `startingItem`, `currentIndent` = 2, `lowestIndent` == 1\n    //     * ------\t\t<-- should be fixed, `indent` == 2 == `currentIndent`\n    //   * ------\t\t<-- should be fixed, set `currentIndent` to 1, `indent` == 1 == `currentIndent`\n    //     * ------\t\t<-- should not be fixed, item is in different list, `indent` = 2, `indent` != `currentIndent`\n    //   * ------\t\t<-- should be fixed, `indent` == 1 == `currentIndent`\n    // * ------\t\t\t<-- break loop (`indent` < `lowestIndent`)\n\n    let currentIndent = startingItem.getAttribute('listIndent'); // Look back until a list item with indent lower than reference `lowestIndent`.\n    // That would be the parent of nested sublist which contains item having `lowestIndent`.\n\n    while (item && item.is('element', 'listItem') && item.getAttribute('listIndent') >= lowestIndent) {\n      if (currentIndent > item.getAttribute('listIndent')) {\n        currentIndent = item.getAttribute('listIndent');\n      } // Found an item that is in the same nested sublist.\n\n\n      if (item.getAttribute('listIndent') == currentIndent) {\n        // Just add the item to selected blocks like it was selected by the user.\n        blocks[isBackward ? 'unshift' : 'push'](item);\n      }\n\n      item = item[isBackward ? 'previousSibling' : 'nextSibling'];\n    }\n  }\n} // Checks whether the given block can be replaced by a listItem.\n//\n// @private\n// @param {module:engine/model/element~Element} block A block to be tested.\n// @param {module:engine/model/schema~Schema} schema The schema of the document.\n// @returns {Boolean}\n\n\nfunction checkCanBecomeListItem(block, schema) {\n  return schema.checkChild(block.parent, 'listItem') && !schema.isObject(block);\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-list/src/listcommand.js"],"names":["Command","first","ListCommand","constructor","editor","type","refresh","value","_getValue","isEnabled","_checkEnabled","execute","options","model","document","blocks","Array","from","selection","getSelectedBlocks","filter","block","checkCanBecomeListItem","schema","turnOff","forceValue","undefined","change","writer","next","length","nextSibling","currentIndent","Number","POSITIVE_INFINITY","changes","name","getAttribute","indent","newIndent","push","element","listIndent","reverse","item","setAttribute","lowestIndent","is","_fixType","rename","setAttributes","listType","fire","listItem","firstBlock","isBackward","startingItem","checkChild","parent","isObject"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/listcommand\n */\n\nimport { Command } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\n\n/**\n * The list command. It is used by the {@link module:list/list~List list feature}.\n *\n * @extends module:core/command~Command\n */\nexport default class ListCommand extends Command {\n\t/**\n\t * Creates an instance of the command.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor instance.\n\t * @param {'numbered'|'bulleted'} type List type that will be handled by this command.\n\t */\n\tconstructor( editor, type ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The type of the list created by the command.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'numbered'|'bulleted'|'todo'}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * A flag indicating whether the command is active, which means that the selection starts in a list of the same type.\n\t\t *\n\t\t * @observable\n\t\t * @readonly\n\t\t * @member {Boolean} #value\n\t\t */\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tthis.value = this._getValue();\n\t\tthis.isEnabled = this._checkEnabled();\n\t}\n\n\t/**\n\t * Executes the list command.\n\t *\n\t * @fires execute\n\t * @param {Object} [options] Command options.\n\t * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will try to convert the\n\t * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements\n\t * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\t\tconst blocks = Array.from( document.selection.getSelectedBlocks() )\n\t\t\t.filter( block => checkCanBecomeListItem( block, model.schema ) );\n\n\t\t// Whether we are turning off some items.\n\t\tconst turnOff = options.forceValue !== undefined ? !options.forceValue : this.value;\n\n\t\t// If we are turning off items, we are going to rename them to paragraphs.\n\n\t\tmodel.change( writer => {\n\t\t\t// If part of a list got turned off, we need to handle (outdent) all of sub-items of the last turned-off item.\n\t\t\t// To be sure that model is all the time in a good state, we first fix items below turned-off item.\n\t\t\tif ( turnOff ) {\n\t\t\t\t// Start from the model item that is just after the last turned-off item.\n\t\t\t\tlet next = blocks[ blocks.length - 1 ].nextSibling;\n\t\t\t\tlet currentIndent = Number.POSITIVE_INFINITY;\n\t\t\t\tlet changes = [];\n\n\t\t\t\t// Correct indent of all items after the last turned off item.\n\t\t\t\t// Rules that should be followed:\n\t\t\t\t// 1. All direct sub-items of turned-off item should become indent 0, because the first item after it\n\t\t\t\t//    will be the first item of a new list. Other items are at the same level, so should have same 0 index.\n\t\t\t\t// 2. All items with indent lower than indent of turned-off item should become indent 0, because they\n\t\t\t\t//    should not end up as a child of any of list items that they were not children of before.\n\t\t\t\t// 3. All other items should have their indent changed relatively to it's parent.\n\t\t\t\t//\n\t\t\t\t// For example:\n\t\t\t\t// 1  * --------\n\t\t\t\t// 2     * --------\n\t\t\t\t// 3        * --------\t\t\t<-- this is turned off.\n\t\t\t\t// 4           * --------\t\t<-- this has to become indent = 0, because it will be first item on a new list.\n\t\t\t\t// 5              * --------\t<-- this should be still be a child of item above, so indent = 1.\n\t\t\t\t// 6        * --------\t\t\t<-- this has to become indent = 0, because it should not be a child of any of items above.\n\t\t\t\t// 7           * --------\t\t<-- this should be still be a child of item above, so indent = 1.\n\t\t\t\t// 8     * --------\t\t\t\t<-- this has to become indent = 0.\n\t\t\t\t// 9        * --------\t\t\t<-- this should still be a child of item above, so indent = 1.\n\t\t\t\t// 10          * --------\t\t<-- this should still be a child of item above, so indent = 2.\n\t\t\t\t// 11          * --------\t\t<-- this should still be at the same level as item above, so indent = 2.\n\t\t\t\t// 12 * --------\t\t\t\t<-- this and all below are left unchanged.\n\t\t\t\t// 13    * --------\n\t\t\t\t// 14       * --------\n\t\t\t\t//\n\t\t\t\t// After turning off 3 the list becomes:\n\t\t\t\t//\n\t\t\t\t// 1  * --------\n\t\t\t\t// 2     * --------\n\t\t\t\t//\n\t\t\t\t// 3  --------\n\t\t\t\t//\n\t\t\t\t// 4  * --------\n\t\t\t\t// 5     * --------\n\t\t\t\t// 6  * --------\n\t\t\t\t// 7     * --------\n\t\t\t\t// 8  * --------\n\t\t\t\t// 9     * --------\n\t\t\t\t// 10       * --------\n\t\t\t\t// 11       * --------\n\t\t\t\t// 12 * --------\n\t\t\t\t// 13    * --------\n\t\t\t\t// 14       * --------\n\t\t\t\t//\n\t\t\t\t// Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while\n\t\t\t\t// those parent-child connection which are possible to maintain are still maintained. It's worth noting\n\t\t\t\t// that this is the same effect that we would be get by multiple use of outdent command. However doing\n\t\t\t\t// it like this is much more efficient because it's less operation (less memory usage, easier OT) and\n\t\t\t\t// less conversion (faster).\n\t\t\t\twhile ( next && next.name == 'listItem' && next.getAttribute( 'listIndent' ) !== 0 ) {\n\t\t\t\t\t// Check each next list item, as long as its indent is bigger than 0.\n\t\t\t\t\t// If the indent is 0 we are not going to change anything anyway.\n\t\t\t\t\tconst indent = next.getAttribute( 'listIndent' );\n\n\t\t\t\t\t// We check if that's item indent is lower as current relative indent.\n\t\t\t\t\tif ( indent < currentIndent ) {\n\t\t\t\t\t\t// If it is, current relative indent becomes that indent.\n\t\t\t\t\t\tcurrentIndent = indent;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fix indent relatively to current relative indent.\n\t\t\t\t\t// Note, that if we just changed the current relative indent, the newIndent will be equal to 0.\n\t\t\t\t\tconst newIndent = indent - currentIndent;\n\n\t\t\t\t\t// Save the entry in changes array. We do not apply it at the moment, because we will need to\n\t\t\t\t\t// reverse the changes so the last item is changed first.\n\t\t\t\t\t// This is to keep model in correct state all the time.\n\t\t\t\t\tchanges.push( { element: next, listIndent: newIndent } );\n\n\t\t\t\t\t// Find next item.\n\t\t\t\t\tnext = next.nextSibling;\n\t\t\t\t}\n\n\t\t\t\tchanges = changes.reverse();\n\n\t\t\t\tfor ( const item of changes ) {\n\t\t\t\t\twriter.setAttribute( 'listIndent', item.listIndent, item.element );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are turning on, we might change some items that are already `listItem`s but with different type.\n\t\t\t// Changing one nested list item to other type should also trigger changing all its siblings so the\n\t\t\t// whole nested list is of the same type.\n\t\t\t// Example (assume changing to numbered list):\n\t\t\t// * ------\t\t\t\t<-- do not fix, top level item\n\t\t\t//   * ------\t\t\t<-- fix, because latter list item of this item's list is changed\n\t\t\t//      * ------\t\t<-- do not fix, item is not affected (different list)\n\t\t\t//   * ------\t\t\t<-- fix, because latter list item of this item's list is changed\n\t\t\t//      * ------\t\t<-- fix, because latter list item of this item's list is changed\n\t\t\t//      * ---[--\t\t<-- already in selection\n\t\t\t//   * ------\t\t\t<-- already in selection\n\t\t\t//   * ------\t\t\t<-- already in selection\n\t\t\t// * ------\t\t\t\t<-- already in selection, but does not cause other list items to change because is top-level\n\t\t\t//   * ---]--\t\t\t<-- already in selection\n\t\t\t//   * ------\t\t\t<-- fix, because preceding list item of this item's list is changed\n\t\t\t//      * ------\t\t<-- do not fix, item is not affected (different list)\n\t\t\t// * ------\t\t\t\t<-- do not fix, top level item\n\t\t\tif ( !turnOff ) {\n\t\t\t\t// Find lowest indent among selected items. This will be indicator what is the indent of\n\t\t\t\t// top-most list affected by the command.\n\t\t\t\tlet lowestIndent = Number.POSITIVE_INFINITY;\n\n\t\t\t\tfor ( const item of blocks ) {\n\t\t\t\t\tif ( item.is( 'element', 'listItem' ) && item.getAttribute( 'listIndent' ) < lowestIndent ) {\n\t\t\t\t\t\tlowestIndent = item.getAttribute( 'listIndent' );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Do not execute the fix for top-level lists.\n\t\t\t\tlowestIndent = lowestIndent === 0 ? 1 : lowestIndent;\n\n\t\t\t\t// Fix types of list items that are \"before\" the selected blocks.\n\t\t\t\t_fixType( blocks, true, lowestIndent );\n\n\t\t\t\t// Fix types of list items that are \"after\" the selected blocks.\n\t\t\t\t_fixType( blocks, false, lowestIndent );\n\t\t\t}\n\n\t\t\t// Phew! Now it will be easier :).\n\t\t\t// For each block element that was in the selection, we will either: turn it to list item,\n\t\t\t// turn it to paragraph, or change it's type. Or leave it as it is.\n\t\t\t// Do it in reverse as there might be multiple blocks (same as with changing indents).\n\t\t\tfor ( const element of blocks.reverse() ) {\n\t\t\t\tif ( turnOff && element.name == 'listItem' ) {\n\t\t\t\t\t// We are turning off and the element is a `listItem` - it should be converted to `paragraph`.\n\t\t\t\t\t// List item specific attributes are removed by post fixer.\n\t\t\t\t\twriter.rename( element, 'paragraph' );\n\t\t\t\t} else if ( !turnOff && element.name != 'listItem' ) {\n\t\t\t\t\t// We are turning on and the element is not a `listItem` - it should be converted to `listItem`.\n\t\t\t\t\t// The order of operations is important to keep model in correct state.\n\t\t\t\t\twriter.setAttributes( { listType: this.type, listIndent: 0 }, element );\n\t\t\t\t\twriter.rename( element, 'listItem' );\n\t\t\t\t} else if ( !turnOff && element.name == 'listItem' && element.getAttribute( 'listType' ) != this.type ) {\n\t\t\t\t\t// We are turning on and the element is a `listItem` but has different type - change it's type and\n\t\t\t\t\t// type of it's all siblings that have same indent.\n\t\t\t\t\twriter.setAttribute( 'listType', this.type, element );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Event fired by the {@link #execute} method.\n\t\t\t *\n\t\t\t * It allows to execute an action after executing the {@link ~ListCommand#execute} method, for example adjusting\n\t\t\t * attributes of changed blocks.\n\t\t\t *\n\t\t\t * @protected\n\t\t\t * @event _executeCleanup\n\t\t\t */\n\t\t\tthis.fire( '_executeCleanup', blocks );\n\t\t} );\n\t}\n\n\t/**\n\t * Checks the command's {@link #value}.\n\t *\n\t * @private\n\t * @returns {Boolean} The current value.\n\t */\n\t_getValue() {\n\t\t// Check whether closest `listItem` ancestor of the position has a correct type.\n\t\tconst listItem = first( this.editor.model.document.selection.getSelectedBlocks() );\n\n\t\treturn !!listItem && listItem.is( 'element', 'listItem' ) && listItem.getAttribute( 'listType' ) == this.type;\n\t}\n\n\t/**\n\t * Checks whether the command can be enabled in the current context.\n\t *\n\t * @private\n\t * @returns {Boolean} Whether the command should be enabled.\n\t */\n\t_checkEnabled() {\n\t\t// If command value is true it means that we are in list item, so the command should be enabled.\n\t\tif ( this.value ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst selection = this.editor.model.document.selection;\n\t\tconst schema = this.editor.model.schema;\n\n\t\tconst firstBlock = first( selection.getSelectedBlocks() );\n\n\t\tif ( !firstBlock ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Otherwise, check if list item can be inserted at the position start.\n\t\treturn checkCanBecomeListItem( firstBlock, schema );\n\t}\n}\n\n// Helper function used when one or more list item have their type changed. Fixes type of other list items\n// that are affected by the change (are in same lists) but are not directly in selection. The function got extracted\n// not to duplicated code, as same fix has to be performed before and after selection.\n//\n// @param {Array.<module:engine/model/node~Node>} blocks Blocks that are in selection.\n// @param {Boolean} isBackward Specified whether fix will be applied for blocks before first selected block (`true`)\n// or blocks after last selected block (`false`).\n// @param {Number} lowestIndent Lowest indent among selected blocks.\nfunction _fixType( blocks, isBackward, lowestIndent ) {\n\t// We need to check previous sibling of first changed item and next siblings of last changed item.\n\tconst startingItem = isBackward ? blocks[ 0 ] : blocks[ blocks.length - 1 ];\n\n\tif ( startingItem.is( 'element', 'listItem' ) ) {\n\t\tlet item = startingItem[ isBackward ? 'previousSibling' : 'nextSibling' ];\n\t\t// During processing items, keeps the lowest indent of already processed items.\n\t\t// This saves us from changing too many items.\n\t\t// Following example is for going forward as it is easier to read, however same applies to going backward.\n\t\t// * ------\n\t\t//   * ------\n\t\t//     * --[---\n\t\t//   * ------\t\t<-- `lowestIndent` should be 1\n\t\t//     * --]---\t\t<-- `startingItem`, `currentIndent` = 2, `lowestIndent` == 1\n\t\t//     * ------\t\t<-- should be fixed, `indent` == 2 == `currentIndent`\n\t\t//   * ------\t\t<-- should be fixed, set `currentIndent` to 1, `indent` == 1 == `currentIndent`\n\t\t//     * ------\t\t<-- should not be fixed, item is in different list, `indent` = 2, `indent` != `currentIndent`\n\t\t//   * ------\t\t<-- should be fixed, `indent` == 1 == `currentIndent`\n\t\t// * ------\t\t\t<-- break loop (`indent` < `lowestIndent`)\n\t\tlet currentIndent = startingItem.getAttribute( 'listIndent' );\n\n\t\t// Look back until a list item with indent lower than reference `lowestIndent`.\n\t\t// That would be the parent of nested sublist which contains item having `lowestIndent`.\n\t\twhile ( item && item.is( 'element', 'listItem' ) && item.getAttribute( 'listIndent' ) >= lowestIndent ) {\n\t\t\tif ( currentIndent > item.getAttribute( 'listIndent' ) ) {\n\t\t\t\tcurrentIndent = item.getAttribute( 'listIndent' );\n\t\t\t}\n\n\t\t\t// Found an item that is in the same nested sublist.\n\t\t\tif ( item.getAttribute( 'listIndent' ) == currentIndent ) {\n\t\t\t\t// Just add the item to selected blocks like it was selected by the user.\n\t\t\t\tblocks[ isBackward ? 'unshift' : 'push' ]( item );\n\t\t\t}\n\n\t\t\titem = item[ isBackward ? 'previousSibling' : 'nextSibling' ];\n\t\t}\n\t}\n}\n\n// Checks whether the given block can be replaced by a listItem.\n//\n// @private\n// @param {module:engine/model/element~Element} block A block to be tested.\n// @param {module:engine/model/schema~Schema} schema The schema of the document.\n// @returns {Boolean}\nfunction checkCanBecomeListItem( block, schema ) {\n\treturn schema.checkChild( block.parent, 'listItem' ) && !schema.isObject( block );\n}\n"]},"metadata":{},"sourceType":"module"}