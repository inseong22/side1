{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/element\n */\nimport Node from './node';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Matcher from './matcher';\nimport StylesMap from './stylesmap'; // @if CK_DEBUG_ENGINE // const { convertMapToTags } = require( '../dev-utils/utils' );\n\n/**\n * View element.\n *\n * The editing engine does not define a fixed semantics of its elements (it is \"DTD-free\").\n * This is why the type of the {@link module:engine/view/element~Element} need to\n * be defined by the feature developer. When creating an element you should use one of the following methods:\n *\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement `downcastWriter#createContainerElement()`}\n * in order to create a {@link module:engine/view/containerelement~ContainerElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement `downcastWriter#createAttributeElement()`}\n * in order to create a {@link module:engine/view/attributeelement~AttributeElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`}\n * in order to create a {@link module:engine/view/emptyelement~EmptyElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}\n * in order to create a {@link module:engine/view/uielement~UIElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`}\n * in order to create a {@link module:engine/view/editableelement~EditableElement}.\n *\n * Note that for view elements which are not created from the model, like elements from mutations, paste or\n * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element.\n * In such cases the {@link module:engine/view/upcastwriter~UpcastWriter#createElement `UpcastWriter#createElement()`} method\n * should be used to create generic view elements.\n *\n * @extends module:engine/view/node~Node\n */\n\nexport default class Element extends Node {\n  /**\n   * Creates a view element.\n   *\n   * Attributes can be passed in various formats:\n   *\n   *\t\tnew Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object\n   *\t\tnew Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator\n   *\t\tnew Element( viewDocument, 'div', mapOfAttributes ); // map\n   *\n   * @protected\n   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n   * @param {String} name Node name.\n   * @param {Object|Iterable} [attrs] Collection of attributes.\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into created element.\n   */\n  constructor(document, name, attrs, children) {\n    super(document);\n    /**\n     * Name of the element.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n    this.name = name;\n    /**\n     * Map of attributes, where attributes names are keys and attributes values are values.\n     *\n     * @protected\n     * @member {Map} #_attrs\n     */\n\n    this._attrs = parseAttributes(attrs);\n    /**\n     * Array of child nodes.\n     *\n     * @protected\n     * @member {Array.<module:engine/view/node~Node>}\n     */\n\n    this._children = [];\n\n    if (children) {\n      this._insertChild(0, children);\n    }\n    /**\n     * Set of classes associated with element instance.\n     *\n     * @protected\n     * @member {Set}\n     */\n\n\n    this._classes = new Set();\n\n    if (this._attrs.has('class')) {\n      // Remove class attribute and handle it by class set.\n      const classString = this._attrs.get('class');\n\n      parseClasses(this._classes, classString);\n\n      this._attrs.delete('class');\n    }\n    /**\n     * Normalized styles.\n     *\n     * @protected\n     * @member {module:engine/view/stylesmap~StylesMap} module:engine/view/element~Element#_styles\n     */\n\n\n    this._styles = new StylesMap(this.document.stylesProcessor);\n\n    if (this._attrs.has('style')) {\n      // Remove style attribute and handle it by styles map.\n      this._styles.setTo(this._attrs.get('style'));\n\n      this._attrs.delete('style');\n    }\n    /**\n     * Map of custom properties.\n     * Custom properties can be added to element instance, will be cloned but not rendered into DOM.\n     *\n     * @protected\n     * @member {Map}\n     */\n\n\n    this._customProperties = new Map();\n    /**\n     * Whether an element is allowed inside an AttributeElement and can be wrapped with\n     * {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n     *\n     * @protected\n     * @member {Boolean}\n     */\n\n    this._isAllowedInsideAttributeElement = false;\n    /**\n     * A list of attribute names that should be rendered in the editing pipeline even though filtering mechanisms\n     * implemented in the {@link module:engine/view/domconverter~DomConverter} (for instance,\n     * {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute}) would filter them out.\n     *\n     * These attributes can be specified as an option when the element is created by\n     * the {@link module:engine/view/downcastwriter~DowncastWriter}. To check whether an unsafe an attribute should\n     * be permitted, use the {@link #shouldRenderUnsafeAttribute} method.\n     *\n     * @private\n     * @readonly\n     * @member {Array.<String>}\n     */\n\n    this._unsafeAttributesToRender = [];\n  }\n  /**\n   * Number of element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get childCount() {\n    return this._children.length;\n  }\n  /**\n   * Is `true` if there are no nodes inside this element, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isEmpty() {\n    return this._children.length === 0;\n  }\n  /**\n   * Whether the element is allowed inside an AttributeElement and can be wrapped with\n   * {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isAllowedInsideAttributeElement() {\n    return this._isAllowedInsideAttributeElement;\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\telement.is( 'element' ); // -> true\n   *\t\telement.is( 'node' ); // -> true\n   *\t\telement.is( 'view:element' ); // -> true\n   *\t\telement.is( 'view:node' ); // -> true\n   *\n   *\t\telement.is( 'model:element' ); // -> false\n   *\t\telement.is( 'documentSelection' ); // -> false\n   *\n   * Assuming that the object being checked is an element, you can also check its\n   * {@link module:engine/view/element~Element#name name}:\n   *\n   *\t\telement.is( 'element', 'img' ); // -> true if this is an <img> element\n   *\t\ttext.is( 'element', 'img' ); -> false\n   *\n   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n   *\n   * @param {String} type Type to check.\n   * @param {String} [name] Element name.\n   * @returns {Boolean}\n   */\n\n\n  is(type, name = null) {\n    if (!name) {\n      return type === 'element' || type === 'view:element' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n      type === 'node' || type === 'view:node';\n    } else {\n      return name === this.name && (type === 'element' || type === 'view:element');\n    }\n  }\n  /**\n   * Gets child at the given index.\n   *\n   * @param {Number} index Index of child.\n   * @returns {module:engine/view/node~Node} Child node.\n   */\n\n\n  getChild(index) {\n    return this._children[index];\n  }\n  /**\n   * Gets index of the given child node. Returns `-1` if child node is not found.\n   *\n   * @param {module:engine/view/node~Node} node Child node.\n   * @returns {Number} Index of the child node.\n   */\n\n\n  getChildIndex(node) {\n    return this._children.indexOf(node);\n  }\n  /**\n   * Gets child nodes iterator.\n   *\n   * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n   */\n\n\n  getChildren() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.\n   *\n   * @returns {Iterable.<String>} Keys for attributes.\n   */\n\n\n  *getAttributeKeys() {\n    if (this._classes.size > 0) {\n      yield 'class';\n    }\n\n    if (!this._styles.isEmpty) {\n      yield 'style';\n    }\n\n    yield* this._attrs.keys();\n  }\n  /**\n   * Returns iterator that iterates over this element's attributes.\n   *\n   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  *getAttributes() {\n    yield* this._attrs.entries();\n\n    if (this._classes.size > 0) {\n      yield ['class', this.getAttribute('class')];\n    }\n\n    if (!this._styles.isEmpty) {\n      yield ['style', this.getAttribute('style')];\n    }\n  }\n  /**\n   * Gets attribute by key. If attribute is not present - returns undefined.\n   *\n   * @param {String} key Attribute key.\n   * @returns {String|undefined} Attribute value.\n   */\n\n\n  getAttribute(key) {\n    if (key == 'class') {\n      if (this._classes.size > 0) {\n        return [...this._classes].join(' ');\n      }\n\n      return undefined;\n    }\n\n    if (key == 'style') {\n      const inlineStyle = this._styles.toString();\n\n      return inlineStyle == '' ? undefined : inlineStyle;\n    }\n\n    return this._attrs.get(key);\n  }\n  /**\n   * Returns a boolean indicating whether an attribute with the specified key exists in the element.\n   *\n   * @param {String} key Attribute key.\n   * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.\n   */\n\n\n  hasAttribute(key) {\n    if (key == 'class') {\n      return this._classes.size > 0;\n    }\n\n    if (key == 'style') {\n      return !this._styles.isEmpty;\n    }\n\n    return this._attrs.has(key);\n  }\n  /**\n   * Checks if this element is similar to other element.\n   * Both elements should have the same name and attributes to be considered as similar. Two similar elements\n   * can contain different set of children nodes.\n   *\n   * @param {module:engine/view/element~Element} otherElement\n   * @returns {Boolean}\n   */\n\n\n  isSimilar(otherElement) {\n    if (!(otherElement instanceof Element)) {\n      return false;\n    } // If exactly the same Element is provided - return true immediately.\n\n\n    if (this === otherElement) {\n      return true;\n    } // Check element name.\n\n\n    if (this.name != otherElement.name) {\n      return false;\n    } // Check isAllowedInsideAttributeElement property.\n\n\n    if (this.isAllowedInsideAttributeElement != otherElement.isAllowedInsideAttributeElement) {\n      return false;\n    } // Check number of attributes, classes and styles.\n\n\n    if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {\n      return false;\n    } // Check if attributes are the same.\n\n\n    for (const [key, value] of this._attrs) {\n      if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {\n        return false;\n      }\n    } // Check if classes are the same.\n\n\n    for (const className of this._classes) {\n      if (!otherElement._classes.has(className)) {\n        return false;\n      }\n    } // Check if styles are the same.\n\n\n    for (const property of this._styles.getStyleNames()) {\n      if (!otherElement._styles.has(property) || otherElement._styles.getAsString(property) !== this._styles.getAsString(property)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns true if class is present.\n   * If more then one class is provided - returns true only when all classes are present.\n   *\n   *\t\telement.hasClass( 'foo' ); // Returns true if 'foo' class is present.\n   *\t\telement.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.\n   *\n   * @param {...String} className\n   */\n\n\n  hasClass(...className) {\n    for (const name of className) {\n      if (!this._classes.has(name)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns iterator that contains all class names.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  getClassNames() {\n    return this._classes.keys();\n  }\n  /**\n   * Returns style value for the given property mae.\n   * If the style does not exist `undefined` is returned.\n   *\n   * **Note**: This method can work with normalized style names if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.\n   *\n   * For an element with style set to `'margin:1px'`:\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tconst element = view.change( writer => {\n   *\t\t\tconst element = writer.createElement();\n   *\t\t\twriter.setStyle( 'margin', '1px' );\n   *\t\t\twriter.setStyle( 'margin-bottom', '3em' );\n   *\n   *\t\t\treturn element;\n   *\t\t} );\n   *\n   *\t\telement.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'\n   *\n   * @param {String} property\n   * @returns {String|undefined}\n   */\n\n\n  getStyle(property) {\n    return this._styles.getAsString(property);\n  }\n  /**\n   * Returns a normalized style object or single style value.\n   *\n   * For an element with style set to: margin:1px 2px 3em;\n   *\n   *\t\telement.getNormalizedStyle( 'margin' ) );\n   *\n   * will return:\n   *\n   *\t\t{\n   *\t\t\ttop: '1px',\n   *\t\t\tright: '2px',\n   *\t\t\tbottom: '3em',\n   *\t\t\tleft: '2px'    // a normalized value from margin shorthand\n   *\t\t}\n   *\n   * and reading for single style value:\n   *\n   *\t\tstyles.getNormalizedStyle( 'margin-left' );\n   *\n   * Will return a `2px` string.\n   *\n   * **Note**: This method will return normalized values only if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.\n   *\n   *\n   * @param {String} property Name of CSS property\n   * @returns {Object|String|undefined}\n   */\n\n\n  getNormalizedStyle(property) {\n    return this._styles.getNormalized(property);\n  }\n  /**\n   * Returns iterator that contains all style names.\n   *\n   * @param {Boolean} [expand=false] Expand shorthand style properties and return all equivalent style representations.\n   * @returns {Iterable.<String>}\n   */\n\n\n  getStyleNames(expand = false) {\n    return this._styles.getStyleNames(expand);\n  }\n  /**\n   * Returns true if style keys are present.\n   * If more then one style property is provided - returns true only when all properties are present.\n   *\n   *\t\telement.hasStyle( 'color' ); // Returns true if 'border-top' style is present.\n   *\t\telement.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.\n   *\n   * @param {...String} property\n   */\n\n\n  hasStyle(...property) {\n    for (const name of property) {\n      if (!this._styles.has(name)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns ancestor element that match specified pattern.\n   * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.\n   *\n   * @see module:engine/view/matcher~Matcher\n   * @param {Object|String|RegExp|Function} patterns Patterns used to match correct ancestor.\n   * See {@link module:engine/view/matcher~Matcher}.\n   * @returns {module:engine/view/element~Element|null} Found element or `null` if no matching ancestor was found.\n   */\n\n\n  findAncestor(...patterns) {\n    const matcher = new Matcher(...patterns);\n    let parent = this.parent;\n\n    while (parent) {\n      if (matcher.match(parent)) {\n        return parent;\n      }\n\n      parent = parent.parent;\n    }\n\n    return null;\n  }\n  /**\n   * Returns the custom property value for the given key.\n   *\n   * @param {String|Symbol} key\n   * @returns {*}\n   */\n\n\n  getCustomProperty(key) {\n    return this._customProperties.get(key);\n  }\n  /**\n   * Returns an iterator which iterates over this element's custom properties.\n   * Iterator provides `[ key, value ]` pairs for each stored property.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  *getCustomProperties() {\n    yield* this._customProperties.entries();\n  }\n  /**\n   * Returns identity string based on element's name, styles, classes and other attributes.\n   * Two elements that {@link #isSimilar are similar} will have same identity string.\n   * It has the following format:\n   *\n   *\t\t'name class=\"class1,class2\" style=\"style1:value1;style2:value2\" attr1=\"val1\" attr2=\"val2\"'\n  \t *\n   * For example:\n   *\n   *\t\tconst element = writer.createContainerElement( 'foo', {\n   *\t\t\tbanana: '10',\n   *\t\t\tapple: '20',\n   *\t\t\tstyle: 'color: red; border-color: white;',\n   *\t\t\tclass: 'baz'\n   *\t\t} );\n   *\n   *\t\t// returns 'foo class=\"baz\" style=\"border-color:white;color:red\" apple=\"20\" banana=\"10\"'\n   *\t\telement.getIdentity();\n   *\n   * **Note**: Classes, styles and other attributes are sorted alphabetically.\n   *\n   * @returns {String}\n   */\n\n\n  getIdentity() {\n    const classes = Array.from(this._classes).sort().join(',');\n\n    const styles = this._styles.toString();\n\n    const attributes = Array.from(this._attrs).map(i => `${i[0]}=\"${i[1]}\"`).sort().join(' ');\n    return this.name + (classes == '' ? '' : ` class=\"${classes}\"`) + (!styles ? '' : ` style=\"${styles}\"`) + (attributes == '' ? '' : ` ${attributes}`);\n  }\n  /**\n   * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms\n   * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.\n   *\n   * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.\n   *\n   * @param {String} attributeName The name of the attribute to be checked.\n   * @returns {Boolean}\n   */\n\n\n  shouldRenderUnsafeAttribute(attributeName) {\n    return this._unsafeAttributesToRender.includes(attributeName);\n  }\n  /**\n   * Clones provided element.\n   *\n   * @protected\n   * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n   * element will be cloned without any children.\n   * @returns {module:engine/view/element~Element} Clone of this element.\n   */\n\n\n  _clone(deep = false) {\n    const childrenClone = [];\n\n    if (deep) {\n      for (const child of this.getChildren()) {\n        childrenClone.push(child._clone(deep));\n      }\n    } // ContainerElement and AttributeElement should be also cloned properly.\n\n\n    const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone); // Classes and styles are cloned separately - this solution is faster than adding them back to attributes and\n    // parse once again in constructor.\n\n    cloned._classes = new Set(this._classes);\n\n    cloned._styles.set(this._styles.getNormalized()); // Clone custom properties.\n\n\n    cloned._customProperties = new Map(this._customProperties); // Clone filler offset method.\n    // We can't define this method in a prototype because it's behavior which\n    // is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.\n\n    cloned.getFillerOffset = this.getFillerOffset;\n    cloned._isAllowedInsideAttributeElement = this.isAllowedInsideAttributeElement;\n    return cloned;\n  }\n  /**\n   * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node\n   * and sets the parent of these nodes to this element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#insert\n   * @protected\n   * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n   * @fires module:engine/view/node~Node#change\n   * @returns {Number} Number of appended nodes.\n   */\n\n\n  _appendChild(items) {\n    return this._insertChild(this.childCount, items);\n  }\n  /**\n   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n   * this element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#insert\n   * @protected\n   * @param {Number} index Position where nodes should be inserted.\n   * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n   * @fires module:engine/view/node~Node#change\n   * @returns {Number} Number of inserted nodes.\n   */\n\n\n  _insertChild(index, items) {\n    this._fireChange('children', this);\n\n    let count = 0;\n    const nodes = normalize(this.document, items);\n\n    for (const node of nodes) {\n      // If node that is being added to this element is already inside another element, first remove it from the old parent.\n      if (node.parent !== null) {\n        node._remove();\n      }\n\n      node.parent = this;\n      node.document = this.document;\n\n      this._children.splice(index, 0, node);\n\n      index++;\n      count++;\n    }\n\n    return count;\n  }\n  /**\n   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#remove\n   * @protected\n   * @param {Number} index Number of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @fires module:engine/view/node~Node#change\n   * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n   */\n\n\n  _removeChildren(index, howMany = 1) {\n    this._fireChange('children', this);\n\n    for (let i = index; i < index + howMany; i++) {\n      this._children[i].parent = null;\n    }\n\n    return this._children.splice(index, howMany);\n  }\n  /**\n   * Adds or overwrite attribute with a specified key and value.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute\n   * @protected\n   * @param {String} key Attribute key.\n   * @param {String} value Attribute value.\n   * @fires module:engine/view/node~Node#change\n   */\n\n\n  _setAttribute(key, value) {\n    value = String(value);\n\n    this._fireChange('attributes', this);\n\n    if (key == 'class') {\n      parseClasses(this._classes, value);\n    } else if (key == 'style') {\n      this._styles.setTo(value);\n    } else {\n      this._attrs.set(key, value);\n    }\n  }\n  /**\n   * Removes attribute from the element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute\n   * @protected\n   * @param {String} key Attribute key.\n   * @returns {Boolean} Returns true if an attribute existed and has been removed.\n   * @fires module:engine/view/node~Node#change\n   */\n\n\n  _removeAttribute(key) {\n    this._fireChange('attributes', this); // Remove class attribute.\n\n\n    if (key == 'class') {\n      if (this._classes.size > 0) {\n        this._classes.clear();\n\n        return true;\n      }\n\n      return false;\n    } // Remove style attribute.\n\n\n    if (key == 'style') {\n      if (!this._styles.isEmpty) {\n        this._styles.clear();\n\n        return true;\n      }\n\n      return false;\n    } // Remove other attributes.\n\n\n    return this._attrs.delete(key);\n  }\n  /**\n   * Adds specified class.\n   *\n   *\t\telement._addClass( 'foo' ); // Adds 'foo' class.\n   *\t\telement._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#addClass\n   * @protected\n   * @param {Array.<String>|String} className\n   * @fires module:engine/view/node~Node#change\n   */\n\n\n  _addClass(className) {\n    this._fireChange('attributes', this);\n\n    for (const name of toArray(className)) {\n      this._classes.add(name);\n    }\n  }\n  /**\n   * Removes specified class.\n   *\n   *\t\telement._removeClass( 'foo' );  // Removes 'foo' class.\n   *\t\telement._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#removeClass\n   * @protected\n   * @param {Array.<String>|String} className\n   * @fires module:engine/view/node~Node#change\n   */\n\n\n  _removeClass(className) {\n    this._fireChange('attributes', this);\n\n    for (const name of toArray(className)) {\n      this._classes.delete(name);\n    }\n  }\n  /**\n   * Adds style to the element.\n   *\n   *\t\telement._setStyle( 'color', 'red' );\n   *\t\telement._setStyle( {\n   *\t\t\tcolor: 'red',\n   *\t\t\tposition: 'fixed'\n   *\t\t} );\n   *\n   * **Note**: This method can work with normalized style names if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#setStyle\n   * @protected\n   * @param {String|Object} property Property name or object with key - value pairs.\n   * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n   * @fires module:engine/view/node~Node#change\n   */\n\n\n  _setStyle(property, value) {\n    this._fireChange('attributes', this);\n\n    this._styles.set(property, value);\n  }\n  /**\n   * Removes specified style.\n   *\n   *\t\telement._removeStyle( 'color' );  // Removes 'color' style.\n   *\t\telement._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.\n   *\n   * **Note**: This method can work with normalized style names if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle\n   * @protected\n   * @param {Array.<String>|String} property\n   * @fires module:engine/view/node~Node#change\n   */\n\n\n  _removeStyle(property) {\n    this._fireChange('attributes', this);\n\n    for (const name of toArray(property)) {\n      this._styles.remove(name);\n    }\n  }\n  /**\n   * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,\n   * so they can be used to add special data to elements.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty\n   * @protected\n   * @param {String|Symbol} key\n   * @param {*} value\n   */\n\n\n  _setCustomProperty(key, value) {\n    this._customProperties.set(key, value);\n  }\n  /**\n   * Removes the custom property stored under the given key.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty\n   * @protected\n   * @param {String|Symbol} key\n   * @returns {Boolean} Returns true if property was removed.\n   */\n\n\n  _removeCustomProperty(key) {\n    return this._customProperties.delete(key);\n  }\n  /**\n   * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n   *\n   * @abstract\n   * @method module:engine/view/element~Element#getFillerOffset\n   */\n  // @if CK_DEBUG_ENGINE // printTree( level = 0) {\n  // @if CK_DEBUG_ENGINE // \tlet string = '';\n  // @if CK_DEBUG_ENGINE //\tstring += '\\t'.repeat( level ) + `<${ this.name }${ convertMapToTags( this.getAttributes() ) }>`;\n  // @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n  // @if CK_DEBUG_ENGINE //\t\tif ( child.is( '$text' ) ) {\n  // @if CK_DEBUG_ENGINE //\t\t\tstring += '\\n' + '\\t'.repeat( level + 1 ) + child.data;\n  // @if CK_DEBUG_ENGINE //\t\t} else {\n  // @if CK_DEBUG_ENGINE //\t\t\tstring += '\\n' + child.printTree( level + 1 );\n  // @if CK_DEBUG_ENGINE //\t\t}\n  // @if CK_DEBUG_ENGINE //\t}\n  // @if CK_DEBUG_ENGINE //\tif ( this.childCount ) {\n  // @if CK_DEBUG_ENGINE //\t\tstring += '\\n' + '\\t'.repeat( level );\n  // @if CK_DEBUG_ENGINE //\t}\n  // @if CK_DEBUG_ENGINE //\tstring += `</${ this.name }>`;\n  // @if CK_DEBUG_ENGINE //\treturn string;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logTree() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n  // @if CK_DEBUG_ENGINE // }\n\n\n} // Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed\n// as an object (instead of `Iterable`), the object is transformed to the map. Attributes with `null` value are removed.\n// Attributes with non-`String` value are converted to `String`.\n//\n// @param {Object|Iterable} attrs Attributes to parse.\n// @returns {Map} Parsed attributes.\n\nfunction parseAttributes(attrs) {\n  attrs = toMap(attrs);\n\n  for (const [key, value] of attrs) {\n    if (value === null) {\n      attrs.delete(key);\n    } else if (typeof value != 'string') {\n      attrs.set(key, String(value));\n    }\n  }\n\n  return attrs;\n} // Parses class attribute and puts all classes into classes set.\n// Classes set s cleared before insertion.\n//\n// @param {Set.<String>} classesSet Set to insert parsed classes.\n// @param {String} classesString String with classes to parse.\n\n\nfunction parseClasses(classesSet, classesString) {\n  const classArray = classesString.split(/\\s+/);\n  classesSet.clear();\n  classArray.forEach(name => classesSet.add(name));\n} // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\n\n\nfunction normalize(document, nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(document, nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(node => {\n    if (typeof node == 'string') {\n      return new Text(document, node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(document, node.data);\n    }\n\n    return node;\n  });\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-engine/src/view/element.js"],"names":["Node","Text","TextProxy","toMap","toArray","isIterable","Matcher","StylesMap","Element","constructor","document","name","attrs","children","_attrs","parseAttributes","_children","_insertChild","_classes","Set","has","classString","get","parseClasses","delete","_styles","stylesProcessor","setTo","_customProperties","Map","_isAllowedInsideAttributeElement","_unsafeAttributesToRender","childCount","length","isEmpty","isAllowedInsideAttributeElement","is","type","getChild","index","getChildIndex","node","indexOf","getChildren","Symbol","iterator","getAttributeKeys","size","keys","getAttributes","entries","getAttribute","key","join","undefined","inlineStyle","toString","hasAttribute","isSimilar","otherElement","value","className","property","getStyleNames","getAsString","hasClass","getClassNames","getStyle","getNormalizedStyle","getNormalized","expand","hasStyle","findAncestor","patterns","matcher","parent","match","getCustomProperty","getCustomProperties","getIdentity","classes","Array","from","sort","styles","attributes","map","i","shouldRenderUnsafeAttribute","attributeName","includes","_clone","deep","childrenClone","child","push","cloned","set","getFillerOffset","_appendChild","items","_fireChange","count","nodes","normalize","_remove","splice","_removeChildren","howMany","_setAttribute","String","_removeAttribute","clear","_addClass","add","_removeClass","_setStyle","_removeStyle","remove","_setCustomProperty","_removeCustomProperty","classesSet","classesString","classArray","split","forEach","data"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/element\n */\n\nimport Node from './node';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Matcher from './matcher';\nimport StylesMap from './stylesmap';\n\n// @if CK_DEBUG_ENGINE // const { convertMapToTags } = require( '../dev-utils/utils' );\n\n/**\n * View element.\n *\n * The editing engine does not define a fixed semantics of its elements (it is \"DTD-free\").\n * This is why the type of the {@link module:engine/view/element~Element} need to\n * be defined by the feature developer. When creating an element you should use one of the following methods:\n *\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement `downcastWriter#createContainerElement()`}\n * in order to create a {@link module:engine/view/containerelement~ContainerElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement `downcastWriter#createAttributeElement()`}\n * in order to create a {@link module:engine/view/attributeelement~AttributeElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`}\n * in order to create a {@link module:engine/view/emptyelement~EmptyElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}\n * in order to create a {@link module:engine/view/uielement~UIElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`}\n * in order to create a {@link module:engine/view/editableelement~EditableElement}.\n *\n * Note that for view elements which are not created from the model, like elements from mutations, paste or\n * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element.\n * In such cases the {@link module:engine/view/upcastwriter~UpcastWriter#createElement `UpcastWriter#createElement()`} method\n * should be used to create generic view elements.\n *\n * @extends module:engine/view/node~Node\n */\nexport default class Element extends Node {\n\t/**\n\t * Creates a view element.\n\t *\n\t * Attributes can be passed in various formats:\n\t *\n\t *\t\tnew Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object\n\t *\t\tnew Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator\n\t *\t\tnew Element( viewDocument, 'div', mapOfAttributes ); // map\n\t *\n\t * @protected\n\t * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n\t * @param {String} name Node name.\n\t * @param {Object|Iterable} [attrs] Collection of attributes.\n\t * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n\t * A list of nodes to be inserted into created element.\n\t */\n\tconstructor( document, name, attrs, children ) {\n\t\tsuper( document );\n\n\t\t/**\n\t\t * Name of the element.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Map of attributes, where attributes names are keys and attributes values are values.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map} #_attrs\n\t\t */\n\t\tthis._attrs = parseAttributes( attrs );\n\n\t\t/**\n\t\t * Array of child nodes.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis._children = [];\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\n\t\t/**\n\t\t * Set of classes associated with element instance.\n\t\t *\n\t\t * @protected\n\t\t * @member {Set}\n\t\t */\n\t\tthis._classes = new Set();\n\n\t\tif ( this._attrs.has( 'class' ) ) {\n\t\t\t// Remove class attribute and handle it by class set.\n\t\t\tconst classString = this._attrs.get( 'class' );\n\t\t\tparseClasses( this._classes, classString );\n\t\t\tthis._attrs.delete( 'class' );\n\t\t}\n\n\t\t/**\n\t\t * Normalized styles.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:engine/view/stylesmap~StylesMap} module:engine/view/element~Element#_styles\n\t\t */\n\t\tthis._styles = new StylesMap( this.document.stylesProcessor );\n\n\t\tif ( this._attrs.has( 'style' ) ) {\n\t\t\t// Remove style attribute and handle it by styles map.\n\t\t\tthis._styles.setTo( this._attrs.get( 'style' ) );\n\n\t\t\tthis._attrs.delete( 'style' );\n\t\t}\n\n\t\t/**\n\t\t * Map of custom properties.\n\t\t * Custom properties can be added to element instance, will be cloned but not rendered into DOM.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map}\n\t\t */\n\t\tthis._customProperties = new Map();\n\n\t\t/**\n\t\t * Whether an element is allowed inside an AttributeElement and can be wrapped with\n\t\t * {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t\t *\n\t\t * @protected\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._isAllowedInsideAttributeElement = false;\n\n\t\t/**\n\t\t * A list of attribute names that should be rendered in the editing pipeline even though filtering mechanisms\n\t\t * implemented in the {@link module:engine/view/domconverter~DomConverter} (for instance,\n\t\t * {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute}) would filter them out.\n\t\t *\n\t\t * These attributes can be specified as an option when the element is created by\n\t\t * the {@link module:engine/view/downcastwriter~DowncastWriter}. To check whether an unsafe an attribute should\n\t\t * be permitted, use the {@link #shouldRenderUnsafeAttribute} method.\n\t\t *\n\t\t * @private\n\t\t * @readonly\n\t\t * @member {Array.<String>}\n\t\t */\n\t\tthis._unsafeAttributesToRender = [];\n\t}\n\n\t/**\n\t * Number of element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this element, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this._children.length === 0;\n\t}\n\n\t/**\n\t * Whether the element is allowed inside an AttributeElement and can be wrapped with\n\t * {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAllowedInsideAttributeElement() {\n\t\treturn this._isAllowedInsideAttributeElement;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\telement.is( 'element' ); // -> true\n\t *\t\telement.is( 'node' ); // -> true\n\t *\t\telement.is( 'view:element' ); // -> true\n\t *\t\telement.is( 'view:node' ); // -> true\n\t *\n\t *\t\telement.is( 'model:element' ); // -> false\n\t *\t\telement.is( 'documentSelection' ); // -> false\n\t *\n\t * Assuming that the object being checked is an element, you can also check its\n\t * {@link module:engine/view/element~Element#name name}:\n\t *\n\t *\t\telement.is( 'element', 'img' ); // -> true if this is an <img> element\n\t *\t\ttext.is( 'element', 'img' ); -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type Type to check.\n\t * @param {String} [name] Element name.\n\t * @returns {Boolean}\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type === 'element' || type === 'view:element' ||\n\t\t\t\t// From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n\t\t\t\ttype === 'node' || type === 'view:node';\n\t\t} else {\n\t\t\treturn name === this.name && ( type === 'element' || type === 'view:element' );\n\t\t}\n\t}\n\n\t/**\n\t * Gets child at the given index.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/view/node~Node} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children[ index ];\n\t}\n\n\t/**\n\t * Gets index of the given child node. Returns `-1` if child node is not found.\n\t *\n\t * @param {module:engine/view/node~Node} node Child node.\n\t * @returns {Number} Index of the child node.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.indexOf( node );\n\t}\n\n\t/**\n\t * Gets child nodes iterator.\n\t *\n\t * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.\n\t *\n\t * @returns {Iterable.<String>} Keys for attributes.\n\t */\n\t* getAttributeKeys() {\n\t\tif ( this._classes.size > 0 ) {\n\t\t\tyield 'class';\n\t\t}\n\n\t\tif ( !this._styles.isEmpty ) {\n\t\t\tyield 'style';\n\t\t}\n\n\t\tyield* this._attrs.keys();\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this element's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t* getAttributes() {\n\t\tyield* this._attrs.entries();\n\n\t\tif ( this._classes.size > 0 ) {\n\t\t\tyield [ 'class', this.getAttribute( 'class' ) ];\n\t\t}\n\n\t\tif ( !this._styles.isEmpty ) {\n\t\t\tyield [ 'style', this.getAttribute( 'style' ) ];\n\t\t}\n\t}\n\n\t/**\n\t * Gets attribute by key. If attribute is not present - returns undefined.\n\t *\n\t * @param {String} key Attribute key.\n\t * @returns {String|undefined} Attribute value.\n\t */\n\tgetAttribute( key ) {\n\t\tif ( key == 'class' ) {\n\t\t\tif ( this._classes.size > 0 ) {\n\t\t\t\treturn [ ...this._classes ].join( ' ' );\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ( key == 'style' ) {\n\t\t\tconst inlineStyle = this._styles.toString();\n\n\t\t\treturn inlineStyle == '' ? undefined : inlineStyle;\n\t\t}\n\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns a boolean indicating whether an attribute with the specified key exists in the element.\n\t *\n\t * @param {String} key Attribute key.\n\t * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.\n\t */\n\thasAttribute( key ) {\n\t\tif ( key == 'class' ) {\n\t\t\treturn this._classes.size > 0;\n\t\t}\n\n\t\tif ( key == 'style' ) {\n\t\t\treturn !this._styles.isEmpty;\n\t\t}\n\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Checks if this element is similar to other element.\n\t * Both elements should have the same name and attributes to be considered as similar. Two similar elements\n\t * can contain different set of children nodes.\n\t *\n\t * @param {module:engine/view/element~Element} otherElement\n\t * @returns {Boolean}\n\t */\n\tisSimilar( otherElement ) {\n\t\tif ( !( otherElement instanceof Element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If exactly the same Element is provided - return true immediately.\n\t\tif ( this === otherElement ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check element name.\n\t\tif ( this.name != otherElement.name ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check isAllowedInsideAttributeElement property.\n\t\tif ( this.isAllowedInsideAttributeElement != otherElement.isAllowedInsideAttributeElement ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check number of attributes, classes and styles.\n\t\tif ( this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size ||\n\t\t\tthis._styles.size !== otherElement._styles.size ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if attributes are the same.\n\t\tfor ( const [ key, value ] of this._attrs ) {\n\t\t\tif ( !otherElement._attrs.has( key ) || otherElement._attrs.get( key ) !== value ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if classes are the same.\n\t\tfor ( const className of this._classes ) {\n\t\t\tif ( !otherElement._classes.has( className ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if styles are the same.\n\t\tfor ( const property of this._styles.getStyleNames() ) {\n\t\t\tif (\n\t\t\t\t!otherElement._styles.has( property ) ||\n\t\t\t\totherElement._styles.getAsString( property ) !== this._styles.getAsString( property )\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns true if class is present.\n\t * If more then one class is provided - returns true only when all classes are present.\n\t *\n\t *\t\telement.hasClass( 'foo' ); // Returns true if 'foo' class is present.\n\t *\t\telement.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.\n\t *\n\t * @param {...String} className\n\t */\n\thasClass( ...className ) {\n\t\tfor ( const name of className ) {\n\t\t\tif ( !this._classes.has( name ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns iterator that contains all class names.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetClassNames() {\n\t\treturn this._classes.keys();\n\t}\n\n\t/**\n\t * Returns style value for the given property mae.\n\t * If the style does not exist `undefined` is returned.\n\t *\n\t * **Note**: This method can work with normalized style names if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.\n\t *\n\t * For an element with style set to `'margin:1px'`:\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tconst element = view.change( writer => {\n\t *\t\t\tconst element = writer.createElement();\n\t *\t\t\twriter.setStyle( 'margin', '1px' );\n\t *\t\t\twriter.setStyle( 'margin-bottom', '3em' );\n\t *\n\t *\t\t\treturn element;\n\t *\t\t} );\n\t *\n\t *\t\telement.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'\n\t *\n\t * @param {String} property\n\t * @returns {String|undefined}\n\t */\n\tgetStyle( property ) {\n\t\treturn this._styles.getAsString( property );\n\t}\n\n\t/**\n\t * Returns a normalized style object or single style value.\n\t *\n\t * For an element with style set to: margin:1px 2px 3em;\n\t *\n\t *\t\telement.getNormalizedStyle( 'margin' ) );\n\t *\n\t * will return:\n\t *\n\t *\t\t{\n\t *\t\t\ttop: '1px',\n\t *\t\t\tright: '2px',\n\t *\t\t\tbottom: '3em',\n\t *\t\t\tleft: '2px'    // a normalized value from margin shorthand\n\t *\t\t}\n\t *\n\t * and reading for single style value:\n\t *\n\t *\t\tstyles.getNormalizedStyle( 'margin-left' );\n\t *\n\t * Will return a `2px` string.\n\t *\n\t * **Note**: This method will return normalized values only if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.\n\t *\n\t *\n\t * @param {String} property Name of CSS property\n\t * @returns {Object|String|undefined}\n\t */\n\tgetNormalizedStyle( property ) {\n\t\treturn this._styles.getNormalized( property );\n\t}\n\n\t/**\n\t * Returns iterator that contains all style names.\n\t *\n\t * @param {Boolean} [expand=false] Expand shorthand style properties and return all equivalent style representations.\n\t * @returns {Iterable.<String>}\n\t */\n\tgetStyleNames( expand = false ) {\n\t\treturn this._styles.getStyleNames( expand );\n\t}\n\n\t/**\n\t * Returns true if style keys are present.\n\t * If more then one style property is provided - returns true only when all properties are present.\n\t *\n\t *\t\telement.hasStyle( 'color' ); // Returns true if 'border-top' style is present.\n\t *\t\telement.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.\n\t *\n\t * @param {...String} property\n\t */\n\thasStyle( ...property ) {\n\t\tfor ( const name of property ) {\n\t\t\tif ( !this._styles.has( name ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns ancestor element that match specified pattern.\n\t * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.\n\t *\n\t * @see module:engine/view/matcher~Matcher\n\t * @param {Object|String|RegExp|Function} patterns Patterns used to match correct ancestor.\n\t * See {@link module:engine/view/matcher~Matcher}.\n\t * @returns {module:engine/view/element~Element|null} Found element or `null` if no matching ancestor was found.\n\t */\n\tfindAncestor( ...patterns ) {\n\t\tconst matcher = new Matcher( ...patterns );\n\t\tlet parent = this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( matcher.match( parent ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the custom property value for the given key.\n\t *\n\t * @param {String|Symbol} key\n\t * @returns {*}\n\t */\n\tgetCustomProperty( key ) {\n\t\treturn this._customProperties.get( key );\n\t}\n\n\t/**\n\t * Returns an iterator which iterates over this element's custom properties.\n\t * Iterator provides `[ key, value ]` pairs for each stored property.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t* getCustomProperties() {\n\t\tyield* this._customProperties.entries();\n\t}\n\n\t/**\n\t * Returns identity string based on element's name, styles, classes and other attributes.\n\t * Two elements that {@link #isSimilar are similar} will have same identity string.\n\t * It has the following format:\n\t *\n\t *\t\t'name class=\"class1,class2\" style=\"style1:value1;style2:value2\" attr1=\"val1\" attr2=\"val2\"'\n \t *\n\t * For example:\n\t *\n\t *\t\tconst element = writer.createContainerElement( 'foo', {\n\t *\t\t\tbanana: '10',\n\t *\t\t\tapple: '20',\n\t *\t\t\tstyle: 'color: red; border-color: white;',\n\t *\t\t\tclass: 'baz'\n\t *\t\t} );\n\t *\n\t *\t\t// returns 'foo class=\"baz\" style=\"border-color:white;color:red\" apple=\"20\" banana=\"10\"'\n\t *\t\telement.getIdentity();\n\t *\n\t * **Note**: Classes, styles and other attributes are sorted alphabetically.\n\t *\n\t * @returns {String}\n\t */\n\tgetIdentity() {\n\t\tconst classes = Array.from( this._classes ).sort().join( ',' );\n\t\tconst styles = this._styles.toString();\n\t\tconst attributes = Array.from( this._attrs ).map( i => `${ i[ 0 ] }=\"${ i[ 1 ] }\"` ).sort().join( ' ' );\n\n\t\treturn this.name +\n\t\t\t( classes == '' ? '' : ` class=\"${ classes }\"` ) +\n\t\t\t( !styles ? '' : ` style=\"${ styles }\"` ) +\n\t\t\t( attributes == '' ? '' : ` ${ attributes }` );\n\t}\n\n\t/**\n\t * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms\n\t * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.\n\t *\n\t * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t *\n\t * @param {String} attributeName The name of the attribute to be checked.\n\t * @returns {Boolean}\n\t */\n\tshouldRenderUnsafeAttribute( attributeName ) {\n\t\treturn this._unsafeAttributesToRender.includes( attributeName );\n\t}\n\n\t/**\n\t * Clones provided element.\n\t *\n\t * @protected\n\t * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any children.\n\t * @returns {module:engine/view/element~Element} Clone of this element.\n\t */\n\t_clone( deep = false ) {\n\t\tconst childrenClone = [];\n\n\t\tif ( deep ) {\n\t\t\tfor ( const child of this.getChildren() ) {\n\t\t\t\tchildrenClone.push( child._clone( deep ) );\n\t\t\t}\n\t\t}\n\n\t\t// ContainerElement and AttributeElement should be also cloned properly.\n\t\tconst cloned = new this.constructor( this.document, this.name, this._attrs, childrenClone );\n\n\t\t// Classes and styles are cloned separately - this solution is faster than adding them back to attributes and\n\t\t// parse once again in constructor.\n\t\tcloned._classes = new Set( this._classes );\n\t\tcloned._styles.set( this._styles.getNormalized() );\n\n\t\t// Clone custom properties.\n\t\tcloned._customProperties = new Map( this._customProperties );\n\n\t\t// Clone filler offset method.\n\t\t// We can't define this method in a prototype because it's behavior which\n\t\t// is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.\n\t\tcloned.getFillerOffset = this.getFillerOffset;\n\n\t\tcloned._isAllowedInsideAttributeElement = this.isAllowedInsideAttributeElement;\n\n\t\treturn cloned;\n\t}\n\n\t/**\n\t * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node\n\t * and sets the parent of these nodes to this element.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#insert\n\t * @protected\n\t * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n\t * @fires module:engine/view/node~Node#change\n\t * @returns {Number} Number of appended nodes.\n\t */\n\t_appendChild( items ) {\n\t\treturn this._insertChild( this.childCount, items );\n\t}\n\n\t/**\n\t * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n\t * this element.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#insert\n\t * @protected\n\t * @param {Number} index Position where nodes should be inserted.\n\t * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n\t * @fires module:engine/view/node~Node#change\n\t * @returns {Number} Number of inserted nodes.\n\t */\n\t_insertChild( index, items ) {\n\t\tthis._fireChange( 'children', this );\n\t\tlet count = 0;\n\n\t\tconst nodes = normalize( this.document, items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t\tnode.document = this.document;\n\n\t\t\tthis._children.splice( index, 0, node );\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#remove\n\t * @protected\n\t * @param {Number} index Number of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @fires module:engine/view/node~Node#change\n\t * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tthis._fireChange( 'children', this );\n\n\t\tfor ( let i = index; i < index + howMany; i++ ) {\n\t\t\tthis._children[ i ].parent = null;\n\t\t}\n\n\t\treturn this._children.splice( index, howMany );\n\t}\n\n\t/**\n\t * Adds or overwrite attribute with a specified key and value.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute\n\t * @protected\n\t * @param {String} key Attribute key.\n\t * @param {String} value Attribute value.\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_setAttribute( key, value ) {\n\t\tvalue = String( value );\n\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tif ( key == 'class' ) {\n\t\t\tparseClasses( this._classes, value );\n\t\t} else if ( key == 'style' ) {\n\t\t\tthis._styles.setTo( value );\n\t\t} else {\n\t\t\tthis._attrs.set( key, value );\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute from the element.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute\n\t * @protected\n\t * @param {String} key Attribute key.\n\t * @returns {Boolean} Returns true if an attribute existed and has been removed.\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_removeAttribute( key ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\t// Remove class attribute.\n\t\tif ( key == 'class' ) {\n\t\t\tif ( this._classes.size > 0 ) {\n\t\t\t\tthis._classes.clear();\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// Remove style attribute.\n\t\tif ( key == 'style' ) {\n\t\t\tif ( !this._styles.isEmpty ) {\n\t\t\t\tthis._styles.clear();\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// Remove other attributes.\n\t\treturn this._attrs.delete( key );\n\t}\n\n\t/**\n\t * Adds specified class.\n\t *\n\t *\t\telement._addClass( 'foo' ); // Adds 'foo' class.\n\t *\t\telement._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#addClass\n\t * @protected\n\t * @param {Array.<String>|String} className\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_addClass( className ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tfor ( const name of toArray( className ) ) {\n\t\t\tthis._classes.add( name );\n\t\t}\n\t}\n\n\t/**\n\t * Removes specified class.\n\t *\n\t *\t\telement._removeClass( 'foo' );  // Removes 'foo' class.\n\t *\t\telement._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#removeClass\n\t * @protected\n\t * @param {Array.<String>|String} className\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_removeClass( className ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tfor ( const name of toArray( className ) ) {\n\t\t\tthis._classes.delete( name );\n\t\t}\n\t}\n\n\t/**\n\t * Adds style to the element.\n\t *\n\t *\t\telement._setStyle( 'color', 'red' );\n\t *\t\telement._setStyle( {\n\t *\t\t\tcolor: 'red',\n\t *\t\t\tposition: 'fixed'\n\t *\t\t} );\n\t *\n\t * **Note**: This method can work with normalized style names if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#setStyle\n\t * @protected\n\t * @param {String|Object} property Property name or object with key - value pairs.\n\t * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_setStyle( property, value ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tthis._styles.set( property, value );\n\t}\n\n\t/**\n\t * Removes specified style.\n\t *\n\t *\t\telement._removeStyle( 'color' );  // Removes 'color' style.\n\t *\t\telement._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.\n\t *\n\t * **Note**: This method can work with normalized style names if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle\n\t * @protected\n\t * @param {Array.<String>|String} property\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_removeStyle( property ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tfor ( const name of toArray( property ) ) {\n\t\t\tthis._styles.remove( name );\n\t\t}\n\t}\n\n\t/**\n\t * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,\n\t * so they can be used to add special data to elements.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty\n\t * @protected\n\t * @param {String|Symbol} key\n\t * @param {*} value\n\t */\n\t_setCustomProperty( key, value ) {\n\t\tthis._customProperties.set( key, value );\n\t}\n\n\t/**\n\t * Removes the custom property stored under the given key.\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty\n\t * @protected\n\t * @param {String|Symbol} key\n\t * @returns {Boolean} Returns true if property was removed.\n\t */\n\t_removeCustomProperty( key ) {\n\t\treturn this._customProperties.delete( key );\n\t}\n\n\t/**\n\t * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n\t *\n\t * @abstract\n\t * @method module:engine/view/element~Element#getFillerOffset\n\t */\n\n\t// @if CK_DEBUG_ENGINE // printTree( level = 0) {\n\t// @if CK_DEBUG_ENGINE // \tlet string = '';\n\n\t// @if CK_DEBUG_ENGINE //\tstring += '\\t'.repeat( level ) + `<${ this.name }${ convertMapToTags( this.getAttributes() ) }>`;\n\n\t// @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE //\t\tif ( child.is( '$text' ) ) {\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += '\\n' + '\\t'.repeat( level + 1 ) + child.data;\n\t// @if CK_DEBUG_ENGINE //\t\t} else {\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += '\\n' + child.printTree( level + 1 );\n\t// @if CK_DEBUG_ENGINE //\t\t}\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\tif ( this.childCount ) {\n\t// @if CK_DEBUG_ENGINE //\t\tstring += '\\n' + '\\t'.repeat( level );\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\tstring += `</${ this.name }>`;\n\n\t// @if CK_DEBUG_ENGINE //\treturn string;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logTree() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n// Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed\n// as an object (instead of `Iterable`), the object is transformed to the map. Attributes with `null` value are removed.\n// Attributes with non-`String` value are converted to `String`.\n//\n// @param {Object|Iterable} attrs Attributes to parse.\n// @returns {Map} Parsed attributes.\nfunction parseAttributes( attrs ) {\n\tattrs = toMap( attrs );\n\n\tfor ( const [ key, value ] of attrs ) {\n\t\tif ( value === null ) {\n\t\t\tattrs.delete( key );\n\t\t} else if ( typeof value != 'string' ) {\n\t\t\tattrs.set( key, String( value ) );\n\t\t}\n\t}\n\n\treturn attrs;\n}\n\n// Parses class attribute and puts all classes into classes set.\n// Classes set s cleared before insertion.\n//\n// @param {Set.<String>} classesSet Set to insert parsed classes.\n// @param {String} classesString String with classes to parse.\nfunction parseClasses( classesSet, classesString ) {\n\tconst classArray = classesString.split( /\\s+/ );\n\tclassesSet.clear();\n\tclassArray.forEach( name => classesSet.add( name ) );\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\nfunction normalize( document, nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( document, nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( document, node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( document, node.data );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n"]},"metadata":{},"sourceType":"module"}