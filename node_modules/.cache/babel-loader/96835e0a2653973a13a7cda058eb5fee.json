{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/converters\n */\nimport { first } from 'ckeditor5/src/utils';\n/**\n * Returns a function that converts the image view representation:\n *\n *\t\t<figure class=\"image\"><img src=\"...\" alt=\"...\"></img></figure>\n *\n * to the model representation:\n *\n *\t\t<imageBlock src=\"...\" alt=\"...\"></imageBlock>\n *\n * The entire content of the `<figure>` element except the first `<img>` is being converted as children\n * of the `<imageBlock>` model element.\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @returns {Function}\n */\n\nexport function upcastImageFigure(imageUtils) {\n  return dispatcher => {\n    dispatcher.on('element:figure', converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    // Do not convert if this is not an \"image figure\".\n    if (!conversionApi.consumable.test(data.viewItem, {\n      name: true,\n      classes: 'image'\n    })) {\n      return;\n    } // Find an image element inside the figure element.\n\n\n    const viewImage = imageUtils.findViewImgElement(data.viewItem); // Do not convert if image element is absent or was already converted.\n\n    if (!viewImage || !conversionApi.consumable.test(viewImage, {\n      name: true\n    })) {\n      return;\n    } // Consume the figure to prevent other converters from processing it again.\n\n\n    conversionApi.consumable.consume(data.viewItem, {\n      name: true,\n      classes: 'image'\n    }); // Convert view image to model image.\n\n    const conversionResult = conversionApi.convertItem(viewImage, data.modelCursor); // Get image element from conversion result.\n\n    const modelImage = first(conversionResult.modelRange.getItems()); // When image wasn't successfully converted then finish conversion.\n\n    if (!modelImage) {\n      // Revert consumed figure so other features can convert it.\n      conversionApi.consumable.revert(data.viewItem, {\n        name: true,\n        classes: 'image'\n      });\n      return;\n    } // Convert rest of the figure element's children as an image children.\n\n\n    conversionApi.convertChildren(data.viewItem, modelImage);\n    conversionApi.updateConversionResult(modelImage, data);\n  }\n}\n/**\n * Returns a function that converts the image view representation:\n *\n *\t\t<picture><source ... /><source ... />...<img ... /></picture>\n *\n * to the model representation as the `sources` attribute:\n *\n *\t\t<image[Block|Inline] ... sources=\"...\"></image[Block|Inline]>\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @returns {Function}\n */\n\nexport function upcastPicture(imageUtils) {\n  const sourceAttributeNames = ['srcset', 'media', 'type'];\n  return dispatcher => {\n    dispatcher.on('element:picture', converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    const pictureViewElement = data.viewItem; // Do not convert <picture> if already consumed.\n\n    if (!conversionApi.consumable.test(pictureViewElement, {\n      name: true\n    })) {\n      return;\n    }\n\n    const sources = new Map(); // Collect all <source /> elements attribute values.\n\n    for (const childSourceElement of pictureViewElement.getChildren()) {\n      if (childSourceElement.is('element', 'source')) {\n        const attributes = {};\n\n        for (const name of sourceAttributeNames) {\n          if (childSourceElement.hasAttribute(name)) {\n            // Don't collect <source /> attribute if already consumed somewhere else.\n            if (conversionApi.consumable.test(childSourceElement, {\n              attributes: name\n            })) {\n              attributes[name] = childSourceElement.getAttribute(name);\n            }\n          }\n        }\n\n        if (Object.keys(attributes).length) {\n          sources.set(childSourceElement, attributes);\n        }\n      }\n    }\n\n    const imgViewElement = imageUtils.findViewImgElement(pictureViewElement); // Don't convert when a picture has no <img/> inside (it is broken).\n\n    if (!imgViewElement) {\n      return;\n    }\n\n    let modelImage = data.modelCursor.parent; // - In case of an inline image (cursor parent in a <paragraph>), the <img/> must be converted right away\n    // because no converter handled it yet and otherwise there would be no model element to set the sources attribute on.\n    // - In case of a block image, the <figure class=\"image\"> converter (in ImageBlockEditing) converts the\n    // <img/> right away on its own and the modelCursor is already inside an imageBlock and there's nothing special\n    // to do here.\n\n    if (!modelImage.is('element', 'imageBlock')) {\n      const conversionResult = conversionApi.convertItem(imgViewElement, data.modelCursor); // Set image range as conversion result.\n\n      data.modelRange = conversionResult.modelRange; // Continue conversion where image conversion ends.\n\n      data.modelCursor = conversionResult.modelCursor;\n      modelImage = first(conversionResult.modelRange.getItems());\n    }\n\n    conversionApi.consumable.consume(pictureViewElement, {\n      name: true\n    }); // Consume only these <source/> attributes that were actually collected and will be passed on\n    // to the image model element.\n\n    for (const [sourceElement, attributes] of sources) {\n      conversionApi.consumable.consume(sourceElement, {\n        attributes: Object.keys(attributes)\n      });\n    }\n\n    if (sources.size) {\n      conversionApi.writer.setAttribute('sources', Array.from(sources.values()), modelImage);\n    } // Convert rest of the <picture> children as an image children. Other converters may want to consume them.\n\n\n    conversionApi.convertChildren(pictureViewElement, modelImage);\n  }\n}\n/**\n * Converter used to convert the `srcset` model image attribute to the `srcset`, `sizes` and `width` attributes in the view.\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @param {'imageBlock'|'imageInline'} imageType The type of the image.\n * @returns {Function}\n */\n\nexport function downcastSrcsetAttribute(imageUtils, imageType) {\n  return dispatcher => {\n    dispatcher.on(`attribute:srcset:${imageType}`, converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const writer = conversionApi.writer;\n    const element = conversionApi.mapper.toViewElement(data.item);\n    const img = imageUtils.findViewImgElement(element);\n\n    if (data.attributeNewValue === null) {\n      const srcset = data.attributeOldValue;\n\n      if (srcset.data) {\n        writer.removeAttribute('srcset', img);\n        writer.removeAttribute('sizes', img);\n\n        if (srcset.width) {\n          writer.removeAttribute('width', img);\n        }\n      }\n    } else {\n      const srcset = data.attributeNewValue;\n\n      if (srcset.data) {\n        writer.setAttribute('srcset', srcset.data, img); // Always outputting `100vw`. See https://github.com/ckeditor/ckeditor5-image/issues/2.\n\n        writer.setAttribute('sizes', '100vw', img);\n\n        if (srcset.width) {\n          writer.setAttribute('width', srcset.width, img);\n        }\n      }\n    }\n  }\n}\n/**\n * Converts the `source` model attribute to the `<picture><source /><source />...<img /></picture>`\n * view structure.\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @returns {Function}\n */\n\nexport function downcastSourcesAttribute(imageUtils) {\n  return dispatcher => {\n    dispatcher.on('attribute:sources:imageBlock', converter);\n    dispatcher.on('attribute:sources:imageInline', converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const element = conversionApi.mapper.toViewElement(data.item);\n    const imgElement = imageUtils.findViewImgElement(element);\n\n    if (data.attributeNewValue && data.attributeNewValue.length) {\n      // Make sure <picture> does not break attribute elements, for instance <a> in linked images.\n      const pictureElement = viewWriter.createContainerElement('picture', {}, {\n        isAllowedInsideAttributeElement: true\n      });\n\n      for (const sourceAttributes of data.attributeNewValue) {\n        const sourceElement = viewWriter.createEmptyElement('source', sourceAttributes);\n        viewWriter.insert(viewWriter.createPositionAt(pictureElement, 'end'), sourceElement);\n      } // Collect all wrapping attribute elements.\n\n\n      const attributeElements = [];\n      let viewElement = imgElement.parent;\n\n      while (viewElement && viewElement.is('attributeElement')) {\n        const parentElement = viewElement.parent;\n        viewWriter.unwrap(viewWriter.createRangeOn(imgElement), viewElement);\n        attributeElements.unshift(viewElement);\n        viewElement = parentElement;\n      } // Insert the picture and move img into it.\n\n\n      viewWriter.insert(viewWriter.createPositionBefore(imgElement), pictureElement);\n      viewWriter.move(viewWriter.createRangeOn(imgElement), viewWriter.createPositionAt(pictureElement, 'end')); // Apply collected attribute elements over the new picture element.\n\n      for (const attributeElement of attributeElements) {\n        viewWriter.wrap(viewWriter.createRangeOn(pictureElement), attributeElement);\n      }\n    } // Both setting \"sources\" to an empty array and removing the attribute should unwrap the <img />.\n    // Unwrap once if the latter followed the former, though.\n    else if (imgElement.parent.is('element', 'picture')) {\n        const pictureElement = imgElement.parent;\n        viewWriter.move(viewWriter.createRangeOn(imgElement), viewWriter.createPositionBefore(pictureElement));\n        viewWriter.remove(pictureElement);\n      }\n  }\n}\n/**\n * Converter used to convert a given image attribute from the model to the view.\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @param {'imageBlock'|'imageInline'} imageType The type of the image.\n * @param {String} attributeKey The name of the attribute to convert.\n * @returns {Function}\n */\n\nexport function downcastImageAttribute(imageUtils, imageType, attributeKey) {\n  return dispatcher => {\n    dispatcher.on(`attribute:${attributeKey}:${imageType}`, converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const element = conversionApi.mapper.toViewElement(data.item);\n    const img = imageUtils.findViewImgElement(element);\n    viewWriter.setAttribute(data.attributeKey, data.attributeNewValue || '', img);\n  }\n}","map":{"version":3,"sources":["/Users/oyejin/Surfee/kiwi/node_modules/@ckeditor/ckeditor5-image/src/image/converters.js"],"names":["first","upcastImageFigure","imageUtils","dispatcher","on","converter","evt","data","conversionApi","consumable","test","viewItem","name","classes","viewImage","findViewImgElement","consume","conversionResult","convertItem","modelCursor","modelImage","modelRange","getItems","revert","convertChildren","updateConversionResult","upcastPicture","sourceAttributeNames","pictureViewElement","sources","Map","childSourceElement","getChildren","is","attributes","hasAttribute","getAttribute","Object","keys","length","set","imgViewElement","parent","sourceElement","size","writer","setAttribute","Array","from","values","downcastSrcsetAttribute","imageType","item","element","mapper","toViewElement","img","attributeNewValue","srcset","attributeOldValue","removeAttribute","width","downcastSourcesAttribute","viewWriter","imgElement","pictureElement","createContainerElement","isAllowedInsideAttributeElement","sourceAttributes","createEmptyElement","insert","createPositionAt","attributeElements","viewElement","parentElement","unwrap","createRangeOn","unshift","createPositionBefore","move","attributeElement","wrap","remove","downcastImageAttribute","attributeKey"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,KAAT,QAAsB,qBAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,iBAAT,CAA4BC,UAA5B,EAAyC;AAC/C,SAAOC,UAAU,IAAI;AACpBA,IAAAA,UAAU,CAACC,EAAX,CAAe,gBAAf,EAAiCC,SAAjC;AACA,GAFD;;AAIA,WAASA,SAAT,CAAoBC,GAApB,EAAyBC,IAAzB,EAA+BC,aAA/B,EAA+C;AAC9C;AACA,QAAK,CAACA,aAAa,CAACC,UAAd,CAAyBC,IAAzB,CAA+BH,IAAI,CAACI,QAApC,EAA8C;AAAEC,MAAAA,IAAI,EAAE,IAAR;AAAcC,MAAAA,OAAO,EAAE;AAAvB,KAA9C,CAAN,EAAyF;AACxF;AACA,KAJ6C,CAM9C;;;AACA,UAAMC,SAAS,GAAGZ,UAAU,CAACa,kBAAX,CAA+BR,IAAI,CAACI,QAApC,CAAlB,CAP8C,CAS9C;;AACA,QAAK,CAACG,SAAD,IAAc,CAACN,aAAa,CAACC,UAAd,CAAyBC,IAAzB,CAA+BI,SAA/B,EAA0C;AAAEF,MAAAA,IAAI,EAAE;AAAR,KAA1C,CAApB,EAAiF;AAChF;AACA,KAZ6C,CAc9C;;;AACAJ,IAAAA,aAAa,CAACC,UAAd,CAAyBO,OAAzB,CAAkCT,IAAI,CAACI,QAAvC,EAAiD;AAAEC,MAAAA,IAAI,EAAE,IAAR;AAAcC,MAAAA,OAAO,EAAE;AAAvB,KAAjD,EAf8C,CAiB9C;;AACA,UAAMI,gBAAgB,GAAGT,aAAa,CAACU,WAAd,CAA2BJ,SAA3B,EAAsCP,IAAI,CAACY,WAA3C,CAAzB,CAlB8C,CAoB9C;;AACA,UAAMC,UAAU,GAAGpB,KAAK,CAAEiB,gBAAgB,CAACI,UAAjB,CAA4BC,QAA5B,EAAF,CAAxB,CArB8C,CAuB9C;;AACA,QAAK,CAACF,UAAN,EAAmB;AAClB;AACAZ,MAAAA,aAAa,CAACC,UAAd,CAAyBc,MAAzB,CAAiChB,IAAI,CAACI,QAAtC,EAAgD;AAAEC,QAAAA,IAAI,EAAE,IAAR;AAAcC,QAAAA,OAAO,EAAE;AAAvB,OAAhD;AAEA;AACA,KA7B6C,CA+B9C;;;AACAL,IAAAA,aAAa,CAACgB,eAAd,CAA+BjB,IAAI,CAACI,QAApC,EAA8CS,UAA9C;AAEAZ,IAAAA,aAAa,CAACiB,sBAAd,CAAsCL,UAAtC,EAAkDb,IAAlD;AACA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASmB,aAAT,CAAwBxB,UAAxB,EAAqC;AAC3C,QAAMyB,oBAAoB,GAAG,CAAE,QAAF,EAAY,OAAZ,EAAqB,MAArB,CAA7B;AAEA,SAAOxB,UAAU,IAAI;AACpBA,IAAAA,UAAU,CAACC,EAAX,CAAe,iBAAf,EAAkCC,SAAlC;AACA,GAFD;;AAIA,WAASA,SAAT,CAAoBC,GAApB,EAAyBC,IAAzB,EAA+BC,aAA/B,EAA+C;AAC9C,UAAMoB,kBAAkB,GAAGrB,IAAI,CAACI,QAAhC,CAD8C,CAG9C;;AACA,QAAK,CAACH,aAAa,CAACC,UAAd,CAAyBC,IAAzB,CAA+BkB,kBAA/B,EAAmD;AAAEhB,MAAAA,IAAI,EAAE;AAAR,KAAnD,CAAN,EAA4E;AAC3E;AACA;;AAED,UAAMiB,OAAO,GAAG,IAAIC,GAAJ,EAAhB,CAR8C,CAU9C;;AACA,SAAM,MAAMC,kBAAZ,IAAkCH,kBAAkB,CAACI,WAAnB,EAAlC,EAAqE;AACpE,UAAKD,kBAAkB,CAACE,EAAnB,CAAuB,SAAvB,EAAkC,QAAlC,CAAL,EAAoD;AACnD,cAAMC,UAAU,GAAG,EAAnB;;AAEA,aAAM,MAAMtB,IAAZ,IAAoBe,oBAApB,EAA2C;AAC1C,cAAKI,kBAAkB,CAACI,YAAnB,CAAiCvB,IAAjC,CAAL,EAA+C;AAC9C;AACA,gBAAKJ,aAAa,CAACC,UAAd,CAAyBC,IAAzB,CAA+BqB,kBAA/B,EAAmD;AAAEG,cAAAA,UAAU,EAAEtB;AAAd,aAAnD,CAAL,EAAiF;AAChFsB,cAAAA,UAAU,CAAEtB,IAAF,CAAV,GAAqBmB,kBAAkB,CAACK,YAAnB,CAAiCxB,IAAjC,CAArB;AACA;AACD;AACD;;AAED,YAAKyB,MAAM,CAACC,IAAP,CAAaJ,UAAb,EAA0BK,MAA/B,EAAwC;AACvCV,UAAAA,OAAO,CAACW,GAAR,CAAaT,kBAAb,EAAiCG,UAAjC;AACA;AACD;AACD;;AAED,UAAMO,cAAc,GAAGvC,UAAU,CAACa,kBAAX,CAA+Ba,kBAA/B,CAAvB,CA9B8C,CAgC9C;;AACA,QAAK,CAACa,cAAN,EAAuB;AACtB;AACA;;AAED,QAAIrB,UAAU,GAAGb,IAAI,CAACY,WAAL,CAAiBuB,MAAlC,CArC8C,CAuC9C;AACA;AACA;AACA;AACA;;AACA,QAAK,CAACtB,UAAU,CAACa,EAAX,CAAe,SAAf,EAA0B,YAA1B,CAAN,EAAiD;AAChD,YAAMhB,gBAAgB,GAAGT,aAAa,CAACU,WAAd,CAA2BuB,cAA3B,EAA2ClC,IAAI,CAACY,WAAhD,CAAzB,CADgD,CAGhD;;AACAZ,MAAAA,IAAI,CAACc,UAAL,GAAkBJ,gBAAgB,CAACI,UAAnC,CAJgD,CAMhD;;AACAd,MAAAA,IAAI,CAACY,WAAL,GAAmBF,gBAAgB,CAACE,WAApC;AAEAC,MAAAA,UAAU,GAAGpB,KAAK,CAAEiB,gBAAgB,CAACI,UAAjB,CAA4BC,QAA5B,EAAF,CAAlB;AACA;;AAEDd,IAAAA,aAAa,CAACC,UAAd,CAAyBO,OAAzB,CAAkCY,kBAAlC,EAAsD;AAAEhB,MAAAA,IAAI,EAAE;AAAR,KAAtD,EAxD8C,CA0D9C;AACA;;AACA,SAAM,MAAM,CAAE+B,aAAF,EAAiBT,UAAjB,CAAZ,IAA6CL,OAA7C,EAAuD;AACtDrB,MAAAA,aAAa,CAACC,UAAd,CAAyBO,OAAzB,CAAkC2B,aAAlC,EAAiD;AAAET,QAAAA,UAAU,EAAEG,MAAM,CAACC,IAAP,CAAaJ,UAAb;AAAd,OAAjD;AACA;;AAED,QAAKL,OAAO,CAACe,IAAb,EAAoB;AACnBpC,MAAAA,aAAa,CAACqC,MAAd,CAAqBC,YAArB,CAAmC,SAAnC,EAA8CC,KAAK,CAACC,IAAN,CAAYnB,OAAO,CAACoB,MAAR,EAAZ,CAA9C,EAA8E7B,UAA9E;AACA,KAlE6C,CAoE9C;;;AACAZ,IAAAA,aAAa,CAACgB,eAAd,CAA+BI,kBAA/B,EAAmDR,UAAnD;AACA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS8B,uBAAT,CAAkChD,UAAlC,EAA8CiD,SAA9C,EAA0D;AAChE,SAAOhD,UAAU,IAAI;AACpBA,IAAAA,UAAU,CAACC,EAAX,CAAgB,oBAAoB+C,SAAW,EAA/C,EAAkD9C,SAAlD;AACA,GAFD;;AAIA,WAASA,SAAT,CAAoBC,GAApB,EAAyBC,IAAzB,EAA+BC,aAA/B,EAA+C;AAC9C,QAAK,CAACA,aAAa,CAACC,UAAd,CAAyBO,OAAzB,CAAkCT,IAAI,CAAC6C,IAAvC,EAA6C9C,GAAG,CAACM,IAAjD,CAAN,EAAgE;AAC/D;AACA;;AAED,UAAMiC,MAAM,GAAGrC,aAAa,CAACqC,MAA7B;AACA,UAAMQ,OAAO,GAAG7C,aAAa,CAAC8C,MAAd,CAAqBC,aAArB,CAAoChD,IAAI,CAAC6C,IAAzC,CAAhB;AACA,UAAMI,GAAG,GAAGtD,UAAU,CAACa,kBAAX,CAA+BsC,OAA/B,CAAZ;;AAEA,QAAK9C,IAAI,CAACkD,iBAAL,KAA2B,IAAhC,EAAuC;AACtC,YAAMC,MAAM,GAAGnD,IAAI,CAACoD,iBAApB;;AAEA,UAAKD,MAAM,CAACnD,IAAZ,EAAmB;AAClBsC,QAAAA,MAAM,CAACe,eAAP,CAAwB,QAAxB,EAAkCJ,GAAlC;AACAX,QAAAA,MAAM,CAACe,eAAP,CAAwB,OAAxB,EAAiCJ,GAAjC;;AAEA,YAAKE,MAAM,CAACG,KAAZ,EAAoB;AACnBhB,UAAAA,MAAM,CAACe,eAAP,CAAwB,OAAxB,EAAiCJ,GAAjC;AACA;AACD;AACD,KAXD,MAWO;AACN,YAAME,MAAM,GAAGnD,IAAI,CAACkD,iBAApB;;AAEA,UAAKC,MAAM,CAACnD,IAAZ,EAAmB;AAClBsC,QAAAA,MAAM,CAACC,YAAP,CAAqB,QAArB,EAA+BY,MAAM,CAACnD,IAAtC,EAA4CiD,GAA5C,EADkB,CAElB;;AACAX,QAAAA,MAAM,CAACC,YAAP,CAAqB,OAArB,EAA8B,OAA9B,EAAuCU,GAAvC;;AAEA,YAAKE,MAAM,CAACG,KAAZ,EAAoB;AACnBhB,UAAAA,MAAM,CAACC,YAAP,CAAqB,OAArB,EAA8BY,MAAM,CAACG,KAArC,EAA4CL,GAA5C;AACA;AACD;AACD;AACD;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,wBAAT,CAAmC5D,UAAnC,EAAgD;AACtD,SAAOC,UAAU,IAAI;AACpBA,IAAAA,UAAU,CAACC,EAAX,CAAe,8BAAf,EAA+CC,SAA/C;AACAF,IAAAA,UAAU,CAACC,EAAX,CAAe,+BAAf,EAAgDC,SAAhD;AACA,GAHD;;AAKA,WAASA,SAAT,CAAoBC,GAApB,EAAyBC,IAAzB,EAA+BC,aAA/B,EAA+C;AAC9C,QAAK,CAACA,aAAa,CAACC,UAAd,CAAyBO,OAAzB,CAAkCT,IAAI,CAAC6C,IAAvC,EAA6C9C,GAAG,CAACM,IAAjD,CAAN,EAAgE;AAC/D;AACA;;AAED,UAAMmD,UAAU,GAAGvD,aAAa,CAACqC,MAAjC;AACA,UAAMQ,OAAO,GAAG7C,aAAa,CAAC8C,MAAd,CAAqBC,aAArB,CAAoChD,IAAI,CAAC6C,IAAzC,CAAhB;AACA,UAAMY,UAAU,GAAG9D,UAAU,CAACa,kBAAX,CAA+BsC,OAA/B,CAAnB;;AAEA,QAAK9C,IAAI,CAACkD,iBAAL,IAA0BlD,IAAI,CAACkD,iBAAL,CAAuBlB,MAAtD,EAA+D;AAC9D;AACA,YAAM0B,cAAc,GAAGF,UAAU,CAACG,sBAAX,CAAmC,SAAnC,EAA8C,EAA9C,EAAkD;AAAEC,QAAAA,+BAA+B,EAAE;AAAnC,OAAlD,CAAvB;;AAEA,WAAM,MAAMC,gBAAZ,IAAgC7D,IAAI,CAACkD,iBAArC,EAAyD;AACxD,cAAMd,aAAa,GAAGoB,UAAU,CAACM,kBAAX,CAA+B,QAA/B,EAAyCD,gBAAzC,CAAtB;AAEAL,QAAAA,UAAU,CAACO,MAAX,CAAmBP,UAAU,CAACQ,gBAAX,CAA6BN,cAA7B,EAA6C,KAA7C,CAAnB,EAAyEtB,aAAzE;AACA,OAR6D,CAU9D;;;AACA,YAAM6B,iBAAiB,GAAG,EAA1B;AACA,UAAIC,WAAW,GAAGT,UAAU,CAACtB,MAA7B;;AAEA,aAAQ+B,WAAW,IAAIA,WAAW,CAACxC,EAAZ,CAAgB,kBAAhB,CAAvB,EAA8D;AAC7D,cAAMyC,aAAa,GAAGD,WAAW,CAAC/B,MAAlC;AAEAqB,QAAAA,UAAU,CAACY,MAAX,CAAmBZ,UAAU,CAACa,aAAX,CAA0BZ,UAA1B,CAAnB,EAA2DS,WAA3D;AAEAD,QAAAA,iBAAiB,CAACK,OAAlB,CAA2BJ,WAA3B;AACAA,QAAAA,WAAW,GAAGC,aAAd;AACA,OArB6D,CAuB9D;;;AACAX,MAAAA,UAAU,CAACO,MAAX,CAAmBP,UAAU,CAACe,oBAAX,CAAiCd,UAAjC,CAAnB,EAAkEC,cAAlE;AACAF,MAAAA,UAAU,CAACgB,IAAX,CAAiBhB,UAAU,CAACa,aAAX,CAA0BZ,UAA1B,CAAjB,EAAyDD,UAAU,CAACQ,gBAAX,CAA6BN,cAA7B,EAA6C,KAA7C,CAAzD,EAzB8D,CA2B9D;;AACA,WAAM,MAAMe,gBAAZ,IAAgCR,iBAAhC,EAAoD;AACnDT,QAAAA,UAAU,CAACkB,IAAX,CAAiBlB,UAAU,CAACa,aAAX,CAA0BX,cAA1B,CAAjB,EAA6De,gBAA7D;AACA;AACD,KA/BD,CAgCA;AACA;AAjCA,SAkCK,IAAKhB,UAAU,CAACtB,MAAX,CAAkBT,EAAlB,CAAsB,SAAtB,EAAiC,SAAjC,CAAL,EAAoD;AACxD,cAAMgC,cAAc,GAAGD,UAAU,CAACtB,MAAlC;AAEAqB,QAAAA,UAAU,CAACgB,IAAX,CAAiBhB,UAAU,CAACa,aAAX,CAA0BZ,UAA1B,CAAjB,EAAyDD,UAAU,CAACe,oBAAX,CAAiCb,cAAjC,CAAzD;AACAF,QAAAA,UAAU,CAACmB,MAAX,CAAmBjB,cAAnB;AACA;AACD;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASkB,sBAAT,CAAiCjF,UAAjC,EAA6CiD,SAA7C,EAAwDiC,YAAxD,EAAuE;AAC7E,SAAOjF,UAAU,IAAI;AACpBA,IAAAA,UAAU,CAACC,EAAX,CAAgB,aAAagF,YAAc,IAAIjC,SAAW,EAA1D,EAA6D9C,SAA7D;AACA,GAFD;;AAIA,WAASA,SAAT,CAAoBC,GAApB,EAAyBC,IAAzB,EAA+BC,aAA/B,EAA+C;AAC9C,QAAK,CAACA,aAAa,CAACC,UAAd,CAAyBO,OAAzB,CAAkCT,IAAI,CAAC6C,IAAvC,EAA6C9C,GAAG,CAACM,IAAjD,CAAN,EAAgE;AAC/D;AACA;;AAED,UAAMmD,UAAU,GAAGvD,aAAa,CAACqC,MAAjC;AACA,UAAMQ,OAAO,GAAG7C,aAAa,CAAC8C,MAAd,CAAqBC,aAArB,CAAoChD,IAAI,CAAC6C,IAAzC,CAAhB;AACA,UAAMI,GAAG,GAAGtD,UAAU,CAACa,kBAAX,CAA+BsC,OAA/B,CAAZ;AAEAU,IAAAA,UAAU,CAACjB,YAAX,CAAyBvC,IAAI,CAAC6E,YAA9B,EAA4C7E,IAAI,CAACkD,iBAAL,IAA0B,EAAtE,EAA0ED,GAA1E;AACA;AACD","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/converters\n */\n\nimport { first } from 'ckeditor5/src/utils';\n\n/**\n * Returns a function that converts the image view representation:\n *\n *\t\t<figure class=\"image\"><img src=\"...\" alt=\"...\"></img></figure>\n *\n * to the model representation:\n *\n *\t\t<imageBlock src=\"...\" alt=\"...\"></imageBlock>\n *\n * The entire content of the `<figure>` element except the first `<img>` is being converted as children\n * of the `<imageBlock>` model element.\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @returns {Function}\n */\nexport function upcastImageFigure( imageUtils ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:figure', converter );\n\t};\n\n\tfunction converter( evt, data, conversionApi ) {\n\t\t// Do not convert if this is not an \"image figure\".\n\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: true, classes: 'image' } ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find an image element inside the figure element.\n\t\tconst viewImage = imageUtils.findViewImgElement( data.viewItem );\n\n\t\t// Do not convert if image element is absent or was already converted.\n\t\tif ( !viewImage || !conversionApi.consumable.test( viewImage, { name: true } ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consume the figure to prevent other converters from processing it again.\n\t\tconversionApi.consumable.consume( data.viewItem, { name: true, classes: 'image' } );\n\n\t\t// Convert view image to model image.\n\t\tconst conversionResult = conversionApi.convertItem( viewImage, data.modelCursor );\n\n\t\t// Get image element from conversion result.\n\t\tconst modelImage = first( conversionResult.modelRange.getItems() );\n\n\t\t// When image wasn't successfully converted then finish conversion.\n\t\tif ( !modelImage ) {\n\t\t\t// Revert consumed figure so other features can convert it.\n\t\t\tconversionApi.consumable.revert( data.viewItem, { name: true, classes: 'image' } );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Convert rest of the figure element's children as an image children.\n\t\tconversionApi.convertChildren( data.viewItem, modelImage );\n\n\t\tconversionApi.updateConversionResult( modelImage, data );\n\t}\n}\n\n/**\n * Returns a function that converts the image view representation:\n *\n *\t\t<picture><source ... /><source ... />...<img ... /></picture>\n *\n * to the model representation as the `sources` attribute:\n *\n *\t\t<image[Block|Inline] ... sources=\"...\"></image[Block|Inline]>\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @returns {Function}\n */\nexport function upcastPicture( imageUtils ) {\n\tconst sourceAttributeNames = [ 'srcset', 'media', 'type' ];\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:picture', converter );\n\t};\n\n\tfunction converter( evt, data, conversionApi ) {\n\t\tconst pictureViewElement = data.viewItem;\n\n\t\t// Do not convert <picture> if already consumed.\n\t\tif ( !conversionApi.consumable.test( pictureViewElement, { name: true } ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst sources = new Map();\n\n\t\t// Collect all <source /> elements attribute values.\n\t\tfor ( const childSourceElement of pictureViewElement.getChildren() ) {\n\t\t\tif ( childSourceElement.is( 'element', 'source' ) ) {\n\t\t\t\tconst attributes = {};\n\n\t\t\t\tfor ( const name of sourceAttributeNames ) {\n\t\t\t\t\tif ( childSourceElement.hasAttribute( name ) ) {\n\t\t\t\t\t\t// Don't collect <source /> attribute if already consumed somewhere else.\n\t\t\t\t\t\tif ( conversionApi.consumable.test( childSourceElement, { attributes: name } ) ) {\n\t\t\t\t\t\t\tattributes[ name ] = childSourceElement.getAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( attributes ).length ) {\n\t\t\t\t\tsources.set( childSourceElement, attributes );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst imgViewElement = imageUtils.findViewImgElement( pictureViewElement );\n\n\t\t// Don't convert when a picture has no <img/> inside (it is broken).\n\t\tif ( !imgViewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet modelImage = data.modelCursor.parent;\n\n\t\t// - In case of an inline image (cursor parent in a <paragraph>), the <img/> must be converted right away\n\t\t// because no converter handled it yet and otherwise there would be no model element to set the sources attribute on.\n\t\t// - In case of a block image, the <figure class=\"image\"> converter (in ImageBlockEditing) converts the\n\t\t// <img/> right away on its own and the modelCursor is already inside an imageBlock and there's nothing special\n\t\t// to do here.\n\t\tif ( !modelImage.is( 'element', 'imageBlock' ) ) {\n\t\t\tconst conversionResult = conversionApi.convertItem( imgViewElement, data.modelCursor );\n\n\t\t\t// Set image range as conversion result.\n\t\t\tdata.modelRange = conversionResult.modelRange;\n\n\t\t\t// Continue conversion where image conversion ends.\n\t\t\tdata.modelCursor = conversionResult.modelCursor;\n\n\t\t\tmodelImage = first( conversionResult.modelRange.getItems() );\n\t\t}\n\n\t\tconversionApi.consumable.consume( pictureViewElement, { name: true } );\n\n\t\t// Consume only these <source/> attributes that were actually collected and will be passed on\n\t\t// to the image model element.\n\t\tfor ( const [ sourceElement, attributes ] of sources ) {\n\t\t\tconversionApi.consumable.consume( sourceElement, { attributes: Object.keys( attributes ) } );\n\t\t}\n\n\t\tif ( sources.size ) {\n\t\t\tconversionApi.writer.setAttribute( 'sources', Array.from( sources.values() ), modelImage );\n\t\t}\n\n\t\t// Convert rest of the <picture> children as an image children. Other converters may want to consume them.\n\t\tconversionApi.convertChildren( pictureViewElement, modelImage );\n\t}\n}\n\n/**\n * Converter used to convert the `srcset` model image attribute to the `srcset`, `sizes` and `width` attributes in the view.\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @param {'imageBlock'|'imageInline'} imageType The type of the image.\n * @returns {Function}\n */\nexport function downcastSrcsetAttribute( imageUtils, imageType ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( `attribute:srcset:${ imageType }`, converter );\n\t};\n\n\tfunction converter( evt, data, conversionApi ) {\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst writer = conversionApi.writer;\n\t\tconst element = conversionApi.mapper.toViewElement( data.item );\n\t\tconst img = imageUtils.findViewImgElement( element );\n\n\t\tif ( data.attributeNewValue === null ) {\n\t\t\tconst srcset = data.attributeOldValue;\n\n\t\t\tif ( srcset.data ) {\n\t\t\t\twriter.removeAttribute( 'srcset', img );\n\t\t\t\twriter.removeAttribute( 'sizes', img );\n\n\t\t\t\tif ( srcset.width ) {\n\t\t\t\t\twriter.removeAttribute( 'width', img );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst srcset = data.attributeNewValue;\n\n\t\t\tif ( srcset.data ) {\n\t\t\t\twriter.setAttribute( 'srcset', srcset.data, img );\n\t\t\t\t// Always outputting `100vw`. See https://github.com/ckeditor/ckeditor5-image/issues/2.\n\t\t\t\twriter.setAttribute( 'sizes', '100vw', img );\n\n\t\t\t\tif ( srcset.width ) {\n\t\t\t\t\twriter.setAttribute( 'width', srcset.width, img );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Converts the `source` model attribute to the `<picture><source /><source />...<img /></picture>`\n * view structure.\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @returns {Function}\n */\nexport function downcastSourcesAttribute( imageUtils ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'attribute:sources:imageBlock', converter );\n\t\tdispatcher.on( 'attribute:sources:imageInline', converter );\n\t};\n\n\tfunction converter( evt, data, conversionApi ) {\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst element = conversionApi.mapper.toViewElement( data.item );\n\t\tconst imgElement = imageUtils.findViewImgElement( element );\n\n\t\tif ( data.attributeNewValue && data.attributeNewValue.length ) {\n\t\t\t// Make sure <picture> does not break attribute elements, for instance <a> in linked images.\n\t\t\tconst pictureElement = viewWriter.createContainerElement( 'picture', {}, { isAllowedInsideAttributeElement: true } );\n\n\t\t\tfor ( const sourceAttributes of data.attributeNewValue ) {\n\t\t\t\tconst sourceElement = viewWriter.createEmptyElement( 'source', sourceAttributes );\n\n\t\t\t\tviewWriter.insert( viewWriter.createPositionAt( pictureElement, 'end' ), sourceElement );\n\t\t\t}\n\n\t\t\t// Collect all wrapping attribute elements.\n\t\t\tconst attributeElements = [];\n\t\t\tlet viewElement = imgElement.parent;\n\n\t\t\twhile ( viewElement && viewElement.is( 'attributeElement' ) ) {\n\t\t\t\tconst parentElement = viewElement.parent;\n\n\t\t\t\tviewWriter.unwrap( viewWriter.createRangeOn( imgElement ), viewElement );\n\n\t\t\t\tattributeElements.unshift( viewElement );\n\t\t\t\tviewElement = parentElement;\n\t\t\t}\n\n\t\t\t// Insert the picture and move img into it.\n\t\t\tviewWriter.insert( viewWriter.createPositionBefore( imgElement ), pictureElement );\n\t\t\tviewWriter.move( viewWriter.createRangeOn( imgElement ), viewWriter.createPositionAt( pictureElement, 'end' ) );\n\n\t\t\t// Apply collected attribute elements over the new picture element.\n\t\t\tfor ( const attributeElement of attributeElements ) {\n\t\t\t\tviewWriter.wrap( viewWriter.createRangeOn( pictureElement ), attributeElement );\n\t\t\t}\n\t\t}\n\t\t// Both setting \"sources\" to an empty array and removing the attribute should unwrap the <img />.\n\t\t// Unwrap once if the latter followed the former, though.\n\t\telse if ( imgElement.parent.is( 'element', 'picture' ) ) {\n\t\t\tconst pictureElement = imgElement.parent;\n\n\t\t\tviewWriter.move( viewWriter.createRangeOn( imgElement ), viewWriter.createPositionBefore( pictureElement ) );\n\t\t\tviewWriter.remove( pictureElement );\n\t\t}\n\t}\n}\n\n/**\n * Converter used to convert a given image attribute from the model to the view.\n *\n * @protected\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @param {'imageBlock'|'imageInline'} imageType The type of the image.\n * @param {String} attributeKey The name of the attribute to convert.\n * @returns {Function}\n */\nexport function downcastImageAttribute( imageUtils, imageType, attributeKey ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( `attribute:${ attributeKey }:${ imageType }`, converter );\n\t};\n\n\tfunction converter( evt, data, conversionApi ) {\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst element = conversionApi.mapper.toViewElement( data.item );\n\t\tconst img = imageUtils.findViewImgElement( element );\n\n\t\tviewWriter.setAttribute( data.attributeKey, data.attributeNewValue || '', img );\n\t}\n}\n\n"]},"metadata":{},"sourceType":"module"}