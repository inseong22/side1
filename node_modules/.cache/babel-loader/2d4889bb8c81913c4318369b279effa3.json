{"ast":null,"code":"import { hexToRgba } from './';\nexport var equalColorObjects = (first, second) => {\n  if (first === second) return true;\n\n  for (var prop in first) {\n    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)\n    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)\n    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,\n    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if\n    // there is or not), and then as a type TS can iterate over.\n    if (first[prop] !== second[prop]) return false;\n  }\n\n  return true;\n};\nexport var equalColorString = (first, second) => {\n  return first.replace(/\\s/g, '') === second.replace(/\\s/g, '');\n};\nexport var equalHex = (first, second) => {\n  if (first.toLowerCase() === second.toLowerCase()) return true; // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects\n\n  return equalColorObjects(hexToRgba(first), hexToRgba(second));\n};\nexport var validHex = hex => /^#?([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);","map":{"version":3,"sources":["../src/utils.ts"],"names":["equalColorObjects","first","second","equalColorString","equalHex","hexToRgba","validHex","hex"],"mappings":"AAAA,SAAA,SAAA,QAAA,IAAA;AAGA,OAAO,IAAMA,iBAAiB,GAAG,CAAA,KAAA,EAAA,MAAA,KAAsD;AACrF,MAAIC,KAAK,KAAT,MAAA,EAAsB,OAAA,IAAA;;AAEtB,OAAK,IAAL,IAAA,IAAA,KAAA,EAA0B;AACxB;AACA;AACA;AACA;AACA;AACA,QAAKA,KAAD,CAAA,IAAA,CAACA,KAAuDC,MAAD,CAA3D,IAA2D,CAA3D,EAAgH,OAAA,KAAA;AACjH;;AAED,SAAA,IAAA;AAZK,CAAA;AAeP,OAAO,IAAMC,gBAAgB,GAAG,CAAA,KAAA,EAAA,MAAA,KAA4C;AAC1E,SAAOF,KAAK,CAALA,OAAAA,CAAAA,KAAAA,EAAAA,EAAAA,MAA6BC,MAAM,CAANA,OAAAA,CAAAA,KAAAA,EAApC,EAAoCA,CAApC;AADK,CAAA;AAIP,OAAO,IAAME,QAAQ,GAAG,CAAA,KAAA,EAAA,MAAA,KAA4C;AAClE,MAAIH,KAAK,CAALA,WAAAA,OAAwBC,MAAM,CAAlC,WAA4BA,EAA5B,EAAkD,OADgB,IAChB,CADgB,CAGlE;;AACA,SAAOF,iBAAiB,CAACK,SAAS,CAAV,KAAU,CAAV,EAAmBA,SAAS,CAApD,MAAoD,CAA5B,CAAxB;AAJK,CAAA;AAOP,OAAO,IAAMC,QAAQ,GAAIC,GAAD,IAA0B,8BAAA,IAAA,CAA3C,GAA2C,CAA3C","sourcesContent":["import { hexToRgba } from './';\nimport { ObjectColor } from './';\n\nexport const equalColorObjects = (first: ObjectColor, second: ObjectColor): boolean => {\n  if (first === second) return true;\n\n  for (const prop in first) {\n    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)\n    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)\n    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,\n    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if\n    // there is or not), and then as a type TS can iterate over.\n    if ((first as unknown as Record<string, number>)[prop] !== (second as unknown as Record<string, number>)[prop]) return false;\n  }\n\n  return true;\n};\n\nexport const equalColorString = (first: string, second: string): boolean => {\n  return first.replace(/\\s/g, '') === second.replace(/\\s/g, '');\n};\n\nexport const equalHex = (first: string, second: string): boolean => {\n  if (first.toLowerCase() === second.toLowerCase()) return true;\n\n  // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects\n  return equalColorObjects(hexToRgba(first), hexToRgba(second));\n};\n\nexport const validHex = (hex: string): boolean => /^#?([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);\n"]},"metadata":{},"sourceType":"module"}