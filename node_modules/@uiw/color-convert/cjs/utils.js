"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validHex = exports.equalHex = exports.equalColorString = exports.equalColorObjects = void 0;

var _ = require("./");

var equalColorObjects = function equalColorObjects(first, second) {
  if (first === second) return true;

  for (var prop in first) {
    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)
    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)
    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,
    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if
    // there is or not), and then as a type TS can iterate over.
    if (first[prop] !== second[prop]) return false;
  }

  return true;
};

exports.equalColorObjects = equalColorObjects;

var equalColorString = function equalColorString(first, second) {
  return first.replace(/\s/g, '') === second.replace(/\s/g, '');
};

exports.equalColorString = equalColorString;

var equalHex = function equalHex(first, second) {
  if (first.toLowerCase() === second.toLowerCase()) return true; // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects

  return equalColorObjects((0, _.hexToRgba)(first), (0, _.hexToRgba)(second));
};

exports.equalHex = equalHex;

var validHex = function validHex(hex) {
  return /^#?([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);
};

exports.validHex = validHex;
//# sourceMappingURL=utils.js.map